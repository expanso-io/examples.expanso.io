---
title: "Step 3: Hash Email and Extract Domain"
sidebar_label: "Step 3: Hash Email"
sidebar_position: 6
description: Hash email addresses for user counting while extracting domains for organizational analytics
keywords: [gdpr, email, hashing, domain-extraction, privacy, analytics]
---

# Step 3: Hash Email and Extract Domain

**Learn to hash emails while preserving analytics value** by extracting the domain separately. This enables both user counting and organizational insights.

## The Concept: Hash + Metadata Extraction

Emails contain **two valuable pieces of information**:
1. **Unique identifier** (sarah.johnson@example.com) - hash this
2. **Organization** (example.com) - extract and keep this

**Use email hashing + extraction when:**
- ‚úÖ You need to count unique users (hash enables `COUNT(DISTINCT email_hash)`)
- ‚úÖ You want organizational analytics (e.g., "30% of users are @gmail.com")
- ‚úÖ You need GDPR compliance (hashed emails are not personal data)
- ‚úÖ You want to track user behavior without knowing identity

**Don't use this when:**
- ‚ùå You need to send emails to users (use encryption or separate system)
- ‚ùå You have no analytics use for email data (use deletion instead)
- ‚ùå Domain is also sensitive (e.g., corporate email on personal device)

## What We're Transforming

From this event:

```json
{
  "event_id": "evt_20240115_1030",
  "email": "sarah.johnson@example.com",  // ‚ùå GDPR personal data
  // ... other fields
}
```

To this:

```json
{
  "event_id": "evt_20240115_1030",
  "email_hash": "a7b3c2d1...",           // ‚úÖ Hash for user counting
  "email_domain": "example.com",         // ‚úÖ Domain for org analytics
  // ... other fields
}
```

## The Bloblang String Functions

**Extract domain from email:**
```bloblang
# Split on @ and take second part
email.split("@").index(1)
```

**Hash email with salt:**
```bloblang
# Hash the full email address
email.hash("sha256", env("EMAIL_SALT").or(""))
```

**Combined example:**
```bloblang
root = this

# Hash the full email
root.email_hash = this.email.hash("sha256", env("EMAIL_SALT").or(""))

# Extract domain (everything after @)
root.email_domain = this.email.split("@").index(1)

# Remove original email
root = this.without("email")
```

## Step-by-Step Implementation

### 1. Verify Environment Variable

Ensure `EMAIL_SALT` is set from the [Setup guide](./setup):

```bash
# Check salt is configured
echo "EMAIL_SALT length: ${#EMAIL_SALT}"  # Should print 64

# If not set, generate one
export EMAIL_SALT=$(openssl rand -hex 32)
```

### 2. Create the Pipeline Configuration

Create `step-3-hash-email.yaml`:

```yaml title="step-3-hash-email.yaml"
name: pii-step-3-hash-email
description: "Step 3: Hash email addresses + extract domains (GDPR)"
type: pipeline
namespace: default
priority: 100

config:
  input:
    http_server:
      address: "0.0.0.0:8080"
      path: /events/ingest
      allowed_verbs: [POST]

  pipeline:
    processors:
      # Processor 1: Delete payment PII (from Step 1)
      - mapping: |
          root = this
          root.payment_method = this.payment_method.without(
            "full_number",
            "expiry"
          )

      # Processor 2: Hash IP address (from Step 2)
      - mapping: |
          root.ip_hash = this.ip_address.hash(
            "sha256",
            env("IP_SALT").or("")
          )
          root = this.without("ip_address")

      # Processor 3: Hash email + extract domain
      - mapping: |
          # Hash the full email for user counting
          root.email_hash = this.email.hash(
            "sha256",
            env("EMAIL_SALT").or("")
          )

          # Extract domain for organizational analytics
          root.email_domain = this.email.split("@").index(1)

          # Remove original email address
          root = this.without("email")

  output:
    file:
      path: /var/log/expanso/step-3-output.jsonl
      codec: lines

logger:
  level: INFO
```

### 3. Deploy the Pipeline

```bash
# Deploy to edge nodes
expanso job deploy step-3-hash-email.yaml

# Verify deployment
expanso job status pii-step-3-hash-email
```

### 4. Test with Sample Data

```bash
# Send the sample event
curl -X POST http://localhost:8080/events/ingest \
  -H "Content-Type: application/json" \
  -d @sample-data.json

# Check the output
tail -1 /var/log/expanso/step-3-output.jsonl | jq .
```

### 5. Verify Email Processing

**Expected output:**

```json
{
  "event_id": "evt_20240115_1030",
  "timestamp": "2024-01-15T10:30:00Z",
  "event_type": "purchase",
  // "email" removed               ‚úÖ Original email deleted
  "email_hash": "a7b3c2d1e4f5...",  // ‚úÖ 64-character hash
  "email_domain": "example.com",    // ‚úÖ Domain extracted
  // ... other fields
}
```

**Verification checklist:**
- ‚úÖ `email` field is **not present** in output
- ‚úÖ `email_hash` field is **present** with 64 hex characters
- ‚úÖ `email_domain` field is **present** with just the domain (no username)
- ‚úÖ Same email always produces **same hash** (deterministic)
- ‚úÖ Domain matches what was after `@` in original email

## Why This Works for GDPR

### GDPR and Email Addresses

**Email is personal data under GDPR Article 4(1):**
- üî¥ Directly identifies an individual
- üî¥ Can be used to contact data subject
- üî¥ Often contains name (sarah.johnson@...)
- üî¥ Requires consent or legal basis to process

### Hashed Email ‚â† Personal Data

**Why our approach is GDPR-compliant:**
- ‚úÖ SHA-256 with salt is **irreversible** (cannot recover email from hash)
- ‚úÖ Hash alone cannot identify individual
- ‚úÖ Qualifies as **anonymous data** under GDPR Recital 26
- ‚úÖ No longer subject to GDPR restrictions

### Domain Extraction is Safe

**email_domain alone is not personal data:**
- ‚úÖ `"example.com"` doesn't identify an individual
- ‚úÖ Millions of users may share same domain
- ‚úÖ Enables organizational analytics (e.g., "20% users are @gmail.com")
- ‚úÖ Combined with hash, still cannot identify individual

**Exception:** Be careful with small organizations:
- üü° If domain is "ceo@smallstartup.com" and you know there's only one employee
- üü° Domain + other context might identify individual
- üü° Solution: Delete domain for orgs with < 10 employees

## Analytics Impact

### Before (with raw email):
```json
"email": "sarah.johnson@example.com"
```

**Analytics queries you CAN run:**
- ‚úÖ Unique user counts
- ‚úÖ User journey tracking
- ‚úÖ Organizational trends
- ‚ùå But violates GDPR without consent!

### After (with hash + domain):
```json
"email_hash": "a7b3c2d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1",
"email_domain": "example.com"
```

**Analytics queries you CAN still run:**

**User Counting:**
```sql
-- Count unique users
SELECT COUNT(DISTINCT email_hash) AS unique_users
FROM events;
```

**User Journey Tracking:**
```sql
-- Track same user across sessions
SELECT email_hash, COUNT(*) AS page_views
FROM events
GROUP BY email_hash
ORDER BY page_views DESC;
```

**Organizational Analytics:**
```sql
-- Top email domains
SELECT email_domain, COUNT(DISTINCT email_hash) AS users
FROM events
GROUP BY email_domain
ORDER BY users DESC;
-- Results:
-- gmail.com        1,234 users
-- yahoo.com        892 users
-- example.com      456 users
```

**B2B vs B2C Segmentation:**
```sql
-- Free email providers (B2C)
SELECT COUNT(DISTINCT email_hash) AS b2c_users
FROM events
WHERE email_domain IN ('gmail.com', 'yahoo.com', 'outlook.com');

-- Corporate domains (B2B)
SELECT COUNT(DISTINCT email_hash) AS b2b_users
FROM events
WHERE email_domain NOT IN ('gmail.com', 'yahoo.com', 'outlook.com');
```

**Analytics you CANNOT run:**
- ‚ùå Email the user
- ‚ùå Identify individual from hash alone
- ‚ùå Build contact lists

## Common Variations

### Variation 1: Categorize Email Providers

Add provider type (free vs corporate):

```yaml
- mapping: |
    root = this

    # Hash email
    root.email_hash = this.email.hash("sha256", env("EMAIL_SALT").or(""))

    # Extract domain
    root.email_domain = this.email.split("@").index(1)

    # Categorize provider
    let free_providers = ["gmail.com", "yahoo.com", "outlook.com", "hotmail.com", "icloud.com"]
    root.email_provider_type = if $free_providers.contains(this.email.split("@").index(1)) {
      "free"
    } else {
      "corporate"
    }

    # Remove original
    root = this.without("email")
```

**Result:**
```json
{
  "email_hash": "a7b3c2d1...",
  "email_domain": "example.com",
  "email_provider_type": "corporate"
}
```

### Variation 2: Keep Domain Only (No Hash)

If you only need organizational analytics (not user counting):

```yaml
- mapping: |
    root = this

    # Extract only the domain
    root.email_domain = this.email.split("@").index(1)

    # Remove email (no hash needed)
    root = this.without("email")
```

**Use when:** You don't need to track individual users, just organizational trends.

### Variation 3: Hash Domain Separately

For extra privacy, hash the domain too:

```yaml
- mapping: |
    root = this

    # Hash full email
    root.email_hash = this.email.hash("sha256", env("EMAIL_SALT").or(""))

    # Hash domain separately (for privacy)
    root.email_domain_hash = this.email.split("@").index(1).hash("sha256", env("DOMAIN_SALT").or(""))

    # Remove original
    root = this.without("email")
```

**Result:**
```json
{
  "email_hash": "a7b3c2d1...",
  "email_domain_hash": "f9e8d7c6..."
}
```

**Use when:** Even domain is sensitive (e.g., healthcare provider domain reveals medical context).

### Variation 4: Normalize Before Hashing

Handle email variations (dots, plus signs in Gmail):

```yaml
- mapping: |
    root = this

    # Normalize email before hashing
    let username = this.email.split("@").index(0).lowercase()
    let domain = this.email.split("@").index(1).lowercase()

    # Gmail ignores dots and + suffixes
    let normalized = if domain == "gmail.com" {
      username.replace_all(".", "").split("+").index(0) + "@" + domain
    } else {
      username + "@" + domain
    }

    # Hash normalized email
    root.email_hash = $normalized.hash("sha256", env("EMAIL_SALT").or(""))
    root.email_domain = domain

    root = this.without("email")
```

**Why this matters:**
- `sarah.johnson@gmail.com` ‚Üí hash_A
- `sarahjohnson@gmail.com` ‚Üí hash_A (same person!)
- `sarah.johnson+newsletter@gmail.com` ‚Üí hash_A (same person!)

### Variation 5: Conditional Domain Extraction

Only extract domain for free email providers:

```yaml
- mapping: |
    root = this

    # Hash email
    root.email_hash = this.email.hash("sha256", env("EMAIL_SALT").or(""))

    # Extract domain only for free providers
    let domain = this.email.split("@").index(1)
    let free_providers = ["gmail.com", "yahoo.com", "outlook.com"]

    root.email_domain = if $free_providers.contains(domain) {
      domain
    } else {
      "corporate"  # Generalize all corporate domains
    }

    root = this.without("email")
```

**Use when:** Corporate domain + other data might identify individual in small companies.

## Troubleshooting

### Issue: email_domain is empty or null

**Cause:** Email field doesn't contain `@` or has unexpected format

**Debug:**
```bash
# Check the raw input email format
tail -1 /var/log/expanso/step-3-output.jsonl | jq .email

# Test with malformed email
curl -X POST http://localhost:8080/events/ingest \
  -d '{"email": "invalid-email-no-at-sign", "event_type": "test"}'
```

**Fix with validation:**
```yaml
- mapping: |
    root = this

    # Validate email has @ symbol
    let has_at = this.email.contains("@")

    root.email_hash = if $has_at {
      this.email.hash("sha256", env("EMAIL_SALT").or(""))
    } else {
      "invalid_email"
    }

    root.email_domain = if $has_at {
      this.email.split("@").index(1)
    } else {
      "unknown"
    }

    root = this.without("email")
```

### Issue: email_domain includes username

**Symptom:** `email_domain: "sarah.johnson@example.com"` (full email, not just domain)

**Cause:** Not removing original email or wrong field assignment

**Wrong:**
```yaml
root.email_domain = this.email  # ‚ùå Assigns full email
```

**Correct:**
```yaml
root.email_domain = this.email.split("@").index(1)  # ‚úÖ Extracts domain only
```

### Issue: Different hashes for same email

**Symptom:**
```
sarah@example.com ‚Üí hash_A
Sarah@Example.com ‚Üí hash_B  (different hash!)
```

**Cause:** Emails not normalized (case-sensitive hashing)

**Fix with normalization:**
```yaml
- mapping: |
    root = this

    # Normalize to lowercase before hashing
    let normalized_email = this.email.lowercase()

    root.email_hash = $normalized_email.hash("sha256", env("EMAIL_SALT").or(""))
    root.email_domain = $normalized_email.split("@").index(1)

    root = this.without("email")
```

### Issue: INDEX OUT OF BOUNDS error

**Cause:** Email has no `@` symbol, so `.split("@")` produces array with 1 element, and `.index(1)` fails

**Debug:**
```bash
# Check logs for errors
expanso job logs pii-step-3-hash-email --tail 50 | grep -i "index"
```

**Fix with safe indexing:**
```yaml
- mapping: |
    root = this

    # Safe domain extraction with fallback
    let parts = this.email.split("@")
    let domain = if parts.length() > 1 {
      parts.index(1)
    } else {
      "invalid_domain"
    }

    root.email_hash = this.email.hash("sha256", env("EMAIL_SALT").or(""))
    root.email_domain = $domain

    root = this.without("email")
```

### Issue: Want to preserve email for customer service

**Problem:** Need email hash for analytics but also need original email for support tickets

**Solution:** Dual output - one for analytics (hashed), one for customer service (encrypted or separate DB):

```yaml
config:
  pipeline:
    processors:
      # Hash email for analytics
      - mapping: |
          root = this
          root.email_hash = this.email.hash("sha256", env("EMAIL_SALT").or(""))
          root.email_domain = this.email.split("@").index(1)
          root = this.without("email")

  output:
    broker:
      outputs:
        # Analytics sink (PII-free)
        - http_client:
            url: http://analytics-service:8080/events

        # Customer service DB (with encryption)
        - http_client:
            url: http://customer-service:8080/tickets
            headers:
              X-Encryption-Key: "${CUSTOMER_SERVICE_KEY}"
```

## Email-Specific Privacy Considerations

### Inference Risk

Even hashed, email patterns can reveal information:

**Example:**
```json
{
  "email_hash": "a7b3c2d1...",
  "email_domain": "stanford.edu",
  "purchase_item": "textbook",
  "location_city": "Palo Alto"
}
```

**Inference:** Likely a Stanford student, even without email.

**Mitigation:**
- Generalize location to state/country
- Remove domain for educational institutions
- Use broader purchase categories

### Gmail Dot Trick

Gmail treats these as the same:
- sarah.johnson@gmail.com
- sarahjohnson@gmail.com
- s.a.r.a.h.j.o.h.n.s.o.n@gmail.com

**Always normalize Gmail addresses** before hashing (see Variation 4).

### Plus Addressing

Email providers allow:
- sarah.johnson+newsletter@example.com
- sarah.johnson+shopping@example.com

**Both are the same person!** Strip `+suffix` before hashing.

## Key Takeaways

‚úÖ **Hash emails** for GDPR-compliant user counting
‚úÖ **Extract domains separately** for organizational analytics
‚úÖ **Normalize emails** before hashing (lowercase, remove dots/pluses)
‚úÖ **Validate email format** to prevent errors
‚úÖ **Domain alone is not PII** unless organization is tiny
‚úÖ **Cannot reverse hash** - if you need to email users, use separate encrypted system

## Next Step

Now that you've hashed emails, move to **pseudonymization** - creating consistent user IDs for tracking without revealing identity.

<div className="margin-top--lg margin-bottom--lg">
  <a href="./step-4-pseudonymize-user" className="button button--primary button--lg">
    Step 4: Pseudonymize User ‚Üí
  </a>
</div>

### Or Jump Ahead:
- [**Step 5: Generalize Location**](./step-5-generalize-location)
- [**Complete Pipeline**](./complete-pipeline)

### Related Resources:
- [**Interactive Explorer**](./explorer) - See this transformation visually
- [**Bloblang String Functions**](https://docs.expanso.io/components/processors/mapping#string-manipulation) - split, lowercase, replace_all
- [**Email Validation**](https://docs.expanso.io/components/processors/mapping#validation) - Validate email formats
