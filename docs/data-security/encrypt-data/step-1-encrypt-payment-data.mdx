---
title: "Step 1 - Encrypt Credit Card Data"
sidebar_label: "Step 1: Credit Card Encryption"
sidebar_position: 4
description: "Implement PCI-DSS compliant credit card encryption with AES-256-GCM while preserving analytics utility"
keywords: [credit-card, encryption, pci-dss, aes-256-gcm, card-data, cvv]
---

# Step 1: Encrypt Credit Card Data

Credit card data encryption is the foundation of PCI-DSS compliance and the most critical security requirement for payment processing. This step implements AES-256-GCM encryption for credit card numbers, CVV codes, and cardholder names while preserving essential analytics metadata.

## Learning Objectives

By the end of this step, you'll be able to:

✅ **Encrypt credit card numbers** with industry-standard AES-256-GCM encryption
✅ **Preserve analytics utility** by retaining last 4 digits and card brand detection  
✅ **Implement secure CVV handling** with immediate encryption and no plaintext storage
✅ **Meet PCI-DSS requirements** for cardholder data protection
✅ **Handle edge cases** like invalid card formats, missing data, and encryption failures

## Problem: Credit Card Data Exposure

Payment systems handle credit card data that must be protected under PCI-DSS regulations. Consider this typical payment transaction:

```json title="Raw payment data (PCI-DSS violation)"
{
  "transaction_id": "txn_20251020_001",
  "payment": {
    "card_number": "4532-1234-5678-9010",     // ❌ Full PAN visible
    "cvv": "123",                            // ❌ CVV stored in plaintext
    "expiration": "12/27",                   // ✅ Safe to keep
    "cardholder_name": "Sarah Johnson"       // ❌ Cardholder data exposed
  },
  "amount": 127.50
}
```

**Security risks:**
- **Full PAN exposure** - Card numbers visible to database administrators
- **CVV storage** - CVV codes must never be stored after authorization
- **Cardholder data** - Names linked to card numbers create PII exposure
- **Audit scope** - All systems handling this data fall under PCI-DSS audit
- **Breach impact** - Stolen database exposes complete payment credentials

## Solution: Selective Field Encryption

Encrypt sensitive payment fields while preserving business-critical analytics metadata:

```json title="Encrypted payment data (PCI-DSS compliant)"
{
  "transaction_id": "txn_20251020_001",
  "payment": {
    // Encrypted sensitive data
    "card_number_encrypted": "AES256GCM:v1:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=:8f3e2a1b9c4d7e6f",
    "cvv_encrypted": "AES256GCM:v1:cGFzc3dvcmQxMjM0NTY3ODkwYWJjZGVmZ2hp:1a2b3c4d5e6f7g8h",
    "cardholder_name_encrypted": "AES256GCM:v1:bmFtZXN0cmluZ2hlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:9f8e7d6c5b4a3g2h",
    
    // Preserved analytics metadata
    "card_last_four": "9010",               // ✅ Customer service lookup
    "card_brand": "visa",                   // ✅ Fraud pattern analysis
    "expiration": "12/27"                   // ✅ Expiration tracking
  },
  "amount": 127.50
}
```

**Benefits:**
- **PCI-DSS compliance** - Encrypted cardholder data reduces audit scope
- **Analytics preserved** - Card brands and last 4 digits enable fraud detection
- **Customer service** - Last 4 digits support payment inquiry handling
- **Breach protection** - Stolen data contains only encrypted blobs

## Implementation

### Step 1.1: Create Credit Card Encryption Processor

Create a processor that identifies, validates, and encrypts credit card data:

```yaml title="card-encryption-processor.yaml"
apiVersion: expanso.io/v1
kind: DataPipeline
metadata:
  name: card-encryption-step1
  namespace: default
spec:
  processors:
    - name: validate-card-data
      type: mapping
      config:
        mapping: |
          # Validate payment object exists
          root = if !this.payment.exists() {
            throw("payment object is required")
          } else if this.payment.card_number.type() != "string" {
            throw("payment.card_number must be a string")
          } else if this.payment.card_number.length() < 13 {
            throw("payment.card_number must be at least 13 digits")
          } else {
            this
          }
          
    - name: encrypt-card-number
      type: mapping
      config:
        mapping: |
          # Clean and validate card number
          let clean_card = this.payment.card_number.re_replace_all("[^0-9]", "")
          
          # Validate card number length (13-19 digits per ISO/IEC 7812)
          root = if clean_card.length() < 13 || clean_card.length() > 19 {
            throw("Invalid card number length: %d digits".format(clean_card.length()))
          } else {
            this
          }
          
          # Encrypt full card number
          root.payment.card_number_encrypted = crypto.encrypt_aes256_gcm(
            this.payment.card_number, 
            env("CARD_ENCRYPTION_KEY"),
            "card_number"
          )
          
          # Extract last 4 digits for analytics
          root.payment.card_last_four = clean_card.slice(-4)
          
          # Determine card brand from BIN (Bank Identification Number)
          root.payment.card_brand = if clean_card.has_prefix("4") {
            "visa"
          } else if clean_card.re_match("^5[1-5].*") {
            "mastercard"
          } else if clean_card.re_match("^3[47].*") {
            "american_express"
          } else if clean_card.re_match("^6(?:011|5).*") {
            "discover"
          } else if clean_card.re_match("^(?:2131|1800|35).*") {
            "jcb"
          } else {
            "unknown"
          }
          
          # Remove original plaintext card number
          root.payment = this.payment.without("card_number")
          
    - name: encrypt-cvv
      type: mapping
      config:
        mapping: |
          # CVV encryption (if present)
          root = this
          
          # Only encrypt if CVV is provided
          root.payment.cvv_encrypted = if this.payment.cvv.exists() {
            # Validate CVV format (3-4 digits)
            if !this.payment.cvv.re_match("^[0-9]{3,4}$") {
              throw("CVV must be 3-4 digits")
            } else {
              crypto.encrypt_aes256_gcm(
                this.payment.cvv,
                env("CARD_ENCRYPTION_KEY"), 
                "cvv"
              )
            }
          }
          
          # Remove original plaintext CVV (PCI-DSS requirement)
          root.payment = if this.payment.cvv.exists() {
            this.payment.without("cvv")
          } else {
            this.payment
          }
          
    - name: encrypt-cardholder-name
      type: mapping  
      config:
        mapping: |
          # Cardholder name encryption (if present)
          root = this
          
          root.payment.cardholder_name_encrypted = if this.payment.cardholder_name.exists() {
            # Validate name is not empty
            if this.payment.cardholder_name.trim().length() == 0 {
              throw("cardholder_name cannot be empty")
            } else {
              crypto.encrypt_aes256_gcm(
                this.payment.cardholder_name.trim().uppercase(),
                env("CARD_ENCRYPTION_KEY"),
                "cardholder_name"  
              )
            }
          }
          
          # Remove original plaintext name
          root.payment = if this.payment.cardholder_name.exists() {
            this.payment.without("cardholder_name") 
          } else {
            this.payment
          }
          
    - name: add-encryption-metadata
      type: mapping
      config:
        mapping: |
          root = this
          
          # Add encryption tracking metadata
          root.payment.encryption_metadata = {
            "encrypted_fields": ["card_number", "cvv", "cardholder_name"].filter(field -> 
              this.payment.get(field + "_encrypted").exists()
            ).map_each(field -> "payment." + field + "_encrypted"),
            "preserved_fields": ["card_last_four", "card_brand", "expiration"],
            "encryption_timestamp": now(),
            "encryption_algorithm": "AES-256-GCM",
            "key_version": env("KEY_VERSION"),
            "node_id": env("NODE_ID")
          }

  input:
    http_server:
      address: "0.0.0.0:8443"
      path: /payments/encrypt-card
      allowed_verbs: ["POST"]
      timeout: "30s"
      tls:
        enabled: true
        cert_file: "/etc/expanso/certs/server.crt"
        key_file: "/etc/expanso/certs/server.key"

  output:
    stdout: {}
    
  environment:
    CARD_ENCRYPTION_KEY: "${CARD_ENCRYPTION_KEY}"
    KEY_VERSION: "${KEY_VERSION}"
    NODE_ID: "${NODE_ID}"
```

### Step 1.2: Deploy and Test Card Encryption

Deploy the card encryption processor:

```bash title="Deploy card encryption processor"
# Deploy the processor
expanso job deploy card-encryption-processor.yaml

# Wait for deployment
sleep 10

# Check deployment status  
expanso job status card-encryption-step1
```

**Expected output:**
```
Job: card-encryption-step1
Status: running
Type: pipeline
Executions:
  - Node: edge-encryption-001
    State: running
    Since: 15 seconds ago
    Health: healthy
```

### Step 1.3: Test Credit Card Encryption

Test with various card types and edge cases:

```bash title="Test Visa card encryption"
curl -X POST https://localhost:8443/payments/encrypt-card \
  --cacert /etc/expanso/certs/ca.crt \
  --cert /etc/expanso/certs/client.crt \
  --key /etc/expanso/certs/client.key \
  -H "Content-Type: application/json" \
  -d '{
    "transaction_id": "txn_visa_001",
    "payment": {
      "card_number": "4532-1234-5678-9010",
      "cvv": "123",
      "expiration": "12/27",
      "cardholder_name": "Sarah Johnson"
    },
    "amount": 127.50
  }'
```

**Expected response:**
```json
{
  "transaction_id": "txn_visa_001",
  "payment": {
    "card_number_encrypted": "AES256GCM:v1:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=:8f3e2a1b9c4d7e6f",
    "cvv_encrypted": "AES256GCM:v1:cGFzc3dvcmQxMjM0NTY3ODkwYWJjZGVmZ2hp:1a2b3c4d5e6f7g8h",
    "cardholder_name_encrypted": "AES256GCM:v1:bmFtZXN0cmluZ2hlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:9f8e7d6c5b4a3g2h",
    "card_last_four": "9010",
    "card_brand": "visa",
    "expiration": "12/27",
    "encryption_metadata": {
      "encrypted_fields": [
        "payment.card_number_encrypted",
        "payment.cvv_encrypted", 
        "payment.cardholder_name_encrypted"
      ],
      "preserved_fields": ["card_last_four", "card_brand", "expiration"],
      "encryption_timestamp": "2025-10-20T14:30:01.234Z",
      "encryption_algorithm": "AES-256-GCM",
      "key_version": "v1_20251020",
      "node_id": "edge-encryption-001"
    }
  },
  "amount": 127.50
}
```

Test other card brands:

```bash title="Test Mastercard encryption"
curl -X POST https://localhost:8443/payments/encrypt-card \
  -H "Content-Type: application/json" \
  --cacert /etc/expanso/certs/ca.crt \
  --cert /etc/expanso/certs/client.crt \
  --key /etc/expanso/certs/client.key \
  -d '{
    "transaction_id": "txn_mc_001", 
    "payment": {
      "card_number": "5555555555554444",
      "cvv": "456",
      "expiration": "08/26",
      "cardholder_name": "John Smith"
    },
    "amount": 89.99
  }'
```

```bash title="Test American Express"
curl -X POST https://localhost:8443/payments/encrypt-card \
  -H "Content-Type: application/json" \
  --cacert /etc/expanso/certs/ca.crt \
  --cert /etc/expanso/certs/client.crt \
  --key /etc/expanso/certs/client.key \
  -d '{
    "transaction_id": "txn_amex_001",
    "payment": {
      "card_number": "371449635398431",
      "cvv": "1234", 
      "expiration": "03/25",
      "cardholder_name": "Emily Davis"
    },
    "amount": 250.00
  }'
```

### Step 1.4: Verify Card Brand Detection

The processor should correctly identify card brands:

| Card Number | Expected Brand | BIN Pattern |
|-------------|----------------|-------------|
| 4532-1234-5678-9010 | visa | Starts with 4 |
| 5555-5555-5555-4444 | mastercard | 5.1-5.5 |
| 3714-496353-98431 | american_express | 34, 37 |
| 6011-1111-1111-1117 | discover | 6011, 65 |
| 3528-0000-0000-0007 | jcb | 35 |

Test invalid card scenarios:

```bash title="Test invalid card number"
curl -X POST https://localhost:8443/payments/encrypt-card \
  -H "Content-Type: application/json" \
  --cacert /etc/expanso/certs/ca.crt \
  --cert /etc/expanso/certs/client.crt \
  --key /etc/expanso/certs/client.key \
  -d '{
    "payment": {
      "card_number": "123",
      "cvv": "123"
    }
  }'
```

**Expected error response:**
```json
{
  "error": "Invalid card number length: 3 digits",
  "pipeline": "card-encryption-step1",
  "timestamp": "2025-10-20T14:30:01Z"
}
```

## Advanced Card Encryption Patterns

### Pattern 1: Luhn Algorithm Validation

Add Luhn algorithm validation for additional card number verification:

```yaml title="Enhanced validation with Luhn check"
- name: validate-card-luhn
  type: mapping
  config:
    mapping: |
      # Luhn algorithm implementation
      let clean_card = this.payment.card_number.re_replace_all("[^0-9]", "")
      let digits = clean_card.split("").map_each(d -> d.number())
      
      # Calculate Luhn checksum
      let luhn_sum = range(0, digits.length()).fold(0, (acc, i) -> {
        let digit = digits[digits.length() - 1 - i]
        let doubled = if (i % 2) == 1 {
          let d = digit * 2
          if d > 9 { d - 9 } else { d }
        } else { digit }
        acc + doubled
      })
      
      root = if (luhn_sum % 10) != 0 {
        throw("Invalid card number: Luhn check failed")
      } else {
        this
      }
```

### Pattern 2: PCI-DSS Audit Logging

Add detailed audit logging for PCI-DSS compliance:

```yaml title="PCI-DSS audit logging"
- name: pci-audit-log
  type: mapping
  config:
    mapping: |
      root = this
      
      # Create audit log entry
      let audit_entry = {
        "event_type": "card_data_encryption",
        "timestamp": now(),
        "transaction_id": this.transaction_id,
        "card_last_four": this.payment.card_last_four,
        "card_brand": this.payment.card_brand,
        "encryption_key_version": env("KEY_VERSION"),
        "node_id": env("NODE_ID"),
        "user_agent": metadata().http.request.headers."User-Agent",
        "source_ip": metadata().http.request.remote_addr,
        "pci_scope": "cardholder_data_encryption",
        "compliance_standard": "PCI-DSS-4.0"
      }
      
      # Send to audit log endpoint
      http_request("POST", env("AUDIT_LOG_ENDPOINT"), audit_entry, {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + env("AUDIT_API_KEY")
      })
```

### Pattern 3: Token-Based Card References

Generate secure tokens for card references:

```yaml title="Card tokenization"
- name: generate-card-token
  type: mapping
  config:
    mapping: |
      root = this
      
      # Generate secure token for card reference
      let token_data = {
        "card_last_four": this.payment.card_last_four,
        "card_brand": this.payment.card_brand,
        "expiration": this.payment.expiration,
        "merchant_id": this.merchant_id,
        "timestamp": now().format_timestamp("20060102")
      }
      
      # Create HMAC-based token
      root.payment.card_token = crypto.hmac_sha256(
        token_data | json.encode(),
        env("TOKEN_SECRET")
      ).encode_base64().slice(0, 32)
      
      root.payment.token_metadata = {
        "token_type": "card_reference",
        "created": now(),
        "expires": now().ts_add("8760h"), # 1 year
        "scope": ["payment_processing", "customer_service"]
      }
```

## Performance Optimization

### Encryption Performance Metrics

Monitor encryption performance to ensure sub-10ms latency:

```yaml title="Performance monitoring"
- name: performance-metrics
  type: mapping
  config:
    mapping: |
      let start_time = now()
      
      # Perform encryption operations
      root = this
      
      let end_time = now()
      let encryption_duration = (end_time - start_time).duration_seconds() * 1000
      
      # Add performance metrics
      root.performance_metrics = {
        "encryption_duration_ms": encryption_duration,
        "fields_encrypted": 3, # card_number, cvv, cardholder_name
        "throughput_fields_per_ms": 3 / encryption_duration,
        "node_id": env("NODE_ID"),
        "timestamp": end_time
      }
      
      # Alert if encryption is slow (&gt;10ms)
      if encryption_duration > 10 {
        http_request("POST", env("ALERT_WEBHOOK_URL"), {
          "alert": "slow_encryption",
          "duration_ms": encryption_duration,
          "threshold_ms": 10,
          "node_id": env("NODE_ID")
        })
      }
```

### Bulk Encryption Optimization

For high-throughput scenarios, optimize bulk encryption:

```yaml title="Bulk card encryption"
- name: bulk-card-encryption
  type: mapping
  config:
    mapping: |
      # Handle array of transactions
      root = if this.transactions.exists() {
        this.merge({
          "transactions": this.transactions.map_each(tx -> {
            tx.merge({
              "payment": {
                "card_number_encrypted": crypto.encrypt_aes256_gcm(
                  tx.payment.card_number, 
                  env("CARD_ENCRYPTION_KEY")
                ),
                "cvv_encrypted": crypto.encrypt_aes256_gcm(
                  tx.payment.cvv,
                  env("CARD_ENCRYPTION_KEY") 
                ),
                "card_last_four": tx.payment.card_number.re_replace_all("[^0-9]", "").slice(-4),
                "card_brand": if tx.payment.card_number.has_prefix("4") { "visa" } else { "unknown" }
              }.without_keys(["card_number", "cvv"])
            })
          })
        })
      } else {
        # Single transaction handling
        this
      }
```

## Security Considerations

### Key Rotation Impact

When rotating encryption keys, plan for backward compatibility:

```yaml title="Multi-version key support"
- name: multi-version-encryption
  type: mapping
  config:
    mapping: |
      # Use current key version for new encryption
      let current_key = env("CARD_ENCRYPTION_KEY_V" + env("KEY_VERSION"))
      
      root.payment.card_number_encrypted = "AES256GCM:" + env("KEY_VERSION") + ":" + 
        crypto.encrypt_aes256_gcm(this.payment.card_number, current_key)
      
      # Store key version for future decryption
      root.payment.key_version = env("KEY_VERSION")
```

### Decryption Service Access

Implement controlled decryption for authorized services:

```yaml title="Authorized decryption"
- name: decrypt-for-fraud-detection
  type: mapping
  config:
    mapping: |
      # Only decrypt for authorized services
      let service_id = metadata().http.request.headers."X-Service-ID"
      let authorized_services = ["fraud-detection", "payment-processing"]
      
      root = if authorized_services.contains(service_id) {
        # Decrypt card data for fraud analysis
        this.merge({
          "payment_analysis": {
            "card_number_masked": "**** **** **** " + this.payment.card_last_four,
            "card_brand": this.payment.card_brand,
            "risk_factors": {
              "card_type": this.payment.card_brand,
              "last_four": this.payment.card_last_four
            }
          }
        })
      } else {
        # Return only encrypted data for unauthorized services
        this
      }
```

## Compliance and Audit

### PCI-DSS Requirement Mapping

This implementation addresses these PCI-DSS requirements:

| PCI-DSS Requirement | Implementation | Evidence |
|---------------------|----------------|----------|
| 3.4 - Cryptographic Keys | AES-256-GCM with secure key storage | Key generation, Vault integration |
| 3.5 - Key Management | Key versioning and rotation | Metadata tracking |
| 3.6 - Cryptographic Functions | Industry-standard algorithms | AES-256-GCM usage |
| 4.1 - Transmission Encryption | TLS + field-level encryption | Double encryption |
| 8.2 - Unique User IDs | Service-based access control | Service ID validation |
| 10.2 - Audit Trails | Comprehensive logging | Audit log integration |

### Compliance Testing

Test compliance with automated checks:

```bash title="PCI-DSS compliance test"
# Test 1: Verify no plaintext card data in output
curl -X POST https://localhost:8443/payments/encrypt-card \
  -d '{"payment":{"card_number":"4532123456789010"}}' \
  -H "Content-Type: application/json" \
  --cacert /etc/expanso/certs/ca.crt | \
  grep -q "4532123456789010" && echo "❌ FAIL: Plaintext card number found" || echo "✅ PASS: No plaintext card data"

# Test 2: Verify encryption metadata exists  
curl -X POST https://localhost:8443/payments/encrypt-card \
  -d '{"payment":{"card_number":"4532123456789010"}}' \
  -H "Content-Type: application/json" \
  --cacert /etc/expanso/certs/ca.crt | \
  jq -r '.payment.encryption_metadata.encryption_algorithm' | \
  grep -q "AES-256-GCM" && echo "✅ PASS: Encryption metadata present" || echo "❌ FAIL: Missing encryption metadata"

# Test 3: Verify last 4 digits preserved
curl -X POST https://localhost:8443/payments/encrypt-card \
  -d '{"payment":{"card_number":"4532123456789010"}}' \
  -H "Content-Type: application/json" \
  --cacert /etc/expanso/certs/ca.crt | \
  jq -r '.payment.card_last_four' | \
  grep -q "9010" && echo "✅ PASS: Last 4 digits preserved" || echo "❌ FAIL: Last 4 digits missing"
```

## Common Issues and Troubleshooting

### Issue: Encryption key not found
**Symptom:** Error "encryption key not found" or "invalid key format"

**Diagnosis:**
```bash
# Check if key environment variable is set
echo "Key check: ${CARD_ENCRYPTION_KEY:0:8}..." 

# Verify key length (should be 64 hex characters = 32 bytes)
echo ${#CARD_ENCRYPTION_KEY}  # Should output 64
```

**Solutions:**
1. **Regenerate key:**
```bash
export CARD_ENCRYPTION_KEY=$(openssl rand -hex 32)
echo "New key: ${CARD_ENCRYPTION_KEY:0:8}..."
```

2. **Check key in Vault:**
```bash
vault kv get secret/expanso/encryption/card
```

### Issue: Card brand detection fails
**Symptom:** All cards show "unknown" brand

**Diagnosis:**
```bash
# Test brand detection manually
python3 -c "
card = '4532123456789010'
clean = ''.join(c for c in card if c.isdigit())
print(f'Clean card: {clean}')
print(f'First digit: {clean[0]}')
print(f'Brand: visa' if clean.startswith('4') else 'other')
"
```

**Solutions:**
1. **Update brand detection logic:**
```yaml
root.payment.card_brand = if clean_card.re_match("^4[0-9]{12,18}$") {
  "visa"
} else if clean_card.re_match("^5[1-5][0-9]{13,16}$") {
  "mastercard"  
} else if clean_card.re_match("^3[47][0-9]{12,14}$") {
  "american_express"
} else {
  "unknown"
}
```

### Issue: CVV encryption fails
**Symptom:** CVV validation errors or empty encrypted values

**Diagnosis:**
```bash
# Test CVV validation
curl -X POST https://localhost:8443/payments/encrypt-card \
  -d '{"payment":{"card_number":"4532123456789010","cvv":"abc"}}' \
  -H "Content-Type: application/json" \
  --cacert /etc/expanso/certs/ca.crt
```

**Solutions:**
1. **Add CVV validation:**
```yaml
# Validate CVV format before encryption
root = if this.payment.cvv.exists() && !this.payment.cvv.re_match("^[0-9]{3,4}$") {
  throw("CVV must be 3-4 digits, got: " + this.payment.cvv)
} else {
  this
}
```

### Issue: Performance degradation
**Symptom:** Encryption taking &gt;50ms per transaction

**Diagnosis:**
```bash
# Monitor encryption performance
curl -w "@curl-format.txt" -X POST https://localhost:8443/payments/encrypt-card \
  -d '{"payment":{"card_number":"4532123456789010"}}' \
  --cacert /etc/expanso/certs/ca.crt >/dev/null

# Create curl-format.txt:
cat > curl-format.txt <<'EOF'
     time_namelookup:  %{time_namelookup}\n
        time_connect:  %{time_connect}\n
     time_appconnect:  %{time_appconnect}\n
    time_pretransfer:  %{time_pretransfer}\n
       time_redirect:  %{time_redirect}\n
  time_starttransfer:  %{time_starttransfer}\n
                     ----------\n
          time_total:  %{time_total}\n
EOF
```

**Solutions:**
1. **Optimize mapping logic:**
```yaml
# Cache regex patterns
let card_patterns = {
  "visa": "^4[0-9]{12,18}$",
  "mastercard": "^5[1-5][0-9]{13,16}$"
}

# Use single pass for brand detection
root.payment.card_brand = card_patterns.keys().fold("unknown", (brand, key) ->
  if clean_card.re_match(card_patterns[key]) { key } else { brand }
)
```

2. **Use connection pooling:**
```yaml
output:
  http_client:
    url: "${PAYMENT_PROCESSOR_ENDPOINT}"
    verb: POST
    headers:
      Connection: "keep-alive"
    timeout: "10s"
    max_idle_conns: 100
```

---

## Summary

You've successfully implemented PCI-DSS compliant credit card encryption with:

✅ **AES-256-GCM encryption** for card numbers, CVV codes, and cardholder names
✅ **Analytics preservation** through last 4 digits and card brand detection
✅ **Compliance features** including audit logging and key versioning  
✅ **Error handling** for invalid card formats and missing data
✅ **Performance optimization** for high-throughput scenarios

**Key achievements:**
- Credit card data is now encrypted at the edge before transmission
- PCI-DSS audit scope significantly reduced
- Analytics capabilities preserved through selective metadata
- Comprehensive audit trail for compliance reporting

**Next step:** [Encrypt customer PII data](./step-2-encrypt-customer-data) including SSN, email, and phone numbers.

---

## Related Resources

- [**Step 2: Encrypt Customer Data**](./step-2-encrypt-customer-data) - SSN, email, and phone protection
- [**PCI-DSS Compliance Guide**](https://www.pcisecuritystandards.org/) - Official compliance requirements
- [**AES-GCM Specification**](https://tools.ietf.org/html/rfc5116) - Technical encryption standard
