---
title: "Step 4 - Implement Key Management"
sidebar_label: "Step 4: Key Management"
sidebar_position: 7 
description: Secure key storage, rotation, versioning, and lifecycle management for production encryption
keywords: [key-management, key-rotation, vault, kms, security-operations, key-versioning]
---

# Step 4: Implement Key Management

Production encryption requires robust key management with secure storage, automatic rotation, versioning, and audit trails. This step implements enterprise-grade key lifecycle management using HashiCorp Vault, AWS KMS, and secure key rotation strategies.

## Learning Objectives

By the end of this step, you'll be able to:

✅ **Store keys securely** in HashiCorp Vault or cloud KMS
✅ **Implement key rotation** with zero-downtime migration  
✅ **Version encryption keys** for backward compatibility
✅ **Audit key operations** for compliance and security
✅ **Handle key rotation** across distributed edge nodes
✅ **Implement emergency procedures** for key compromise

## Problem: Insecure Key Practices

Many organizations struggle with encryption key security and lifecycle management:

```bash title="Insecure key practices (Security violations)"
# ❌ Keys in environment variables
export ENCRYPTION_KEY="abc123def456..."

# ❌ Keys in configuration files  
encryption_key: "hardcoded-key-value"

# ❌ Keys in version control
echo "CARD_KEY=secret123" >> .env

# ❌ No key rotation
# Same key used for years

# ❌ No audit trail  
# Who accessed keys when?
```

**Security risks:**
- **Key exposure** - Environment variables logged/exposed
- **Static keys** - Same key used indefinitely increases breach impact
- **No audit trail** - Cannot track key access or rotation
- **Single point of failure** - Key compromise affects all data
- **Compliance violations** - Regulations require key rotation

## Solution: Enterprise Key Management

Implement comprehensive key lifecycle management:

```yaml title="Secure key management architecture"
# ✅ Vault-based key storage
vault_config:
  address: "https://vault.company.com:8200"
  auth_method: "kubernetes"
  secret_path: "secret/expanso/encryption/"
  
# ✅ Key rotation schedule  
rotation_schedule:
  high_sensitivity: 90  # days (card data)
  medium_sensitivity: 180  # days (PII) 
  low_sensitivity: 365  # days (addresses)
  
# ✅ Multi-version support
key_versions:
  current: "v3_20251020"
  previous: ["v2_20250720", "v1_20250420"] 
  deprecated: ["v0_20250120"]
  
# ✅ Audit logging
audit_events:
  - key_generation
  - key_rotation  
  - key_access
  - key_deprecation
```

## Implementation

### Step 4.1: HashiCorp Vault Integration

```yaml title="vault-key-management.yaml"
apiVersion: expanso.io/v1
kind: DataPipeline  
metadata:
  name: vault-key-manager
  namespace: default
spec:
  processors:
    - name: retrieve-current-keys
      type: mapping
      config:
        mapping: |
          # Retrieve current key versions from Vault
          let vault_response = http_request(
            "GET", 
            env("VAULT_ADDR") + "/v1/secret/data/expanso/encryption/current",
            {},
            {
              "X-Vault-Token": env("VAULT_TOKEN"),
              "Content-Type": "application/json"
            }
          )
          
          let key_data = vault_response.body.data.data
          
          # Store keys in processing context
          root = this.merge({
            "encryption_keys": {
              "card_key": key_data.card_encryption_key,
              "pii_key": key_data.pii_encryption_key, 
              "address_key": key_data.address_encryption_key,
              "key_version": key_data.version,
              "rotation_date": key_data.rotation_date,
              "expires_date": key_data.expires_date
            }
          })
          
    - name: check-key-expiration
      type: mapping
      config:
        mapping: |
          root = this
          
          # Check if keys need rotation
          let expires_date = this.encryption_keys.expires_date.parse_timestamp("2006-01-02T15:04:05Z")
          let now_date = now()
          let days_until_expiry = (expires_date - now_date).duration_hours() / 24
          
          root.key_status = {
            "days_until_expiry": days_until_expiry,
            "rotation_required": days_until_expiry <= 30,
            "rotation_urgent": days_until_expiry <= 7,
            "current_version": this.encryption_keys.key_version
          }
          
          # Alert if rotation needed
          if days_until_expiry <= 30 {
            http_request("POST", env("ALERT_WEBHOOK_URL"), {
              "alert": "key_rotation_required",
              "days_remaining": days_until_expiry,
              "key_version": this.encryption_keys.key_version,
              "urgency": if days_until_expiry <= 7 { "high" } else { "medium" }
            })
          }
          
    - name: perform-encryption-with-versioning
      type: mapping
      config:
        mapping: |
          # Use current keys for new encryption
          let keys = this.encryption_keys
          
          root = this
          
          # Encrypt payment data with versioned keys
          root.payment = if this.payment.exists() {
            this.payment.merge({
              "card_number_encrypted": keys.key_version + ":" + 
                crypto.encrypt_aes256_gcm(this.payment.card_number, keys.card_key),
              "encryption_metadata": {
                "key_version": keys.key_version,
                "encryption_timestamp": now(),
                "algorithm": "AES-256-GCM",
                "node_id": env("NODE_ID")
              }
            }).without("card_number")
          } else {
            this.payment
          }
          
    - name: log-key-access
      type: mapping 
      config:
        mapping: |
          # Audit log key access
          let audit_entry = {
            "event_type": "key_access",
            "key_version": this.encryption_keys.key_version,
            "accessed_by": env("NODE_ID"),
            "access_timestamp": now(),
            "purpose": "field_encryption", 
            "transaction_id": this.transaction_id,
            "fields_encrypted": ["card_number", "ssn", "email"]
          }
          
          # Send to audit system
          http_request("POST", env("AUDIT_LOG_ENDPOINT"), audit_entry, {
            "Authorization": "Bearer " + env("AUDIT_API_KEY"),
            "Content-Type": "application/json"
          })
          
          root = this

  environment:
    VAULT_ADDR: "${VAULT_ADDR}"
    VAULT_TOKEN: "${VAULT_TOKEN}"
    AUDIT_LOG_ENDPOINT: "${AUDIT_LOG_ENDPOINT}"  
    AUDIT_API_KEY: "${AUDIT_API_KEY}"
    ALERT_WEBHOOK_URL: "${ALERT_WEBHOOK_URL}"
    NODE_ID: "${NODE_ID}"
```

### Step 4.2: Automated Key Rotation

```yaml title="key-rotation-pipeline.yaml" 
apiVersion: expanso.io/v1
kind: DataPipeline
metadata:
  name: automated-key-rotation
  namespace: default
spec:
  processors:
    - name: generate-new-keys
      type: mapping
      config:
        mapping: |
          # Generate new encryption keys
          let new_version = "v" + (env("CURRENT_VERSION_NUM").number() + 1).string() + "_" + now().format_timestamp("20060102")
          
          let new_keys = {
            "card_encryption_key": crypto.generate_key_aes256(),
            "pii_encryption_key": crypto.generate_key_aes256(), 
            "address_encryption_key": crypto.generate_key_aes256(),
            "version": new_version,
            "created_date": now(),
            "rotation_date": now(),
            "expires_date": now().ts_add("2160h"),  # 90 days
            "previous_version": env("CURRENT_KEY_VERSION")
          }
          
          root = this.merge({"new_keys": new_keys})
          
    - name: store-keys-in-vault
      type: mapping
      config:
        mapping: |
          # Store new keys in Vault
          let vault_payload = {
            "data": this.new_keys
          }
          
          let vault_response = http_request(
            "POST",
            env("VAULT_ADDR") + "/v1/secret/data/expanso/encryption/" + this.new_keys.version,
            vault_payload,
            {
              "X-Vault-Token": env("VAULT_TOKEN"),
              "Content-Type": "application/json"
            }
          )
          
          # Update current key pointer
          http_request(
            "POST", 
            env("VAULT_ADDR") + "/v1/secret/data/expanso/encryption/current",
            vault_payload,
            {"X-Vault-Token": env("VAULT_TOKEN")}
          )
          
          root = this
          
    - name: notify-rotation-complete
      type: mapping
      config:
        mapping: |
          # Notify systems of key rotation
          let notification = {
            "event": "key_rotation_complete",
            "new_version": this.new_keys.version,
            "previous_version": this.new_keys.previous_version,
            "rotation_timestamp": now(),
            "affected_systems": ["payment_processing", "analytics", "reporting"]
          }
          
          # Send notifications
          ["security@company.com", "ops@company.com"].map_each(email -> 
            http_request("POST", env("EMAIL_API_ENDPOINT"), {
              "to": email,
              "subject": "Encryption Keys Rotated - " + this.new_keys.version,
              "body": notification | json.encode()
            })
          )
          
          root = this

  triggers:
    - schedule:
        cron: "0 2 * * 0"  # Every Sunday at 2 AM
    - webhook:
        path: "/admin/rotate-keys"
        auth: bearer_token
```

### Step 4.3: Multi-Version Decryption Support

```yaml title="multi-version-decryption.yaml"
- name: decrypt-with-version-support
  type: mapping
  config:
    mapping: |
      # Support decryption of data encrypted with previous key versions
      let encrypted_data = this.payment.card_number_encrypted
      let version_prefix = encrypted_data.split(":")[0]
      let ciphertext = encrypted_data.split(":").slice(1).join(":")
      
      # Retrieve appropriate key for version
      let key_response = http_request(
        "GET",
        env("VAULT_ADDR") + "/v1/secret/data/expanso/encryption/" + version_prefix,
        {},
        {"X-Vault-Token": env("VAULT_TOKEN")}
      )
      
      let decryption_key = key_response.body.data.data.card_encryption_key
      
      # Decrypt with version-specific key
      root.payment.card_number = crypto.decrypt_aes256_gcm(ciphertext, decryption_key)
      
      # Log decryption for audit
      http_request("POST", env("AUDIT_LOG_ENDPOINT"), {
        "event": "key_decryption",
        "key_version": version_prefix,
        "transaction_id": this.transaction_id,
        "timestamp": now()
      })
```

## AWS KMS Integration

For cloud-native deployments:

```yaml title="aws-kms-integration.yaml"
- name: encrypt-with-kms
  type: mapping
  config:
    mapping: |
      # Use AWS KMS for key management
      let kms_response = http_request(
        "POST",
        "https://kms." + env("AWS_REGION") + ".amazonaws.com/",
        {
          "KeyId": env("AWS_KMS_KEY_ID"),
          "Plaintext": this.payment.card_number.encode_base64()
        },
        {
          "X-Amz-Target": "TrentService.Encrypt",
          "Authorization": env("AWS_AUTH_HEADER"),
          "Content-Type": "application/x-amz-json-1.1"
        }
      )
      
      root.payment.card_number_encrypted = "KMS:" + env("AWS_KMS_KEY_VERSION") + ":" + 
        kms_response.body.CiphertextBlob
```

## Key Performance Monitoring

```yaml title="key-performance-monitoring.yaml"  
- name: monitor-encryption-performance
  type: mapping
  config:
    mapping: |
      let start_time = now()
      
      # Perform encryption operations
      root = this
      
      let end_time = now()
      let operation_duration = (end_time - start_time).duration_milliseconds()
      
      # Track key operation metrics
      root.key_metrics = {
        "encryption_duration_ms": operation_duration,
        "key_version": env("CURRENT_KEY_VERSION"),
        "operations_per_second": 1000 / operation_duration,
        "node_id": env("NODE_ID"),
        "timestamp": end_time
      }
      
      # Alert on performance degradation
      if operation_duration > 50 {  # 50ms threshold
        http_request("POST", env("PERFORMANCE_ALERT_URL"), {
          "alert": "slow_encryption_operation",
          "duration_ms": operation_duration,
          "key_version": env("CURRENT_KEY_VERSION"),
          "node_id": env("NODE_ID")
        })
      }
```

## Emergency Key Procedures

### Key Compromise Response

```bash title="Emergency key rotation procedure"
#!/bin/bash
# emergency-key-rotation.sh

# 1. Immediately generate new keys
NEW_VERSION="emergency_$(date +%Y%m%d_%H%M%S)"

# 2. Store in Vault
vault kv put secret/expanso/encryption/$NEW_VERSION \
  card_encryption_key=$(openssl rand -hex 32) \
  pii_encryption_key=$(openssl rand -hex 32) \
  address_encryption_key=$(openssl rand -hex 32) \
  created_date=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
  emergency_rotation=true

# 3. Update current key pointer  
vault kv put secret/expanso/encryption/current \
  @secret/expanso/encryption/$NEW_VERSION

# 4. Revoke compromised keys
vault kv delete secret/expanso/encryption/v1_20251020

# 5. Notify security team
curl -X POST $SECURITY_ALERT_URL \
  -d "{\"alert\":\"key_compromise\",\"new_version\":\"$NEW_VERSION\"}"
```

## Compliance and Auditing

### SOC 2 Key Management Controls

| Control | Implementation | Evidence |
|---------|---------------|----------|
| CC6.1 - Logical Access | Vault authentication required | Vault audit logs |
| CC6.2 - Key Management | Automated rotation | Rotation logs |  
| CC6.3 - Data Transmission | TLS + field encryption | Certificate audits |
| CC6.7 - System Boundaries | Key segregation | Network diagrams |

### Key Audit Reports

```sql title="Key usage audit queries"
-- Key rotation compliance
SELECT 
  key_version,
  created_date,
  expires_date,
  DATEDIFF(expires_date, NOW()) as days_until_expiry
FROM key_audit_log 
WHERE status = 'active'
ORDER BY expires_date;

-- Key access patterns  
SELECT 
  node_id,
  key_version,
  COUNT(*) as access_count,
  DATE(access_timestamp) as access_date
FROM key_access_log
WHERE access_timestamp >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY node_id, key_version, DATE(access_timestamp);
```

## Summary

✅ **Secure key storage** in HashiCorp Vault or AWS KMS
✅ **Automated key rotation** with configurable schedules
✅ **Key versioning** for backward compatibility  
✅ **Comprehensive auditing** of all key operations
✅ **Performance monitoring** for encryption operations
✅ **Emergency procedures** for key compromise scenarios

**Next step:** [Enable selective decryption](./step-5-selective-decryption) for authorized services.
