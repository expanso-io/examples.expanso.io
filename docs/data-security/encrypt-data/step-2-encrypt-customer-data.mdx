---
title: "Step 2 - Encrypt Customer PII Data"
sidebar_label: "Step 2: Customer Data Encryption"
sidebar_position: 5
description: Encrypt SSN, email, and phone numbers while preserving analytics utility for business intelligence
keywords: [pii, ssn, email, phone, gdpr, hipaa, personal-data, customer-data]
---

# Step 2: Encrypt Customer PII Data

Customer personally identifiable information (PII) must be protected under GDPR, HIPAA, and state privacy laws. This step implements encryption for Social Security Numbers, email addresses, phone numbers, and dates of birth while preserving essential analytics capabilities for fraud detection and business intelligence.

## Learning Objectives

By the end of this step, you'll be able to:

✅ **Encrypt Social Security Numbers** while preserving last 4 digits for customer service
✅ **Protect email addresses** while preserving domain information for organizational analysis
✅ **Secure phone numbers** while preserving area codes for geographic analytics  
✅ **Handle dates of birth** while preserving birth year for demographic analysis
✅ **Meet compliance requirements** for GDPR, HIPAA, and state privacy laws
✅ **Implement analytics-friendly encryption** that maintains business intelligence capabilities

## Problem: Customer Data Privacy Exposure

Modern applications collect extensive customer PII that must be protected under multiple privacy regulations:

```json title="Raw customer data (Privacy law violations)"
{
  "transaction_id": "txn_20251020_001",
  "customer": {
    "ssn": "123-45-6789",                    // ❌ SSN exposed (HIPAA/state law)
    "email": "sarah.johnson@acme.com",       // ❌ Personal email (GDPR Article 4)  
    "phone": "+1-415-555-0123",             // ❌ Phone number (CCPA/GDPR)
    "date_of_birth": "1985-03-15",          // ❌ Birth date (HIPAA identifier)
    "drivers_license": "D1234567890"        // ❌ State ID (Privacy law)
  }
}
```

**Privacy risks:**
- **Identity theft** - Complete SSN exposure enables identity fraud
- **GDPR violations** - Personal data processed without proper protection
- **HIPAA breaches** - Health identifiers exposed in medical contexts
- **State law violations** - California CCPA, Virginia CDPA, etc.
- **Organizational profiling** - Email domains reveal employer information
- **Geographic tracking** - Phone area codes enable location tracking

## Solution: Analytics-Preserving PII Encryption

Encrypt sensitive customer data while maintaining business intelligence capabilities:

```json title="Encrypted customer data (Privacy compliant)"
{
  "transaction_id": "txn_20251020_001", 
  "customer": {
    // Encrypted sensitive data
    "ssn_encrypted": "AES256GCM:v1:c3NuZGF0YWhlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:7e6d5c4b3a2g1h0f",
    "email_encrypted": "AES256GCM:v1:ZW1haWxkYXRhaGVyZWZvcnRlc3Rpbmdwcm9wb3Nlcw==:6d5c4b3a2g1h0f9e",
    "phone_encrypted": "AES256GCM:v1:cGhvbmVkYXRhaGVyZWZvcnRlc3Rpbmdwcm9wb3Nlcw==:5c4b3a2g1h0f9e8d",
    "dob_encrypted": "AES256GCM:v1:ZG9iZGF0YWhlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:4b3a2g1h0f9e8d7c",
    
    // Preserved analytics metadata
    "ssn_last_four": "6789",               // ✅ Customer service lookup
    "email_domain": "acme.com",            // ✅ B2B vs B2C analysis
    "phone_area_code": "415",              // ✅ Geographic analytics
    "birth_year": 1985,                    // ✅ Demographic segmentation
    "age_range": "35-40"                   // ✅ Age cohort analysis
  }
}
```

**Benefits:**
- **Privacy compliance** - Encrypted PII meets GDPR/HIPAA requirements
- **Business analytics** - Demographics and geography preserved for insights
- **Customer service** - Partial identifiers enable support lookup
- **Fraud detection** - Patterns maintained for security analysis

## Implementation

### Step 2.1: Create Customer Data Encryption Processor

Build a processor that validates, encrypts, and preserves analytics metadata for customer PII:

```yaml title="customer-pii-encryption.yaml"
apiVersion: expanso.io/v1
kind: DataPipeline
metadata:
  name: customer-encryption-step2
  namespace: default
spec:
  processors:
    - name: validate-customer-data
      type: mapping
      config:
        mapping: |
          # Validate customer object exists
          root = if !this.customer.exists() {
            throw("customer object is required")
          } else {
            this
          }
          
          # Validate at least one PII field exists
          let pii_fields = ["ssn", "email", "phone", "date_of_birth"]
          let has_pii = pii_fields.any(field -> this.customer.get(field).exists())
          
          root = if !has_pii {
            throw("At least one customer PII field required: " + pii_fields.join(", "))
          } else {
            this
          }
          
    - name: encrypt-ssn
      type: mapping
      config:
        mapping: |
          root = this
          
          # Encrypt SSN if present
          root.customer = if this.customer.ssn.exists() {
            let ssn = this.customer.ssn.string()
            
            # Validate SSN format (XXX-XX-XXXX or 9 digits)
            let clean_ssn = ssn.re_replace_all("[^0-9]", "")
            
            if clean_ssn.length() != 9 {
              throw("SSN must be 9 digits, got: " + clean_ssn.length().string())
            } else if !clean_ssn.re_match("^[0-9]{9}$") {
              throw("SSN must contain only digits")
            } else {
              this.customer.merge({
                "ssn_encrypted": crypto.encrypt_aes256_gcm(
                  ssn,
                  env("PII_ENCRYPTION_KEY"),
                  "ssn"
                ),
                "ssn_last_four": clean_ssn.slice(-4),
                "ssn_area": clean_ssn.slice(0, 3)  # For fraud detection patterns
              }).without("ssn")
            }
          } else {
            this.customer
          }
          
    - name: encrypt-email
      type: mapping
      config:
        mapping: |
          root = this
          
          # Encrypt email if present
          root.customer = if this.customer.email.exists() {
            let email = this.customer.email.string().lowercase()
            
            # Validate email format
            if !email.re_match("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$") {
              throw("Invalid email format: " + email)
            } else {
              let email_parts = email.split("@")
              let username = email_parts[0]
              let domain = email_parts[1]
              
              this.customer.merge({
                "email_encrypted": crypto.encrypt_aes256_gcm(
                  email,
                  env("PII_ENCRYPTION_KEY"),
                  "email"
                ),
                "email_domain": domain,
                "email_provider": if [
                  "gmail.com", "yahoo.com", "hotmail.com", "outlook.com", 
                  "aol.com", "icloud.com"
                ].contains(domain) { "personal" } else { "business" },
                "email_username_length": username.length()
              }).without("email")
            }
          } else {
            this.customer
          }
          
    - name: encrypt-phone
      type: mapping
      config:
        mapping: |
          root = this
          
          # Encrypt phone if present
          root.customer = if this.customer.phone.exists() {
            let phone = this.customer.phone.string()
            
            # Clean phone number (remove formatting)
            let clean_phone = phone.re_replace_all("[^0-9+]", "")
            
            # Validate phone format
            if !clean_phone.re_match("^\\+?1?[0-9]{10,11}$") {
              throw("Invalid phone format: " + phone + " (cleaned: " + clean_phone + ")")
            } else {
              # Extract area code for US numbers
              let area_code = if clean_phone.has_prefix("+1") {
                clean_phone.slice(2, 5)
              } else if clean_phone.has_prefix("1") && clean_phone.length() == 11 {
                clean_phone.slice(1, 4)  
              } else if clean_phone.length() == 10 {
                clean_phone.slice(0, 3)
              } else {
                "unknown"
              }
              
              this.customer.merge({
                "phone_encrypted": crypto.encrypt_aes256_gcm(
                  phone,
                  env("PII_ENCRYPTION_KEY"),
                  "phone"
                ),
                "phone_area_code": area_code,
                "phone_country": if clean_phone.has_prefix("+1") || 
                                    (clean_phone.length() >= 10 && !clean_phone.has_prefix("+")) {
                  "US"
                } else {
                  "international" 
                },
                "phone_type": if area_code.re_match("^(800|844|855|866|877|888)$") {
                  "toll_free"
                } else {
                  "standard"
                }
              }).without("phone")
            }
          } else {
            this.customer
          }
          
    - name: encrypt-date-of-birth
      type: mapping
      config:
        mapping: |
          root = this
          
          # Encrypt date of birth if present
          root.customer = if this.customer.date_of_birth.exists() {
            let dob = this.customer.date_of_birth.string()
            
            # Validate date format (YYYY-MM-DD)
            if !dob.re_match("^[0-9]{4}-[0-9]{2}-[0-9]{2}$") {
              throw("Date of birth must be YYYY-MM-DD format, got: " + dob)
            } else {
              let parsed_date = dob.parse_timestamp("2006-01-02")
              let birth_year = parsed_date.format_timestamp("2006").number()
              let current_year = now().format_timestamp("2006").number()
              let age = current_year - birth_year
              
              # Validate reasonable age (0-120)
              if age < 0 || age > 120 {
                throw("Invalid birth year: " + birth_year.string() + " (age: " + age.string() + ")")
              } else {
                # Determine age range for analytics
                let age_range = if age < 18 {
                  "under_18"
                } else if age < 25 {
                  "18_24" 
                } else if age < 35 {
                  "25_34"
                } else if age < 45 {
                  "35_44"
                } else if age < 55 {
                  "45_54"
                } else if age < 65 {
                  "55_64"
                } else {
                  "65_plus"
                }
                
                this.customer.merge({
                  "dob_encrypted": crypto.encrypt_aes256_gcm(
                    dob,
                    env("PII_ENCRYPTION_KEY"), 
                    "date_of_birth"
                  ),
                  "birth_year": birth_year,
                  "age": age,
                  "age_range": age_range,
                  "generation": if birth_year >= 1997 {
                    "gen_z"
                  } else if birth_year >= 1981 {
                    "millennial"
                  } else if birth_year >= 1965 {
                    "gen_x"
                  } else if birth_year >= 1946 {
                    "baby_boomer"
                  } else {
                    "silent_generation"
                  }
                }).without("date_of_birth")
              }
            }
          } else {
            this.customer
          }
          
    - name: add-customer-encryption-metadata
      type: mapping
      config:
        mapping: |
          root = this
          
          # Collect encrypted fields
          let encrypted_fields = []
          let preserved_fields = []
          
          # Check what was encrypted
          if this.customer.ssn_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("customer.ssn_encrypted")
            preserved_fields = preserved_fields.concat(["customer.ssn_last_four", "customer.ssn_area"])
          }
          
          if this.customer.email_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("customer.email_encrypted") 
            preserved_fields = preserved_fields.concat(["customer.email_domain", "customer.email_provider"])
          }
          
          if this.customer.phone_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("customer.phone_encrypted")
            preserved_fields = preserved_fields.concat(["customer.phone_area_code", "customer.phone_country"])
          }
          
          if this.customer.dob_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("customer.dob_encrypted")
            preserved_fields = preserved_fields.concat(["customer.birth_year", "customer.age_range"])
          }
          
          # Add customer encryption metadata
          root.customer.encryption_metadata = {
            "encrypted_fields": encrypted_fields,
            "preserved_fields": preserved_fields,
            "encryption_timestamp": now(),
            "encryption_algorithm": "AES-256-GCM",
            "key_version": env("KEY_VERSION"),
            "node_id": env("NODE_ID"),
            "compliance_standards": ["GDPR", "CCPA", "HIPAA"],
            "data_classification": "PII"
          }

  input:
    http_server:
      address: "0.0.0.0:8443"
      path: /customers/encrypt-pii
      allowed_verbs: ["POST"]
      timeout: "30s"
      tls:
        enabled: true
        cert_file: "/etc/expanso/certs/server.crt"
        key_file: "/etc/expanso/certs/server.key"

  output:
    stdout: {}
    
  environment:
    PII_ENCRYPTION_KEY: "${PII_ENCRYPTION_KEY}"
    KEY_VERSION: "${KEY_VERSION}"
    NODE_ID: "${NODE_ID}"
```

### Step 2.2: Deploy Customer PII Encryption

Deploy the customer data encryption processor:

```bash title="Deploy customer PII encryption"
# Deploy the processor
expanso job deploy customer-pii-encryption.yaml

# Wait for deployment
sleep 10

# Check deployment status
expanso job status customer-encryption-step2
```

### Step 2.3: Test Customer Data Encryption

Test comprehensive customer PII encryption:

```bash title="Test complete customer PII encryption"
curl -X POST https://localhost:8443/customers/encrypt-pii \
  --cacert /etc/expanso/certs/ca.crt \
  --cert /etc/expanso/certs/client.crt \
  --key /etc/expanso/certs/client.key \
  -H "Content-Type: application/json" \
  -d '{
    "transaction_id": "txn_customer_001",
    "customer": {
      "ssn": "123-45-6789",
      "email": "sarah.johnson@acme.com",
      "phone": "+1-415-555-0123", 
      "date_of_birth": "1985-03-15"
    }
  }'
```

**Expected response:**
```json
{
  "transaction_id": "txn_customer_001",
  "customer": {
    "ssn_encrypted": "AES256GCM:v1:c3NuZGF0YWhlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:7e6d5c4b3a2g1h0f",
    "email_encrypted": "AES256GCM:v1:ZW1haWxkYXRhaGVyZWZvcnRlc3Rpbmdwcm9wb3Nlcw==:6d5c4b3a2g1h0f9e",
    "phone_encrypted": "AES256GCM:v1:cGhvbmVkYXRhaGVyZWZvcnRlc3Rpbmdwcm9wb3Nlcw==:5c4b3a2g1h0f9e8d",
    "dob_encrypted": "AES256GCM:v1:ZG9iZGF0YWhlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:4b3a2g1h0f9e8d7c",
    "ssn_last_four": "6789",
    "ssn_area": "123",
    "email_domain": "acme.com", 
    "email_provider": "business",
    "email_username_length": 12,
    "phone_area_code": "415",
    "phone_country": "US",
    "phone_type": "standard",
    "birth_year": 1985,
    "age": 39,
    "age_range": "35_44",
    "generation": "millennial",
    "encryption_metadata": {
      "encrypted_fields": [
        "customer.ssn_encrypted",
        "customer.email_encrypted", 
        "customer.phone_encrypted",
        "customer.dob_encrypted"
      ],
      "preserved_fields": [
        "customer.ssn_last_four", "customer.email_domain",
        "customer.phone_area_code", "customer.birth_year"
      ],
      "encryption_timestamp": "2025-10-20T14:30:01.234Z",
      "encryption_algorithm": "AES-256-GCM",
      "key_version": "v1_20251020",
      "node_id": "edge-encryption-001",
      "compliance_standards": ["GDPR", "CCPA", "HIPAA"],
      "data_classification": "PII"
    }
  }
}
```

Test individual field encryption:

```bash title="Test SSN-only encryption" 
curl -X POST https://localhost:8443/customers/encrypt-pii \
  -H "Content-Type: application/json" \
  --cacert /etc/expanso/certs/ca.crt \
  --cert /etc/expanso/certs/client.crt \
  --key /etc/expanso/certs/client.key \
  -d '{
    "customer": {
      "ssn": "987-65-4321"
    }
  }'
```

```bash title="Test email-only encryption"
curl -X POST https://localhost:8443/customers/encrypt-pii \
  -H "Content-Type: application/json" \
  --cacert /etc/expanso/certs/ca.crt \
  --cert /etc/expanso/certs/client.crt \
  --key /etc/expanso/certs/client.key \
  -d '{
    "customer": {
      "email": "john.doe@gmail.com"  
    }
  }'
```

Test validation errors:

```bash title="Test invalid SSN"
curl -X POST https://localhost:8443/customers/encrypt-pii \
  -H "Content-Type: application/json" \
  --cacert /etc/expanso/certs/ca.crt \
  --cert /etc/expanso/certs/client.crt \
  --key /etc/expanso/certs/client.key \
  -d '{
    "customer": {
      "ssn": "123-45-67890"  # Too many digits
    }
  }'
```

## Advanced PII Encryption Patterns

### Pattern 1: International Phone Number Support

Extend phone encryption for international formats:

```yaml title="International phone encryption"
- name: encrypt-international-phone
  type: mapping
  config:
    mapping: |
      # Enhanced international phone handling
      let phone = this.customer.phone.string()
      let country_code = if phone.has_prefix("+") {
        phone.re_find("^\\+([0-9]{1,3})")[0][1] 
      } else { "1" }
      
      # Country-specific parsing
      let phone_data = if country_code == "1" {
        # North America (US/Canada)
        let cleaned = phone.re_replace_all("[^0-9]", "")
        let area_code = if cleaned.length() == 11 {
          cleaned.slice(1, 4)
        } else { cleaned.slice(0, 3) }
        {
          "country": "US",
          "area_code": area_code,
          "format": "NANP"
        }
      } else if country_code == "44" {
        # United Kingdom
        { "country": "UK", "area_code": "unknown", "format": "E164" }
      } else if country_code == "49" {
        # Germany  
        { "country": "DE", "area_code": "unknown", "format": "E164" }
      } else {
        # Other international
        { "country": "international", "area_code": "unknown", "format": "E164" }
      }
      
      root.customer.phone_encrypted = crypto.encrypt_aes256_gcm(phone, env("PII_ENCRYPTION_KEY"))
      root.customer.phone_country = phone_data.country
      root.customer.phone_area_code = phone_data.area_code
      root.customer.phone_format = phone_data.format
```

### Pattern 2: GDPR Data Subject Rights

Implement GDPR data subject request handling:

```yaml title="GDPR data subject rights"
- name: gdpr-subject-rights
  type: mapping
  config:
    mapping: |
      # Handle GDPR subject access requests
      let request_type = metadata().http.request.headers."X-GDPR-Request-Type"
      
      root = if request_type == "subject_access" {
        # Provide metadata for subject access requests (no decryption)
        this.merge({
          "gdpr_response": {
            "data_collected": this.customer.encryption_metadata.encrypted_fields,
            "data_retained": this.customer.encryption_metadata.preserved_fields,
            "legal_basis": "legitimate_interest",
            "retention_period": "7_years",
            "data_controller": env("DATA_CONTROLLER"),
            "processing_purpose": "transaction_processing"
          }
        })
      } else if request_type == "data_deletion" {
        # Mark for deletion (retain transaction ID only)
        {
          "transaction_id": this.transaction_id,
          "customer": {
            "data_deleted": true,
            "deletion_timestamp": now(),
            "deletion_method": "cryptographic_erasure"
          }
        }
      } else {
        this
      }
```

### Pattern 3: HIPAA Safe Harbor Compliance

Implement HIPAA safe harbor de-identification:

```yaml title="HIPAA safe harbor compliance"
- name: hipaa-safe-harbor
  type: mapping
  config:
    mapping: |
      # HIPAA Safe Harbor Method compliance
      root = this
      
      # Encrypt all 18 HIPAA identifiers
      let hipaa_identifiers = [
        "ssn", "email", "phone", "date_of_birth",
        "medical_record_number", "health_plan_number",
        "account_number", "license_number",
        "vehicle_serial_number", "device_serial_number",
        "web_url", "ip_address", "biometric_identifier"
      ]
      
      # Check coverage of HIPAA identifiers
      let encrypted_hipaa = hipaa_identifiers.filter(id -> 
        this.customer.get(id + "_encrypted").exists()
      )
      
      root.hipaa_compliance = {
        "method": "safe_harbor",
        "identifiers_encrypted": encrypted_hipaa,
        "identifiers_preserved": [
          "birth_year", "age_range", "zip_code_3digit"  
        ],
        "compliant": encrypted_hipaa.length() >= 16,  # Most of 18 identifiers
        "certification_date": now()
      }
```

## Analytics and Business Intelligence

### Customer Segmentation Capabilities

The preserved metadata enables sophisticated customer analytics:

```sql title="Customer analytics with encrypted data"
-- Age demographics (birth year preserved)
SELECT age_range, COUNT(*) as customers, AVG(transaction_amount)
FROM transactions 
WHERE DATE(created) >= '2025-01-01'
GROUP BY age_range;

-- Geographic distribution (area code preserved)
SELECT phone_area_code, COUNT(*) as customers
FROM transactions
WHERE phone_area_code IS NOT NULL
GROUP BY phone_area_code
ORDER BY customers DESC;

-- B2B vs B2C analysis (email domain preserved)
SELECT 
  email_provider,
  COUNT(*) as customers,
  AVG(transaction_amount),
  SUM(transaction_amount) as total_revenue
FROM transactions
GROUP BY email_provider;

-- Generational trends (generation preserved)
SELECT 
  generation,
  age_range, 
  COUNT(*) as customers,
  AVG(transaction_amount)
FROM transactions  
GROUP BY generation, age_range;

-- Customer service queries (last 4 digits preserved)
SELECT transaction_id, customer_id, amount
FROM transactions
WHERE ssn_last_four = '6789'
  AND created >= DATE_SUB(NOW(), INTERVAL 30 DAY);
```

### Fraud Detection Patterns

Use preserved metadata for fraud detection without decrypting PII:

```yaml title="Fraud detection with encrypted PII"
- name: fraud-detection-analysis
  type: mapping
  config:
    mapping: |
      # Analyze patterns without decrypting PII
      let fraud_score = 0
      
      # Geographic risk (area code analysis)
      let high_risk_areas = ["917", "646", "718"]  # Example NYC areas
      fraud_score = if high_risk_areas.contains(this.customer.phone_area_code) {
        fraud_score + 10
      } else { fraud_score }
      
      # Age risk (very young or old users)
      fraud_score = if this.customer.age < 18 || this.customer.age > 80 {
        fraud_score + 15
      } else { fraud_score }
      
      # Email provider risk  
      fraud_score = if this.customer.email_provider == "personal" && this.amount > 1000 {
        fraud_score + 20
      } else { fraud_score }
      
      # SSN area number risk (known fraudulent patterns)
      let suspicious_ssn_areas = ["000", "666", "900", "999"]
      fraud_score = if suspicious_ssn_areas.contains(this.customer.ssn_area) {
        fraud_score + 50  # High risk
      } else { fraud_score }
      
      root = this.merge({
        "fraud_analysis": {
          "risk_score": fraud_score,
          "risk_level": if fraud_score >= 50 { "high" }
                       else if fraud_score >= 25 { "medium" }  
                       else { "low" },
          "risk_factors": {
            "geographic": high_risk_areas.contains(this.customer.phone_area_code),
            "age_range": this.customer.age < 18 || this.customer.age > 80,
            "email_type": this.customer.email_provider,
            "ssn_pattern": suspicious_ssn_areas.contains(this.customer.ssn_area)
          }
        }
      })
```

## Security and Compliance

### GDPR Compliance Checklist

Verify GDPR compliance with automated checks:

| GDPR Article | Requirement | Implementation | Status |
|--------------|-------------|----------------|--------|
| Article 25 | Data Protection by Design | Encryption at collection point | ✅ |
| Article 32 | Security of Processing | AES-256-GCM encryption | ✅ |
| Article 5(1)(e) | Data Minimization | Only necessary metadata preserved | ✅ |
| Article 17 | Right to Erasure | Cryptographic erasure via key deletion | ✅ |
| Article 15 | Right of Access | Metadata provided, no decryption | ✅ |
| Article 30 | Records of Processing | Audit logs and encryption metadata | ✅ |

### CCPA Compliance Implementation

California Consumer Privacy Act compliance features:

```yaml title="CCPA compliance features"
- name: ccpa-privacy-rights
  type: mapping
  config:
    mapping: |
      let ccpa_request = metadata().http.request.headers."X-CCPA-Request"
      
      root = if ccpa_request == "opt_out_sale" {
        # Mark data for no sale/sharing
        this.merge({
          "ccpa_flags": {
            "opt_out_sale": true,
            "opt_out_sharing": true,
            "effective_date": now(),
            "data_retention": "business_purpose_only"
          }
        })
      } else if ccpa_request == "delete_personal_info" {
        # California deletion right
        {
          "transaction_id": this.transaction_id,
          "ccpa_deletion": {
            "deleted": true,
            "deletion_date": now(),
            "verification_method": "encrypted_email_confirmation",
            "retention_exception": "legal_obligation"  # Tax records
          }
        }
      } else {
        this
      }
```

## Performance Optimization and Monitoring

### PII Encryption Performance

Monitor encryption performance for PII fields:

```yaml title="PII encryption performance monitoring"
- name: pii-performance-monitor
  type: mapping
  config:
    mapping: |
      let start_time = now()
      
      # Perform all PII encryption operations
      root = this
      
      let end_time = now()
      let encryption_duration = (end_time - start_time).duration_milliseconds()
      
      # Count encrypted fields
      let field_count = [
        this.customer.ssn_encrypted.exists(),
        this.customer.email_encrypted.exists(), 
        this.customer.phone_encrypted.exists(),
        this.customer.dob_encrypted.exists()
      ].fold(0, (acc, exists) -> if exists { acc + 1 } else { acc })
      
      root.performance_metrics = {
        "pii_encryption_duration_ms": encryption_duration,
        "fields_encrypted": field_count,
        "throughput_fields_per_ms": field_count / encryption_duration,
        "node_id": env("NODE_ID"),
        "timestamp": end_time
      }
      
      # Performance alerting
      if encryption_duration > 25 {  # 25ms threshold for PII
        http_request("POST", env("PERFORMANCE_ALERT_URL"), {
          "alert": "slow_pii_encryption",
          "duration_ms": encryption_duration,
          "threshold_ms": 25,
          "fields": field_count,
          "node_id": env("NODE_ID")
        })
      }
```

## Common Issues and Troubleshooting

### Issue: SSN validation failures
**Symptom:** "SSN must be 9 digits" errors with valid SSNs

**Diagnosis:**
```bash
# Test SSN cleaning
python3 -c "
import re
ssn = '123-45-6789'
cleaned = re.sub(r'[^0-9]', '', ssn)
print(f'Original: {ssn}')
print(f'Cleaned: {cleaned}')
print(f'Length: {len(cleaned)}')
"
```

**Solutions:**
```yaml
# Enhanced SSN validation
let ssn_patterns = [
  "^[0-9]{3}-[0-9]{2}-[0-9]{4}$",  # XXX-XX-XXXX
  "^[0-9]{3}\\s[0-9]{2}\\s[0-9]{4}$",  # XXX XX XXXX
  "^[0-9]{9}$"  # XXXXXXXXX
]

let valid_format = ssn_patterns.any(pattern -> ssn.re_match(pattern))
```

### Issue: Email domain extraction errors  
**Symptom:** Missing or incorrect email domains

**Solution:**
```yaml
# Robust email parsing
let email_parts = email.lowercase().split("@")
root.email_domain = if email_parts.length() == 2 {
  email_parts[1].trim()
} else {
  throw("Invalid email format: multiple @ symbols")
}
```

### Issue: Phone area code detection fails
**Symptom:** Area codes showing as "unknown" for valid US numbers

**Solution:**
```yaml  
# Enhanced US phone parsing
let digits_only = phone.re_replace_all("[^0-9]", "")
let area_code = if digits_only.length() == 10 {
  digits_only.slice(0, 3)
} else if digits_only.length() == 11 && digits_only.has_prefix("1") {
  digits_only.slice(1, 4)
} else {
  "unknown"  
}

# Validate area code is not 0XX or 1XX
area_code = if area_code.re_match("^[01][0-9]{2}$") {
  "invalid"
} else {
  area_code
}
```

---

## Summary

You've successfully implemented comprehensive customer PII encryption with:

✅ **SSN encryption** with last 4 digit preservation for customer service
✅ **Email encryption** with domain preservation for B2B/B2C analytics
✅ **Phone encryption** with area code preservation for geographic insights
✅ **Date of birth encryption** with demographic metadata for segmentation  
✅ **Compliance features** for GDPR, CCPA, and HIPAA requirements
✅ **Analytics preservation** enabling fraud detection and business intelligence

**Key achievements:**
- Customer PII is now encrypted at the edge before transmission
- Privacy law compliance scope significantly improved
- Business analytics capabilities preserved through selective metadata
- Comprehensive audit trail for regulatory reporting

**Next step:** [Encrypt address and location data](./step-3-encrypt-location-data) while preserving geographic analytics.

---

## Related Resources

- [**Step 3: Encrypt Location Data**](./step-3-encrypt-location-data) - Address and geographic privacy
- [**GDPR Compliance Guide**](https://gdpr.eu/) - European privacy regulation  
- [**CCPA Compliance Guide**](https://oag.ca.gov/privacy/ccpa) - California privacy law
- [**HIPAA Safe Harbor**](https://www.hhs.gov/hipaa/for-professionals/privacy/special-topics/de-identification/) - Healthcare de-identification
