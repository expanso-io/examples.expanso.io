---
title: How to Encrypt Sensitive Data in Transit
sidebar_label: Encrypt Data
sidebar_position: 3
description: Field-level encryption for PII and sensitive information
keywords: [encryption, aes, field-level, security, key management]
---

import CodeBlock from '@theme/CodeBlock';
import pipelineYaml from '!!raw-loader!../../examples/data-security/encrypt-data.yaml';


# How to Encrypt Sensitive Data in Transit

Sensitive data transmitted between edge nodes and cloud systems faces multiple threat vectors: network interception, man-in-the-middle attacks, insider access to storage systems, and regulatory compliance requirements. While TLS encrypts data during network transmission, it leaves data vulnerable once it reaches storage or processing systems where operators, DBAs, and compromised cloud services can access it in plaintext.

This guide shows you how to implement field-level encryption for sensitive data like credit card numbers, social security numbers, and protected health information (PHI). You'll encrypt data at the edge before it leaves your trusted network boundary, ensuring only authorized systems with decryption keys can access the original values. The data remains encrypted through network transit, cloud storage, analytics pipelines, and backup systems.

## Why Field-Level Encryption at the Edge?

Field-level encryption at the edge provides security advantages that TLS and full-disk encryption cannot deliver:

**Security Benefits:**
- Defense in depth (data encrypted even if TLS is compromised)
- Zero-trust architecture (data protected at rest in cloud systems)
- Insider threat protection (cloud operators cannot access plaintext)
- Breach containment (stolen databases contain encrypted values)
- Selective decryption (only authorized services get decryption keys)

**Compliance Benefits:**
- PCI-DSS compliance (credit card encryption required)
- HIPAA compliance (PHI must be encrypted in transit and at rest)
- SOC 2 requirements (encryption of sensitive data)
- Reduced compliance scope (encrypted data often exempt from regulations)
- Audit trail of encryption operations (who encrypted what, when)

**Operational Benefits:**
- Centralized key management (rotate keys without touching data sources)
- Granular access control (different keys for different data types)
- Edge processing reduces cloud security burden
- Encrypted data can be stored in lower-security environments
- Simplified vendor security reviews (data pre-encrypted)

**Cost Benefits:**
- Lower cloud security costs (encrypted data needs less protection)
- Reduced audit costs (smaller compliance scope)
- Fewer security controls needed for encrypted data
- Simplified data residency compliance (encrypted data less restricted)

## Prerequisites

Before starting this guide, you'll need:

- **Expanso installed and running** - Complete [Getting Started](https://docs.expanso.io/getting-started) first
- **An edge node connected** to your orchestrator
- **Sample data containing sensitive fields** to test encryption
- **Basic understanding of AES encryption** - Familiarity with symmetric encryption concepts
- **Key management system** (optional) - HashiCorp Vault, AWS KMS, or secure environment variables

## Problem Statement

Consider a payment processing system where point-of-sale terminals send transaction data to the cloud for processing. Each transaction contains multiple sensitive fields:

```json title="Payment transaction with sensitive data"
{
  "transaction_id": "txn_20251020_001",
  "timestamp": "2025-10-20T14:30:00Z",
  "merchant_id": "merchant_789",
  "amount": 127.50,
  "currency": "USD",

  // Sensitive: PCI-DSS regulated data
  "payment": {
    "card_number": "4532-1234-5678-9010",
    "cvv": "123",
    "expiration": "12/27",
    "cardholder_name": "Sarah Johnson"
  },

  // Sensitive: PII for fraud detection
  "customer": {
    "email": "sarah.johnson@example.com",
    "phone": "+1-415-555-0123",
    "ssn": "123-45-6789",
    "date_of_birth": "1985-03-15"
  },

  // Sensitive: Location data
  "billing_address": {
    "street": "123 Main St",
    "city": "San Francisco",
    "state": "CA",
    "zip": "94102",
    "country": "US"
  },

  // Safe: Business data (not sensitive)
  "metadata": {
    "terminal_id": "pos_42",
    "transaction_type": "card_present",
    "merchant_category": "5814"
  }
}
```

**Security risks without encryption:**

1. **Network interception** - TLS protects in-transit, but data exposed if TLS is compromised
2. **Cloud storage exposure** - Data stored in plaintext in databases, logs, backups
3. **Insider access** - Cloud operators, DBAs, support staff can view sensitive data
4. **Vendor exposure** - Third-party analytics services receive plaintext data
5. **Backup vulnerabilities** - Backup tapes/snapshots contain plaintext data
6. **Compliance violations** - PCI-DSS requires encryption of cardholder data

**What needs encryption:**
- Credit card numbers (PCI-DSS requirement)
- CVV codes (PCI-DSS requirement)
- Social security numbers (PII protection)
- Email addresses and phone numbers (PII protection)
- Billing addresses (PII protection)
- Protected health information if applicable (HIPAA requirement)

**What can remain plaintext:**
- Transaction IDs (needed for queries)
- Timestamps (needed for time-series analysis)
- Merchant IDs (needed for reporting)
- Amounts and currency (needed for analytics)
- Terminal IDs (needed for diagnostics)
- Non-PII metadata

The challenge: encrypt sensitive fields while keeping data usable for analytics, fraud detection, and business intelligence.

## Solution Overview

This guide implements a comprehensive field-level encryption strategy:

1. **Identify sensitive fields** - Classify which fields contain PII/PCI data
2. **Encrypt with AES-256-GCM** - Use industry-standard authenticated encryption
3. **Manage encryption keys** - Implement secure key storage and rotation
4. **Preserve data utility** - Keep non-sensitive fields in plaintext for analytics
5. **Implement key rotation** - Periodically rotate keys for security best practices
6. **Audit encryption operations** - Log what was encrypted, when, and by whom
7. **Support selective decryption** - Allow authorized services to decrypt specific fields

Let's build the complete encryption pipeline step by step.

## Step 1: Generate Encryption Keys

Generate secure AES-256 encryption keys for different data types:

```bash title="Generate encryption keys"
# Generate master encryption key for credit card data (32 bytes = 256 bits)
export CARD_ENCRYPTION_KEY=$(openssl rand -hex 32)
echo "Card encryption key: $CARD_ENCRYPTION_KEY"

# Generate key for PII data (SSN, email, phone)
export PII_ENCRYPTION_KEY=$(openssl rand -hex 32)
echo "PII encryption key: $PII_ENCRYPTION_KEY"

# Generate key for address data
export ADDRESS_ENCRYPTION_KEY=$(openssl rand -hex 32)
echo "Address encryption key: $ADDRESS_ENCRYPTION_KEY"

# Generate key ID for rotation tracking
export KEY_VERSION="v1_20251020"
echo "Key version: $KEY_VERSION"
```

:::danger Protect Your Encryption Keys
Encryption keys are the most critical secrets in your system. If an attacker obtains them, all encrypted data can be decrypted. **Never:**
- Store keys in source code or configuration files
- Commit keys to version control
- Log keys in application logs
- Transmit keys over unencrypted channels
- Share keys between environments (dev/staging/prod)

**Always:**
- Use a key management system (HashiCorp Vault, AWS KMS, Google Cloud KMS)
- Rotate keys periodically (every 90 days minimum)
- Implement key versioning for rotation
- Audit all key access
- Use separate keys for different data types
:::

**Production key management:**

```bash title="Store keys in HashiCorp Vault"
# Store keys in Vault (production approach)
vault kv put secret/expanso/encryption/card \
  key=$CARD_ENCRYPTION_KEY \
  version=$KEY_VERSION \
  created=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

vault kv put secret/expanso/encryption/pii \
  key=$PII_ENCRYPTION_KEY \
  version=$KEY_VERSION \
  created=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

vault kv put secret/expanso/encryption/address \
  key=$ADDRESS_ENCRYPTION_KEY \
  version=$KEY_VERSION \
  created=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# Verify keys are stored
vault kv get secret/expanso/encryption/card
```

**Key rotation schedule:**

```bash
# Recommended rotation schedule
# - High-sensitivity keys (credit cards, SSN): Every 90 days
# - Medium-sensitivity keys (PII): Every 180 days
# - Low-sensitivity keys (addresses): Every 365 days

# Set up automatic rotation alerts
cat > /etc/cron.d/key-rotation-alert <<'EOF'
# Alert when keys are approaching rotation deadline
0 9 * * 1 root /usr/local/bin/check-key-age.sh && \
  mail -s "Encryption keys require rotation" security@example.com
EOF
```

## Step 2: Create the Encryption Pipeline

Create a pipeline that encrypts sensitive fields using the [encryption patterns](/examples/data-security/encryption-patterns) documented separately. This example shows a complete payment processing pipeline.

:::tip
The encryption logic below uses reusable patterns. See [Field-Level Encryption Patterns](/examples/data-security/encryption-patterns) for:
- [Credit card encryption with brand detection](/examples/data-security/encryption-patterns#credit-card-encryption)
- [SSN encryption with last-4 preservation](/examples/data-security/encryption-patterns#ssn-encryption)
- [Email encryption with domain preservation](/examples/data-security/encryption-patterns#email-encryption)
- [Phone encryption with area code preservation](/examples/data-security/encryption-patterns#phone-encryption)
- [Address encryption patterns](/examples/data-security/encryption-patterns#address-encryption)
- [Multi-key encryption strategy](/examples/data-security/encryption-patterns#multi-key-encryption)
- [Key rotation patterns](/examples/data-security/encryption-patterns#key-rotation)
:::

<CodeBlock language="yaml" title="field-encryption-pipeline.yaml" showLineNumbers>
  {pipelineYaml}
</CodeBlock>

<a
  href="/files/data-security/encrypt-data.yaml"
  download
  className="button button--primary button--lg margin-top--md"
>
  üì• Download Pipeline
</a>

---


**Pipeline steps:**
1. Parse JSON input
2. Validate required fields
3. Encrypt credit card data ([pattern](/examples/data-security/encryption-patterns#credit-card-encryption))
4. Encrypt PII data ([pattern](/examples/data-security/encryption-patterns#ssn-encryption))
5. Encrypt address data ([pattern](/examples/data-security/encryption-patterns#address-encryption))
6. Add encryption metadata ([pattern](/examples/data-security/encryption-patterns#encryption-metadata-pattern))
7. Validate encryption completed ([pattern](/examples/data-security/encryption-patterns#validation-pattern))

## Step 3: Deploy the Encryption Pipeline

Deploy the encryption pipeline to your edge nodes:

```bash title="Deploy encryption pipeline"
# Set environment variables for encryption keys
export CARD_ENCRYPTION_KEY="your-card-key-here"
export PII_ENCRYPTION_KEY="your-pii-key-here"
export ADDRESS_ENCRYPTION_KEY="your-address-key-here"
export KEY_VERSION="v1_20251020"
export NODE_ID="edge-payment-001"

# Set endpoints
export PAYMENT_PROCESSOR_ENDPOINT="https://payment-api.example.com:8443/transactions"
export ANALYTICS_ENDPOINT="https://analytics-api.example.com:8080/payments"

# Deploy the pipeline
expanso job deploy field-encryption-pipeline.yaml
```

Verify deployment:

```bash title="Verify pipeline deployment"
expanso job status payment-field-encryption
```

Expected output:

```
Job: payment-field-encryption
Status: running
Type: pipeline
Executions:
  - Node: edge-payment-001
    State: running
    Since: 10 seconds ago
    Health: healthy
  - Node: edge-payment-002
    State: running
    Since: 8 seconds ago
    Health: healthy
```

## Step 4: Test Encryption with Sample Data

Send a test payment transaction with sensitive data:

```bash title="Send test payment transaction"
curl -X POST https://localhost:8443/payments/transactions \
  --cacert /etc/expanso/certs/ca.crt \
  --cert /etc/expanso/certs/client.crt \
  --key /etc/expanso/certs/client.key \
  -H "Content-Type: application/json" \
  -d '{
    "transaction_id": "txn_20251020_001",
    "timestamp": "2025-10-20T14:30:00Z",
    "merchant_id": "merchant_789",
    "amount": 127.50,
    "currency": "USD",
    "payment": {
      "card_number": "4532-1234-5678-9010",
      "cvv": "123",
      "expiration": "12/27",
      "cardholder_name": "Sarah Johnson"
    },
    "customer": {
      "email": "sarah.johnson@example.com",
      "phone": "+1-415-555-0123",
      "ssn": "123-45-6789",
      "date_of_birth": "1985-03-15"
    },
    "billing_address": {
      "street": "123 Main St",
      "city": "San Francisco",
      "state": "CA",
      "zip": "94102",
      "country": "US"
    },
    "metadata": {
      "terminal_id": "pos_42",
      "transaction_type": "card_present",
      "merchant_category": "5814"
    }
  }'
```

You should receive `200 OK` response.

## Step 5: Verify Encryption Output

The encrypted transaction sent to your payment processor and analytics systems will look like this:

```json title="Output: Encrypted payment transaction"
{
  "transaction_id": "txn_20251020_001",
  "timestamp": "2025-10-20T14:30:00Z",
  "merchant_id": "merchant_789",
  "amount": 127.50,
  "currency": "USD",

  // Credit card data - ENCRYPTED
  "payment": {
    "card_number_encrypted": "AES256GCM:v1:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=:8f3e2a1b9c4d7e6f",
    "cvv_encrypted": "AES256GCM:v1:cGFzc3dvcmQxMjM0NTY3ODkwYWJjZGVmZ2hp:1a2b3c4d5e6f7g8h",
    "cardholder_name_encrypted": "AES256GCM:v1:bmFtZXN0cmluZ2hlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:9f8e7d6c5b4a3g2h",
    "card_last_four": "9010",
    "card_brand": "visa",
    "expiration": "12/27"
  },

  // PII data - ENCRYPTED
  "customer": {
    "ssn_encrypted": "AES256GCM:v1:c3NuZGF0YWhlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:7e6d5c4b3a2g1h0f",
    "email_encrypted": "AES256GCM:v1:ZW1haWxkYXRhaGVyZWZvcnRlc3Rpbmdwcm9wb3Nlcw==:6d5c4b3a2g1h0f9e",
    "phone_encrypted": "AES256GCM:v1:cGhvbmVkYXRhaGVyZWZvcnRlc3Rpbmdwcm9wb3Nlcw==:5c4b3a2g1h0f9e8d",
    "date_of_birth_encrypted": "AES256GCM:v1:ZG9iZGF0YWhlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:4b3a2g1h0f9e8d7c",
    "ssn_last_four": "6789",
    "email_domain": "example.com",
    "phone_area_code": "415",
    "birth_year": 1985
  },

  // Address data - PARTIALLY ENCRYPTED
  "billing_address": {
    "street_encrypted": "AES256GCM:v1:c3RyZWV0ZGF0YWhlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:3a2g1h0f9e8d7c6b",
    "zip_encrypted": "AES256GCM:v1:emlwZGF0YWhlcmVmb3J0ZXN0aW5ncHVycG9zZXM=:2g1h0f9e8d7c6b5a",
    "city": "San Francisco",
    "state": "CA",
    "country": "US"
  },

  // Non-sensitive metadata - PLAINTEXT
  "metadata": {
    "terminal_id": "pos_42",
    "transaction_type": "card_present",
    "merchant_category": "5814"
  },

  // Encryption tracking metadata
  "encryption_metadata": {
    "encrypted": true,
    "encryption_timestamp": "2025-10-20T14:30:01.234Z",
    "encryption_version": "1.0",
    "key_version": "v1_20251020",
    "algorithm": "AES-256-GCM",
    "node_id": "edge-payment-001",
    "pipeline": "payment-field-encryption",
    "encrypted_fields": [
      "payment.card_number_encrypted",
      "payment.cvv_encrypted",
      "payment.cardholder_name_encrypted",
      "customer.ssn_encrypted",
      "customer.email_encrypted",
      "customer.phone_encrypted",
      "customer.date_of_birth_encrypted",
      "billing_address.street_encrypted",
      "billing_address.zip_encrypted"
    ],
    "plaintext_fields": [
      "transaction_id",
      "timestamp",
      "merchant_id",
      "amount",
      "currency",
      "payment.card_last_four",
      "payment.card_brand",
      "payment.expiration",
      "customer.ssn_last_four",
      "customer.email_domain",
      "customer.phone_area_code",
      "customer.birth_year",
      "billing_address.city",
      "billing_address.state",
      "billing_address.country",
      "metadata"
    ]
  }
}
```

**Encrypted field format:**

Each encrypted field follows this structure:
```
AES256GCM:v1:base64(encrypted_data):base64(authentication_tag)
```

**Components:**
- `AES256GCM` - Encryption algorithm identifier
- `v1` - Key version for rotation tracking
- `base64(encrypted_data)` - Base64-encoded ciphertext
- `base64(authentication_tag)` - GCM authentication tag for integrity verification

**Compare Before and After:**

| Field | Before (Plaintext) | After (Encrypted) | Analytics Utility |
|-------|-------------------|-------------------|------------------|
| `payment.card_number` | "4532-1234-5678-9010" | Encrypted blob + last 4 digits | Last 4 for display |
| `payment.cvv` | "123" | Encrypted blob | None (not needed) |
| `payment.cardholder_name` | "Sarah Johnson" | Encrypted blob | None |
| `customer.ssn` | "123-45-6789" | Encrypted blob + last 4 digits | Last 4 for customer service |
| `customer.email` | "sarah.johnson@example.com" | Encrypted blob + domain | Domain for org analysis |
| `customer.phone` | "+1-415-555-0123" | Encrypted blob + area code | Area code for regional trends |
| `billing_address.street` | "123 Main St" | Encrypted blob | None |
| `billing_address.zip` | "94102" | Encrypted blob | None |

**What's Preserved for Analytics:**

‚úÖ Transaction IDs (needed for queries and joins)
‚úÖ Timestamps (time-series analysis)
‚úÖ Merchant IDs (merchant reporting)
‚úÖ Amounts and currency (financial analytics)
‚úÖ Card last 4 digits (customer service)
‚úÖ Card brand (fraud detection patterns)
‚úÖ Email domain (organizational analysis)
‚úÖ Phone area code (regional analytics)
‚úÖ Birth year (age cohort analysis)
‚úÖ City, state, country (geographic trends)
‚úÖ All business metadata (terminal ID, transaction type)

**What's Encrypted (Protected):**

‚ùå Full credit card numbers
‚ùå CVV codes
‚ùå Cardholder names
‚ùå Social security numbers
‚ùå Email addresses
‚ùå Phone numbers
‚ùå Dates of birth
‚ùå Street addresses
‚ùå Detailed zip codes

## See Also

**Related How-To Guides:**
- [Field-Level Encryption Patterns](/examples/data-security/encryption-patterns) - Reusable encryption patterns reference
- [How to Remove PII from Data Streams](/examples/data-security/remove-pii) - Hash and anonymize PII (alternative to encryption)
- [How to Enforce Data Schema Validation](/examples/data-security/enforce-schema) - Validate encrypted data structure

**Reference Documentation:**
- [Mapping Processor Reference](https://docs.expanso.io/components/processors/mapping) - Bloblang mapping syntax
- [Bloblang Guide](https://docs.expanso.io/guides/bloblang) - Transformation language reference
