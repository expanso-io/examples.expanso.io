---
title: "Step 2: Encrypt PII Fields"
sidebar_label: "Step 2: PII Encryption"
sidebar_position: 5
description: Encrypt personal identifiers (email, phone, SSN) for GDPR/CCPA compliance while preserving analytics metadata
keywords: [encryption, pii, gdpr, ccpa, personal-data, compliance]
---

# Step 2: Encrypt PII Fields

Learn to implement **GDPR and CCPA compliant personal data encryption** that protects customer privacy while preserving essential analytics capabilities. This step covers email addresses, phone numbers, and Social Security Numbers.

## Understanding PII Encryption Requirements

Personal Identifiable Information (PII) requires careful encryption strategies that balance privacy compliance with business operations:

- **GDPR Compliance**: Right to be forgotten, data minimization, consent management
- **CCPA Compliance**: Consumer privacy rights, opt-out capabilities
- **Business Analytics**: Demographic trends, regional patterns, customer segmentation
- **Customer Service**: Account lookup, identity verification, support operations

## What We'll Encrypt vs Preserve

**Fields to Encrypt (Privacy Requirements):**
- ❌ Full email address (personal identifier under GDPR)
- ❌ Complete phone number (PII in most jurisdictions) 
- ❌ Social Security Number (high-risk PII requiring encryption)

**Fields to Preserve (Business Analytics):**
- ✅ Email domain (company affiliations, B2B vs B2C segmentation)
- ✅ Phone area code (regional demographics without personal identification)
- ✅ SSN last 4 (customer service account verification)
- ✅ Country codes (international customer analytics)

## Input Data Structure

Here's the customer PII data we'll be encrypting:

```json title="Sample customer PII data"
{
  "customer": {
    "customer_id": "cust-789",           // ✅ Business identifier  
    "first_name": "Sarah",              // ❌ PII - encrypt
    "last_name": "Johnson",             // ❌ PII - encrypt
    "email": "sarah.johnson@example.com", // ❌ PII - encrypt
    "phone": "+1-415-555-0123",         // ❌ PII - encrypt
    "ssn": "123-45-6789",               // ❌ High-risk PII - encrypt
    "date_of_birth": "1985-03-15"       // ❌ Temporal PII (next step)
  }
}
```

## Step 2.1: Email Address Encryption

Encrypt email addresses while preserving domain information for B2B analytics.

```yaml title="Email encryption processor"
pipeline:
  processors:
    # Encrypt email addresses with domain preservation
    - mapping: |
        root = this
        
        # Extract and preserve email domain before encryption
        root.customer.email_domain = if this.customer.email.exists() {
          let email = this.customer.email.lowercase()
          
          # Validate email format first
          if email.re_match("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$") {
            email.split("@").index(1)
          } else {
            null  # Invalid email format
          }
        }
        
        # Extract company type for B2B analytics (common business domains)
        root.customer.email_domain_type = if root.customer.email_domain.exists() {
          let domain = root.customer.email_domain
          
          match {
            # Free email providers (B2C)
            domain.re_match("(gmail|yahoo|hotmail|outlook|aol|icloud|proton)\\..*") => "consumer"
            
            # Common business domains  
            domain.re_match("(company|corp|inc|llc|ltd|org|edu|gov)\\..*") => "business"
            domain.re_match(".*\\.(com|org|net|edu|gov|mil)$") => "business"
            
            # International domains
            domain.re_match(".*\\.(co\\.uk|de|fr|jp|au|ca)$") => "international"
            
            _ => "other"
          }
        }
        
        # Encrypt full email address
        root.customer.email_encrypted = if this.customer.email.exists() {
          this.customer.email.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
        }
        
        # Remove plaintext email
        root.customer.email = deleted()
```

## Step 2.2: Phone Number Encryption

Encrypt phone numbers while preserving area codes and country codes for regional analytics.

```yaml title="Phone number encryption processor"
    # Encrypt phone numbers with regional preservation
    - mapping: |
        root = this
        
        # Normalize and parse phone number
        let phone_normalized = if this.customer.phone.exists() {
          this.customer.phone.re_replace_all("[^0-9+]", "")
        }
        
        # Extract country code
        root.customer.phone_country_code = if phone_normalized.exists() &&
                                             phone_normalized.has_prefix("+") {
          match {
            phone_normalized.has_prefix("+1") => "+1"      # US/Canada
            phone_normalized.has_prefix("+44") => "+44"    # UK
            phone_normalized.has_prefix("+49") => "+49"    # Germany
            phone_normalized.has_prefix("+33") => "+33"    # France
            phone_normalized.has_prefix("+81") => "+81"    # Japan
            phone_normalized.has_prefix("+86") => "+86"    # China
            phone_normalized.has_prefix("+91") => "+91"    # India
            _ => "international"
          }
        }
        
        # Extract area code (US/Canada format)
        root.customer.phone_area_code = if phone_normalized.exists() {
          # For US/Canada (+1), extract 3-digit area code
          if phone_normalized.has_prefix("+1") && phone_normalized.length() == 12 {
            phone_normalized.slice(2, 5)  # Skip +1, take next 3 digits
          }
          # For other 10-digit numbers without country code  
          else if phone_normalized.length() == 10 {
            phone_normalized.slice(0, 3)
          }
          else {
            null  # International or non-standard format
          }
        }
        
        # Determine phone type for analytics
        root.customer.phone_type = if root.customer.phone_area_code.exists() {
          let area_code = root.customer.phone_area_code
          
          match {
            # Mobile prefixes (US examples)
            area_code.re_match("(917|646|347|929|718|212)") => "mobile_likely"
            
            # Toll-free numbers
            area_code.re_match("(800|888|877|866|855|844|833|822)") => "toll_free"
            
            # Standard area codes
            _ => "standard"
          }
        }
        
        # Encrypt full phone number
        root.customer.phone_encrypted = if this.customer.phone.exists() {
          this.customer.phone.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
        }
        
        # Remove plaintext phone
        root.customer.phone = deleted()
```

## Step 2.3: Social Security Number Encryption

Encrypt SSN while preserving last 4 digits for customer service verification.

```yaml title="SSN encryption processor"
    # Encrypt SSN with last 4 preservation
    - mapping: |
        root = this
        
        # Normalize SSN format
        let ssn_normalized = if this.customer.ssn.exists() {
          this.customer.ssn.re_replace_all("[^0-9]", "")
        }
        
        # Validate SSN format (9 digits)
        root.customer.ssn_valid = if ssn_normalized.exists() {
          ssn_normalized.length() == 9 && 
          ssn_normalized != "000000000" &&     # Invalid SSN
          ssn_normalized != "123456789" &&     # Test SSN
          !ssn_normalized.has_prefix("666") && # Reserved range
          !ssn_normalized.has_prefix("900")    # Reserved range
        }
        
        # Extract last 4 digits for customer service (common practice)
        root.customer.ssn_last_four = if ssn_normalized.exists() && 
                                        root.customer.ssn_valid == true {
          ssn_normalized.slice(-4)
        }
        
        # Extract state/region from area number (first 3 digits)
        root.customer.ssn_state_region = if ssn_normalized.exists() &&
                                           root.customer.ssn_valid == true {
          let area_number = ssn_normalized.slice(0, 3).number()
          
          match {
            # Geographic regions (pre-2011 issuance)
            area_number >= 1 && area_number <= 3 => "northeast"
            area_number >= 4 && area_number <= 7 => "northeast"  
            area_number >= 8 && area_number <= 9 => "northeast"
            area_number >= 50 && area_number <= 134 => "northeast"
            area_number >= 135 && area_number <= 158 => "northeast"
            area_number >= 159 && area_number <= 211 => "northeast"
            area_number >= 212 && area_number <= 220 => "northeast"
            area_number >= 221 && area_number <= 222 => "southeast"
            area_number >= 232 && area_number <= 236 => "southeast"
            area_number >= 237 && area_number <= 246 => "southeast"
            area_number >= 247 && area_number <= 251 => "southeast"
            area_number >= 654 && area_number <= 658 => "southeast"
            _ => "randomized"  # Post-2011 randomized issuance
          }
        }
        
        # Encrypt full SSN
        root.customer.ssn_encrypted = if this.customer.ssn.exists() &&
                                        root.customer.ssn_valid == true {
          this.customer.ssn.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
        }
        
        # Remove plaintext SSN
        root.customer.ssn = deleted()
```

## Step 2.4: Name Encryption

Encrypt first and last names while preserving length information for form validation.

```yaml title="Name encryption processor"
    # Encrypt customer names
    - mapping: |
        root = this
        
        # Preserve name lengths for form validation and UX
        root.customer.first_name_length = if this.customer.first_name.exists() {
          this.customer.first_name.length()
        }
        
        root.customer.last_name_length = if this.customer.last_name.exists() {
          this.customer.last_name.length()
        }
        
        # Extract name characteristics for analytics (optional)
        root.customer.name_characteristics = {
          "has_middle_initial": if this.customer.first_name.exists() {
            this.customer.first_name.contains(" ")
          },
          "last_name_common": if this.customer.last_name.exists() {
            # Check against common surnames for demographic analysis
            let surname = this.customer.last_name.lowercase()
            surname.re_match("(smith|johnson|williams|brown|jones|garcia|miller|davis|rodriguez|martinez|hernandez|lopez|gonzalez|wilson|anderson|taylor|thomas|jackson|white|harris|martin|thompson|moore|young|allen)")
          },
          "name_complexity": if this.customer.first_name.exists() && this.customer.last_name.exists() {
            (this.customer.first_name.length() + this.customer.last_name.length()) / 2
          }
        }
        
        # Encrypt first name
        root.customer.first_name_encrypted = if this.customer.first_name.exists() {
          this.customer.first_name.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
        }
        
        # Encrypt last name  
        root.customer.last_name_encrypted = if this.customer.last_name.exists() {
          this.customer.last_name.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
        }
        
        # Remove plaintext names
        root.customer = this.customer.without("first_name", "last_name")
```

## Step 2.5: PII Encryption Metadata

Add comprehensive metadata for GDPR/CCPA compliance auditing.

```yaml title="PII encryption metadata processor"
    # Add PII-specific encryption metadata
    - mapping: |
        root = this
        
        # PII encryption audit metadata
        root.pii_encryption_metadata = {
          "encrypted": true,
          "encryption_timestamp": now(),
          "key_version": env("KEY_VERSION").or("unknown"),
          "algorithm": "AES-256-GCM",
          "node_id": env("NODE_ID").or("unknown"),
          "compliance_standards": ["GDPR", "CCPA", "PII-Protection"],
          
          # Track PII fields encrypted
          "pii_fields_encrypted": [
            if this.customer.email_encrypted.exists() { "customer.email" },
            if this.customer.phone_encrypted.exists() { "customer.phone" },
            if this.customer.ssn_encrypted.exists() { "customer.ssn" },
            if this.customer.first_name_encrypted.exists() { "customer.first_name" },
            if this.customer.last_name_encrypted.exists() { "customer.last_name" }
          ].filter(v -> v != null),
          
          # Track analytics data preserved
          "analytics_preserved": [
            if this.customer.email_domain.exists() { "customer.email_domain" },
            if this.customer.phone_area_code.exists() { "customer.phone_area_code" },
            if this.customer.phone_country_code.exists() { "customer.phone_country_code" },
            if this.customer.ssn_last_four.exists() { "customer.ssn_last_four" },
            if this.customer.ssn_state_region.exists() { "customer.ssn_state_region" }
          ].filter(v -> v != null),
          
          # GDPR Article 30 record keeping
          "gdpr_processing_record": {
            "lawful_basis": "legitimate_interest",  # or "consent", "contract", etc.
            "purpose": "customer_service_and_analytics",
            "data_categories": ["contact_information", "identification_numbers"],
            "retention_period": "7_years_or_until_deletion_request",
            "encryption_strength": "AES-256-GCM"
          }
        }
```

## Complete PII Encryption Pipeline

Here's the complete pipeline combining all PII encryption steps:

```yaml title="step-2-pii-encryption.yaml"
input:
  file:
    paths: 
      - "./step-1-output.jsonl"  # Use payment-encrypted data from step 1
    codec: "lines"

pipeline:
  processors:
    # Step 2.1: Email encryption with domain preservation
    - mapping: |
        root = this
        
        root.customer.email_domain = if this.customer.email.exists() {
          let email = this.customer.email.lowercase()
          if email.re_match("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$") {
            email.split("@").index(1)
          }
        }
        
        root.customer.email_domain_type = if root.customer.email_domain.exists() {
          let domain = root.customer.email_domain
          match {
            domain.re_match("(gmail|yahoo|hotmail|outlook|aol|icloud)\\..*") => "consumer"
            domain.re_match("(company|corp|inc|llc|ltd|org|edu|gov)\\..*") => "business"
            _ => "other"
          }
        }
        
        root.customer.email_encrypted = if this.customer.email.exists() {
          this.customer.email.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
        }
        
        root.customer.email = deleted()

    # Step 2.2: Phone encryption with regional preservation
    - mapping: |
        root = this
        
        let phone_normalized = if this.customer.phone.exists() {
          this.customer.phone.re_replace_all("[^0-9+]", "")
        }
        
        root.customer.phone_country_code = if phone_normalized.exists() &&
                                             phone_normalized.has_prefix("+") {
          match {
            phone_normalized.has_prefix("+1") => "+1"
            phone_normalized.has_prefix("+44") => "+44"  
            phone_normalized.has_prefix("+49") => "+49"
            _ => "international"
          }
        }
        
        root.customer.phone_area_code = if phone_normalized.exists() {
          if phone_normalized.has_prefix("+1") && phone_normalized.length() == 12 {
            phone_normalized.slice(2, 5)
          } else if phone_normalized.length() == 10 {
            phone_normalized.slice(0, 3)
          }
        }
        
        root.customer.phone_encrypted = if this.customer.phone.exists() {
          this.customer.phone.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
        }
        
        root.customer.phone = deleted()

    # Step 2.3: SSN encryption with last 4 preservation
    - mapping: |
        root = this
        
        let ssn_normalized = if this.customer.ssn.exists() {
          this.customer.ssn.re_replace_all("[^0-9]", "")
        }
        
        root.customer.ssn_valid = if ssn_normalized.exists() {
          ssn_normalized.length() == 9 && 
          ssn_normalized != "000000000" &&
          !ssn_normalized.has_prefix("666")
        }
        
        root.customer.ssn_last_four = if ssn_normalized.exists() && 
                                        root.customer.ssn_valid == true {
          ssn_normalized.slice(-4)
        }
        
        root.customer.ssn_encrypted = if this.customer.ssn.exists() &&
                                        root.customer.ssn_valid == true {
          this.customer.ssn.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
        }
        
        root.customer.ssn = deleted()

    # Step 2.4: Name encryption
    - mapping: |
        root = this
        
        root.customer.first_name_encrypted = if this.customer.first_name.exists() {
          this.customer.first_name.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
        }
        
        root.customer.last_name_encrypted = if this.customer.last_name.exists() {
          this.customer.last_name.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
        }
        
        root.customer = this.customer.without("first_name", "last_name")

    # Step 2.5: PII encryption metadata
    - mapping: |
        root = this
        
        root.pii_encryption_metadata = {
          "encrypted": true,
          "encryption_timestamp": now(),
          "key_version": env("KEY_VERSION").or("unknown"),
          "algorithm": "AES-256-GCM",
          "compliance_standards": ["GDPR", "CCPA", "PII-Protection"],
          "pii_fields_encrypted": [
            "customer.email", "customer.phone", "customer.ssn",
            "customer.first_name", "customer.last_name"
          ],
          "analytics_preserved": [
            "customer.email_domain", "customer.phone_area_code", 
            "customer.ssn_last_four"
          ]
        }

output:
  file:
    path: "./step-2-output.jsonl"
    codec: "lines"

logger:
  level: "INFO"
  add_timestamp: true
```

## Testing PII Encryption

Deploy and test the PII encryption pipeline:

```bash
# Deploy the PII encryption pipeline  
expanso job deploy step-2-pii-encryption.yaml

# Verify deployment
expanso job status step-2-pii-encryption

# Wait for processing
sleep 3

# Check the encrypted output
echo "PII encryption results:"
cat step-2-output.jsonl | jq '.customer'
```

**Expected output structure:**
```json
{
  "customer": {
    "customer_id": "cust-789",
    "email_encrypted": "AES256GCM:v1:ZW1haWxkYXRh:8f7e6d5c4b3a2g1h0f9e8d7c6b5a4g3f",
    "email_domain": "example.com",
    "email_domain_type": "business",
    "phone_encrypted": "AES256GCM:v1:cGhvbmVkYXRh:7e6d5c4b3a2g1h0f9e8d7c6b5a4g3f2e",
    "phone_country_code": "+1",
    "phone_area_code": "415",
    "ssn_encrypted": "AES256GCM:v1:c3NuZGF0YQ==:6d5c4b3a2g1h0f9e8d7c6b5a4g3f2e1d",
    "ssn_last_four": "6789",
    "ssn_valid": true,
    "first_name_encrypted": "AES256GCM:v1:Zmlyc3ROYW1l:5c4b3a2g1h0f9e8d7c6b5a4g3f2e1d0c",
    "last_name_encrypted": "AES256GCM:v1:bGFzdE5hbWU=:4b3a2g1h0f9e8d7c6b5a4g3f2e1d0c9b",
    "date_of_birth": "1985-03-15"  // Will be encrypted in Step 4
  }
}
```

## Validation and Compliance Testing

### Verify GDPR Compliance

```bash
# Check that all PII fields are encrypted
echo "GDPR Compliance Check..."

# Verify no plaintext email addresses
if cat step-2-output.jsonl | jq -r '.customer.email // empty' | grep -q "@"; then
    echo "❌ Plaintext email found - GDPR violation!"
else
    echo "✅ Email addresses encrypted"
fi

# Verify no plaintext phone numbers  
if cat step-2-output.jsonl | jq -r '.customer.phone // empty' | grep -q "415"; then
    echo "❌ Plaintext phone found - privacy violation!"
else
    echo "✅ Phone numbers encrypted"
fi

# Verify no plaintext SSN
if cat step-2-output.jsonl | jq -r '.customer.ssn // empty' | grep -q "123-45"; then
    echo "❌ Plaintext SSN found - critical violation!"
else
    echo "✅ SSN encrypted"
fi

# Verify preserved analytics data exists
if cat step-2-output.jsonl | jq -r '.customer.email_domain' | grep -q "example.com"; then
    echo "✅ Email domain preserved for analytics"
fi

if cat step-2-output.jsonl | jq -r '.customer.phone_area_code' | grep -q "415"; then
    echo "✅ Area code preserved for regional analytics"
fi
```

### Test Right to Be Forgotten (GDPR Article 17)

```yaml title="GDPR deletion compliance test"
# Create deletion pipeline for GDPR compliance
cat > test-gdpr-deletion.yaml << 'EOF'
input:
  file:
    paths: 
      - "./step-2-output.jsonl"
    codec: "lines"

pipeline:
  processors:
    # Simulate GDPR deletion request
    - mapping: |
        root = this
        
        # Check if customer requested deletion (would come from deletion service)
        let deletion_requested = env("CUSTOMER_DELETE_REQUEST") == this.customer.customer_id
        
        # If deletion requested, remove all PII fields
        root.customer = if deletion_requested {
          this.customer.without(
            "email_encrypted", "phone_encrypted", "ssn_encrypted",
            "first_name_encrypted", "last_name_encrypted", "ssn_last_four"
          ).
          # Keep only non-personal analytics data
          merge({
            "deletion_timestamp": now(),
            "gdpr_deleted": true,
            "analytics_retained": {
              "email_domain": this.customer.email_domain,
              "phone_area_code": this.customer.phone_area_code,
              "email_domain_type": this.customer.email_domain_type
            }
          })
        } else {
          this.customer
        }

output:
  file:
    path: "./gdpr-deletion-test.jsonl"
    codec: "lines"
EOF

# Test GDPR deletion
export CUSTOMER_DELETE_REQUEST="cust-789"
expanso job deploy test-gdpr-deletion.yaml

sleep 3

# Verify deletion worked
echo "GDPR deletion test:"
cat gdpr-deletion-test.jsonl | jq '.customer'
```

## Common Variations

### Variation 1: Consent-Based Processing

Track and enforce consent for GDPR compliance:

```yaml title="Consent-based encryption"
# Only encrypt if customer has given consent
root.customer.email_encrypted = if this.customer.email.exists() &&
                                   this.customer.consent.email_processing == true {
  this.customer.email.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
}

# Track consent metadata
root.consent_metadata = {
  "consent_given": this.customer.consent.email_processing,
  "consent_timestamp": this.customer.consent.timestamp,
  "consent_version": "v2.1"
}
```

### Variation 2: International Phone Numbers

Handle international phone number formats:

```yaml title="International phone support"
# Extended international phone support
root.customer.phone_country_code = if phone_normalized.exists() {
  match {
    phone_normalized.has_prefix("+1") => "+1"    # US/Canada
    phone_normalized.has_prefix("+44") => "+44"  # UK
    phone_normalized.has_prefix("+33") => "+33"  # France
    phone_normalized.has_prefix("+49") => "+49"  # Germany
    phone_normalized.has_prefix("+81") => "+81"  # Japan
    phone_normalized.has_prefix("+86") => "+86"  # China
    phone_normalized.has_prefix("+91") => "+91"  # India
    phone_normalized.has_prefix("+61") => "+61"  # Australia
    phone_normalized.has_prefix("+55") => "+55"  # Brazil
    _ => "other_international"
  }
}
```

### Variation 3: Email Categorization

Enhanced email domain classification:

```yaml title="Advanced email categorization"
root.customer.email_organization_size = if root.customer.email_domain.exists() {
  let domain = root.customer.email_domain
  
  match {
    # Fortune 500 companies (examples)
    domain.re_match("(google|microsoft|amazon|apple|facebook)\\.com") => "enterprise"
    
    # Educational institutions
    domain.re_match(".*\\.edu") => "education"
    
    # Government
    domain.re_match(".*\\.gov") => "government"
    
    # Non-profit
    domain.re_match(".*\\.org") => "nonprofit"
    
    # Consumer email
    domain.re_match("(gmail|yahoo|hotmail|outlook|aol)\\..*") => "consumer"
    
    _ => "business"
  }
}
```

## GDPR & CCPA Compliance Notes

### Required Privacy Controls

✅ **Data Minimization**: Only encrypt necessary PII, preserve analytics-safe metadata
✅ **Purpose Limitation**: Clearly document why each field is preserved vs encrypted
✅ **Consent Management**: Track consent for each processing purpose  
✅ **Right to Access**: Maintain ability to decrypt for data subject access requests
✅ **Right to Deletion**: Support complete PII removal while retaining analytics data
✅ **Data Protection Impact Assessment**: Document encryption decisions and trade-offs

### Production Privacy Requirements

For GDPR/CCPA compliance in production:

1. **Consent Management**: Integrate with consent management platform
2. **Data Subject Rights**: Automated systems for access, rectification, deletion
3. **Cross-Border Data Transfer**: Ensure encryption meets adequacy requirements
4. **Breach Notification**: Encrypted data reduces breach severity and reporting requirements
5. **Privacy by Design**: Document how encryption supports privacy-first architecture

## Troubleshooting

### Issue: "Email domain not extracted"

**Cause**: Invalid email format or special characters.

**Solution**: Add robust email validation:
```yaml
# Validate email before processing
let email_valid = this.customer.email.re_match("^[\\w\\._%+-]+@[\\w\\.-]+\\.[A-Za-z]{2,}$")
root.customer.email_domain = if email_valid {
  this.customer.email.split("@").index(1).lowercase()
}
```

### Issue: "Phone area code extraction failed"

**Cause**: International number or non-standard format.

**Solution**: Add format detection:
```yaml
# Handle various phone formats
let phone_digits = this.customer.phone.re_replace_all("[^0-9]", "")
root.customer.phone_area_code = match {
  phone_digits.length() == 10 => phone_digits.slice(0, 3)    # US without +1
  phone_digits.length() == 11 => phone_digits.slice(1, 4)    # US with +1
  _ => null  # International or invalid
}
```

### Issue: "SSN validation failed"

**Cause**: Invalid SSN format or reserved number range.

**Solution**: Enhanced SSN validation:
```yaml
root.customer.ssn_validation_error = if ssn_normalized.exists() {
  match {
    ssn_normalized.length() != 9 => "Invalid length"
    ssn_normalized == "000000000" => "Invalid SSN (all zeros)"
    ssn_normalized.has_prefix("666") => "Invalid SSN (666 prefix)"
    ssn_normalized.has_prefix("900") => "Invalid SSN (900+ prefix)"
    _ => null  # Valid
  }
}
```

## What's Next

You've successfully implemented comprehensive PII encryption with privacy compliance! Customer personal data is now protected while preserving essential business analytics capabilities.

**Key accomplishments:**
- ✅ Email addresses encrypted with domain preservation for B2B analytics
- ✅ Phone numbers encrypted with area code preservation for regional insights
- ✅ SSN encrypted with last-4 preservation for customer service
- ✅ Names encrypted with length preservation for form validation
- ✅ GDPR/CCPA compliance metadata for audit trails
- ✅ Analytics-safe data preserved for business intelligence

**Next step:** [Step 3: Encrypt Addresses](./step-3-encrypt-addresses) - Implement location privacy while preserving demographic analytics through geographic aggregation.

---

**Compliance note:** Always consult with legal and privacy teams to ensure your encryption approach meets specific regulatory requirements for your jurisdiction and industry.
