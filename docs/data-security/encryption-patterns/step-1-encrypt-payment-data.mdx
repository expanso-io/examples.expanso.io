---
title: "Step 1: Encrypt Payment Data"
sidebar_label: "Step 1: Payment Encryption"
sidebar_position: 4
description: Implement PCI-DSS compliant credit card encryption with last-4 preservation and brand detection
keywords: [encryption, payment, credit-card, pci-dss, compliance, aes]
---

# Step 1: Encrypt Payment Data

Learn to implement **PCI-DSS compliant credit card encryption** that protects sensitive payment data while preserving essential fields for customer service and analytics. This step focuses on the highest-risk data in your pipeline.

## Understanding Payment Data Encryption

Payment card data is the most regulated sensitive data, requiring **PCI-DSS 3.2.1 compliance**. The challenge is encrypting cardholder data while maintaining operational capabilities:

- **Customer Service**: Needs last 4 digits for payment method identification
- **Fraud Detection**: Needs card brand and issuer information for risk scoring  
- **Analytics**: Needs transaction patterns without exposing card numbers
- **Compliance**: Requires strong encryption with proper key management

## What We'll Encrypt vs Preserve

**Fields to Encrypt (PCI-DSS Requirements):**
- ❌ Full credit card number (Primary Account Number - PAN)
- ❌ CVV/CVC security code (never store, encrypt in transit only)
- ❌ Cardholder name (PII associated with payment method)

**Fields to Preserve (Business Requirements):**
- ✅ Last 4 digits (masked PAN, allowed by PCI-DSS)
- ✅ Card brand (Visa, MasterCard, etc. - not sensitive)
- ✅ Expiry month/year (not considered sensitive data)
- ✅ Transaction amount, currency, timestamp (operational data)

## Input Data Structure

Here's the payment data structure we'll be encrypting:

```json title="Sample payment transaction"
{
  "transaction_id": "txn-12345",
  "timestamp": "2025-01-15T10:00:00Z",
  "amount": 49.99,
  "currency": "USD",
  "payment": {
    "card_number": "4532123456789010",      // ❌ Full PAN - encrypt
    "cvv": "123",                           // ❌ Security code - encrypt  
    "expiry_month": 12,                     // ✅ Safe for analytics
    "expiry_year": 2028,                    // ✅ Safe for analytics
    "cardholder_name": "Sarah Johnson",     // ❌ PII - encrypt
    "card_brand": "visa"                    // ✅ Safe for analytics
  }
}
```

## Step 1.1: Detect Card Brand

First, implement card brand detection before encryption. This preserves fraud detection capabilities.

```yaml title="Brand detection processor"
pipeline:
  processors:
    # Detect and preserve card brand before encryption
    - mapping: |
        root = this
        
        # Enhanced card brand detection with validation
        root.payment.card_brand_detected = if this.payment.card_number.exists() {
          let card_num = this.payment.card_number.re_replace_all("[^0-9]", "")
          
          match {
            # Visa: starts with 4, 13-19 digits
            card_num.re_match("^4[0-9]{12,18}$") => "visa"
            
            # Mastercard: 5.1-5.5, 2221-2720, 16 digits
            card_num.re_match("^5[1-5][0-9]{14}$") => "mastercard"
            card_num.re_match("^2[2-7][0-9]{14}$") => "mastercard"
            
            # American Express: 34xx or 37xx, 15 digits
            card_num.re_match("^3[47][0-9]{13}$") => "american_express"
            
            # Discover: 6011, 644-649, 65, 622126-622925, 16-19 digits
            card_num.re_match("^6011[0-9]{12}$") => "discover"
            card_num.re_match("^64[4-9][0-9]{13}$") => "discover"
            card_num.re_match("^65[0-9]{14}$") => "discover"
            card_num.re_match("^622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[01][0-9]|92[0-5])[0-9]{10}$") => "discover"
            
            # Diners Club: 300-305, 36xx, 38xx, 14 digits
            card_num.re_match("^30[0-5][0-9]{11}$") => "diners"
            card_num.re_match("^36[0-9]{12}$") => "diners"
            card_num.re_match("^38[0-9]{12}$") => "diners"
            
            # JCB: 35xx, 2131, 1800, 14-19 digits
            card_num.re_match("^35[0-9]{14}$") => "jcb"
            card_num.re_match("^2131[0-9]{11}$") => "jcb"
            card_num.re_match("^1800[0-9]{11}$") => "jcb"
            
            _ => "unknown"
          }
        } else { null }
        
        # Preserve existing brand if already detected
        root.payment.card_brand = if this.payment.card_brand.exists() {
          this.payment.card_brand
        } else {
          root.payment.card_brand_detected
        }
```

## Step 1.2: Extract Last 4 Digits

Extract the last 4 digits before encryption for customer service operations.

```yaml title="Last 4 extraction processor"
    # Extract last 4 digits before encryption
    - mapping: |
        root = this
        
        # Extract last 4 digits (PCI-DSS allows first 6 and last 4)
        root.payment.card_last_four = if this.payment.card_number.exists() {
          let card_num = this.payment.card_number.re_replace_all("[^0-9]", "")
          
          # Validate minimum length before extracting
          if card_num.length() >= 8 {
            card_num.slice(-4)
          } else {
            null  # Don't extract from invalid card numbers
          }
        }
        
        # Extract first 6 digits (Bank Identification Number - BIN)
        root.payment.card_bin = if this.payment.card_number.exists() {
          let card_num = this.payment.card_number.re_replace_all("[^0-9]", "")
          
          # BIN helps with fraud detection and routing
          if card_num.length() >= 8 {
            card_num.slice(0, 6)
          } else {
            null
          }
        }
        
        # Validate card number format before encryption
        root.payment.card_validation = if this.payment.card_number.exists() {
          let card_num = this.payment.card_number.re_replace_all("[^0-9]", "")
          
          {
            "length_valid": card_num.length() >= 13 && card_num.length() <= 19,
            "luhn_valid": this.luhn_validate_card(card_num),
            "brand_matches": root.payment.card_brand != "unknown"
          }
        }

# Custom Luhn algorithm validation function
luhn_validate_card: |
  let digits = this.split("").map_each(char -> char.number())
  let sum = 0
  let alternate = false
  
  # Process digits from right to left
  range(digits.length() - 1, -1, -1).fold(sum, index -> {
    let digit = digits.index(index)
    let doubled = if alternate { digit * 2 } else { digit }
    let final_digit = if doubled > 9 { doubled - 9 } else { doubled }
    
    # Update for next iteration
    alternate = !alternate
    
    sum + final_digit
  }) % 10 == 0
```

## Step 1.3: Encrypt Sensitive Payment Fields  

Now encrypt the sensitive payment data using AES-256-GCM with the payment encryption key.

```yaml title="Payment field encryption processor"
    # Encrypt sensitive payment fields
    - mapping: |
        root = this
        
        # Encrypt full credit card number
        root.payment.card_number_encrypted = if this.payment.card_number.exists() &&
                                               this.payment.card_validation.length_valid == true {
          this.payment.card_number.encrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
        }
        
        # Encrypt CVV (critical - never store unencrypted)
        root.payment.cvv_encrypted = if this.payment.cvv.exists() {
          this.payment.cvv.encrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
        }
        
        # Encrypt cardholder name (PII associated with payment)
        root.payment.cardholder_name_encrypted = if this.payment.cardholder_name.exists() {
          this.payment.cardholder_name.encrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
        }
        
        # Remove plaintext sensitive fields
        root.payment = this.payment.without(
          "card_number",
          "cvv", 
          "cardholder_name",
          "card_brand_detected",  # Clean up temporary field
          "card_validation"       # Remove validation metadata
        )
```

## Step 1.4: Add Payment Encryption Metadata

Add comprehensive metadata for audit trails and operational monitoring.

```yaml title="Payment encryption metadata processor"
    # Add payment-specific encryption metadata  
    - mapping: |
        root = this
        
        # Payment encryption audit metadata
        root.payment_encryption_metadata = {
          "encrypted": true,
          "encryption_timestamp": now(),
          "key_version": env("KEY_VERSION").or("unknown"),
          "algorithm": "AES-256-GCM",
          "node_id": env("NODE_ID").or("unknown"),
          "compliance_standard": "PCI-DSS-3.2.1",
          
          # Track what was encrypted for audit
          "encrypted_fields": [
            if this.payment.card_number_encrypted.exists() { "payment.card_number" },
            if this.payment.cvv_encrypted.exists() { "payment.cvv" },
            if this.payment.cardholder_name_encrypted.exists() { "payment.cardholder_name" }
          ].filter(v -> v != null),
          
          # Track what was preserved for business operations
          "preserved_fields": [
            if this.payment.card_last_four.exists() { "payment.card_last_four" },
            if this.payment.card_bin.exists() { "payment.card_bin" },
            if this.payment.card_brand.exists() { "payment.card_brand" },
            "payment.expiry_month",
            "payment.expiry_year"
          ],
          
          # Card validation results for monitoring
          "card_validation_passed": this.payment.card_validation.length_valid == true &&
                                  this.payment.card_validation.luhn_valid == true &&
                                  this.payment.card_validation.brand_matches == true
        }
```

## Complete Payment Encryption Pipeline

Here's the complete pipeline for this step:

```yaml title="step-1-payment-encryption.yaml"
input:
  file:
    paths: 
      - "./sample-data.json"
    codec: "auto"

pipeline:
  processors:
    # Step 1.1: Detect card brand before encryption
    - mapping: |
        root = this
        
        root.payment.card_brand_detected = if this.payment.card_number.exists() {
          let card_num = this.payment.card_number.re_replace_all("[^0-9]", "")
          
          match {
            card_num.re_match("^4[0-9]{12,18}$") => "visa"
            card_num.re_match("^5[1-5][0-9]{14}$") => "mastercard"
            card_num.re_match("^2[2-7][0-9]{14}$") => "mastercard"
            card_num.re_match("^3[47][0-9]{13}$") => "american_express"
            card_num.re_match("^6011[0-9]{12}$") => "discover"
            card_num.re_match("^64[4-9][0-9]{13}$") => "discover"
            card_num.re_match("^65[0-9]{14}$") => "discover"
            card_num.re_match("^30[0-5][0-9]{11}$") => "diners"
            card_num.re_match("^36[0-9]{12}$") => "diners"
            card_num.re_match("^38[0-9]{12}$") => "diners"
            card_num.re_match("^35[0-9]{14}$") => "jcb"
            card_num.re_match("^2131[0-9]{11}$") => "jcb"
            card_num.re_match("^1800[0-9]{11}$") => "jcb"
            _ => "unknown"
          }
        } else { null }
        
        root.payment.card_brand = this.payment.card_brand.or(root.payment.card_brand_detected)

    # Step 1.2: Extract last 4 and BIN before encryption
    - mapping: |
        root = this
        
        let card_num = this.payment.card_number.re_replace_all("[^0-9]", "")
        
        root.payment.card_last_four = if this.payment.card_number.exists() && card_num.length() >= 8 {
          card_num.slice(-4)
        }
        
        root.payment.card_bin = if this.payment.card_number.exists() && card_num.length() >= 8 {
          card_num.slice(0, 6)  
        }

    # Step 1.3: Encrypt sensitive payment fields
    - mapping: |
        root = this
        
        # Encrypt full credit card number
        root.payment.card_number_encrypted = if this.payment.card_number.exists() {
          this.payment.card_number.encrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
        }
        
        # Encrypt CVV
        root.payment.cvv_encrypted = if this.payment.cvv.exists() {
          this.payment.cvv.encrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
        }
        
        # Encrypt cardholder name
        root.payment.cardholder_name_encrypted = if this.payment.cardholder_name.exists() {
          this.payment.cardholder_name.encrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
        }
        
        # Remove plaintext sensitive fields
        root.payment = this.payment.without("card_number", "cvv", "cardholder_name")

    # Step 1.4: Add encryption metadata
    - mapping: |
        root = this
        
        root.payment_encryption_metadata = {
          "encrypted": true,
          "encryption_timestamp": now(),
          "key_version": env("KEY_VERSION").or("unknown"),
          "algorithm": "AES-256-GCM",
          "node_id": env("NODE_ID").or("unknown"),
          "compliance_standard": "PCI-DSS-3.2.1",
          "encrypted_fields": ["payment.card_number", "payment.cvv", "payment.cardholder_name"],
          "preserved_fields": ["payment.card_last_four", "payment.card_bin", "payment.card_brand"]
        }

output:
  file:
    path: "./step-1-output.jsonl"
    codec: "lines"

logger:
  level: "INFO"
  add_timestamp: true
```

## Testing the Payment Encryption

Deploy and test the payment encryption pipeline:

```bash
# Deploy the payment encryption pipeline
expanso job deploy step-1-payment-encryption.yaml

# Verify deployment
expanso job status step-1-payment-encryption

# Wait for processing
sleep 3

# Check the encrypted output
echo "Payment encryption results:"
cat step-1-output.jsonl | jq '.'
```

**Expected output structure:**
```json
{
  "transaction_id": "txn-12345",
  "timestamp": "2025-01-15T10:00:00Z",
  "amount": 49.99,
  "currency": "USD",
  "payment": {
    "card_number_encrypted": "AES256GCM:v1:Y2FyZGRhdGE=:7f6e5d4c3b2a1h0g9f8e7d6c5b4a3g2f",
    "cvv_encrypted": "AES256GCM:v1:Y3Z2ZGF0YQ==:9f8e7d6c5b4a3g2f1h0g9e8d7c6b5a4g",
    "cardholder_name_encrypted": "AES256GCM:v1:bmFtZWRhdGE=:3g2f1h0g9e8d7c6b5a4g3f2e1d0c9b8a",
    "expiry_month": 12,
    "expiry_year": 2028,
    "card_brand": "visa",
    "card_last_four": "9010",
    "card_bin": "453212"
  },
  "customer": {
    "customer_id": "cust-789",
    "first_name": "Sarah",
    "last_name": "Johnson",
    "email": "sarah.johnson@example.com",
    "phone": "+1-415-555-0123",
    "ssn": "123-45-6789",
    "date_of_birth": "1985-03-15"
  },
  "payment_encryption_metadata": {
    "encrypted": true,
    "encryption_timestamp": "2025-01-15T10:10:30.456Z",
    "key_version": "v1_20251115",
    "algorithm": "AES-256-GCM",
    "node_id": "edge-node-myhost",
    "compliance_standard": "PCI-DSS-3.2.1",
    "encrypted_fields": ["payment.card_number", "payment.cvv", "payment.cardholder_name"],
    "preserved_fields": ["payment.card_last_four", "payment.card_bin", "payment.card_brand"]
  }
}
```

## Validation and Testing

### Verify Encryption Success

```bash
# Check that sensitive fields are encrypted
echo "Checking encryption status..."

# Verify no plaintext card numbers remain
if cat step-1-output.jsonl | jq -r '.payment.card_number' | grep -q "453212"; then
    echo "❌ Plaintext card number found - encryption failed!"
else
    echo "✅ Card number encrypted successfully"
fi

# Verify encrypted fields exist
if cat step-1-output.jsonl | jq -r '.payment.card_number_encrypted' | grep -q "AES256GCM"; then
    echo "✅ Encrypted card number found"
else
    echo "❌ Encrypted card number missing"
fi

# Verify preserved fields exist
if cat step-1-output.jsonl | jq -r '.payment.card_last_four' | grep -q "9010"; then
    echo "✅ Last 4 digits preserved"
else
    echo "❌ Last 4 digits missing"
fi

if cat step-1-output.jsonl | jq -r '.payment.card_brand' | grep -q "visa"; then
    echo "✅ Card brand preserved"
else
    echo "❌ Card brand missing"
fi
```

### Test Decryption (Authorized Services Only)

```yaml title="Test decryption for authorized services"
# Create decryption test pipeline
cat > test-decryption.yaml << 'EOF'
input:
  file:
    paths: 
      - "./step-1-output.jsonl"
    codec: "lines"

pipeline:
  processors:
    # Only decrypt if service is authorized
    - mapping: |
        root = this
        
        # Check service authorization (would come from API key, JWT, etc.)
        let authorized_for_payment = env("SERVICE_ROLE") == "payment-processor"
        
        # Decrypt payment fields only if authorized
        root.payment.card_number_decrypted = if authorized_for_payment && 
                                               this.payment.card_number_encrypted.exists() {
          this.payment.card_number_encrypted.decrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
        }
        
        root.payment.cvv_decrypted = if authorized_for_payment && 
                                       this.payment.cvv_encrypted.exists() {
          this.payment.cvv_encrypted.decrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
        }
        
        # Add decryption audit metadata
        root.decryption_audit = if authorized_for_payment {
          {
            "decrypted_by": env("SERVICE_ROLE"),
            "timestamp": now(),
            "node_id": env("NODE_ID"),
            "fields_decrypted": ["payment.card_number", "payment.cvv"]
          }
        }

output:
  file:
    path: "./decryption-test.jsonl"
    codec: "lines"
EOF

# Set service role and test decryption
export SERVICE_ROLE="payment-processor"
expanso job deploy test-decryption.yaml

sleep 3

# Verify decryption worked
echo "Decryption test results:"
cat decryption-test.jsonl | jq '.payment.card_number_decrypted, .payment.cvv_decrypted'

# Clean up
expanso job stop test-decryption
```

## Common Variations

### Variation 1: Industry-Specific Card Types

For specific industries, you might need to handle additional card types:

```yaml title="Healthcare payment cards"
# Healthcare industry cards (FSA, HSA)
card_num.re_match("^606200[0-9]{10}$") => "fsa_visa"
card_num.re_match("^627080[0-9]{10}$") => "hsa_mastercard"

# Government purchase cards  
card_num.re_match("^559805[0-9]{10}$") => "government_visa"
```

### Variation 2: Tokenization Integration

Replace encryption with tokenization for PCI-DSS scope reduction:

```yaml title="Token-based approach"
# Replace card number with secure token
root.payment.card_token = if this.payment.card_number.exists() {
  # Call tokenization service
  http_request("POST", "https://tokenizer.company.com/tokenize", {
    "card_number": this.payment.card_number,
    "merchant_id": env("MERCHANT_ID")
  }).token
}
```

### Variation 3: Format Preserving Encryption (FPE)

Use Format Preserving Encryption to maintain card number format:

```yaml title="Format preserving encryption"
# FPE maintains the format (16 digits) while encrypting
root.payment.card_number_fpe = if this.payment.card_number.exists() {
  this.payment.card_number.encrypt_fpe_ff1(env("CARD_ENCRYPTION_KEY"))
}
```

## PCI-DSS Compliance Notes

### Required PCI-DSS Controls

✅ **Strong Encryption**: AES-256-GCM meets PCI-DSS encryption requirements
✅ **Key Management**: Environment variables are temporary; use HSM/KMS in production  
✅ **Access Control**: Decryption requires service role authorization
✅ **Audit Trail**: Comprehensive metadata tracks all encryption operations
✅ **Data Minimization**: Only last 4 digits and card brand preserved

### Production Requirements

For PCI-DSS compliance in production:

1. **Key Management**: Use Hardware Security Module (HSM) or AWS KMS
2. **Network Security**: TLS 1.2+ for all data transmission
3. **Access Logging**: Log all encryption/decryption operations
4. **Key Rotation**: Rotate keys every 90 days minimum
5. **Penetration Testing**: Annual penetration testing required

## Troubleshooting

### Issue: "Card brand not detected"

**Cause**: Invalid card number format or unsupported card type.

**Solution**: Add validation and error handling:
```yaml
root.payment.validation_error = if this.payment.card_brand == "unknown" {
  "Unsupported or invalid card number format"
}
```

### Issue: "Encryption key not found"

**Cause**: CARD_ENCRYPTION_KEY environment variable not set.

**Solution**: Verify environment variable:
```bash
echo "Card key set: ${CARD_ENCRYPTION_KEY:0:8}..."
```

### Issue: "Last 4 extraction failed"

**Cause**: Card number contains non-numeric characters or is too short.

**Solution**: Add robust validation:
```yaml
let card_num = this.payment.card_number.re_replace_all("[^0-9]", "")
root.payment.card_last_four = if card_num.length() >= 13 {
  card_num.slice(-4)
}
```

## What's Next

You've successfully implemented PCI-DSS compliant payment card encryption! The encrypted payment data is now safe for storage and transmission while preserving essential business operations.

**Key accomplishments:**
- ✅ Full card number encrypted with AES-256-GCM
- ✅ CVV encrypted (critical for transaction security)
- ✅ Cardholder name encrypted (PII protection)
- ✅ Last 4 digits preserved for customer service
- ✅ Card brand preserved for fraud detection
- ✅ BIN preserved for payment routing
- ✅ Complete audit trail for PCI-DSS compliance

**Next step:** [Step 2: Encrypt PII Fields](./step-2-encrypt-pii-fields) - Extend encryption to personal identifiers (email, phone, SSN) with GDPR/CCPA compliance.

---

**Production deployment:** Once you've completed all steps, see [Complete Encryption Pipeline](./complete-encryption-pipeline) for production deployment with key rotation and monitoring.
