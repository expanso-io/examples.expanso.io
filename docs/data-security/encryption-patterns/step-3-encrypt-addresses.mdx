---
title: "Step 3: Encrypt Addresses"
sidebar_label: "Step 3: Address Encryption"  
sidebar_position: 6
description: Encrypt street addresses and detailed zip codes while preserving city, state, and demographic analytics
keywords: [encryption, address, location, privacy, demographics, analytics]
---

# Step 3: Encrypt Addresses

Learn to implement **location privacy encryption** that protects specific addresses while preserving essential demographic and geographic analytics. This step balances individual privacy with business intelligence needs.

## Understanding Address Data Privacy

Address data presents unique privacy challenges because it contains both highly sensitive personal information and valuable demographic insights:

- **Personal Privacy**: Street addresses can reveal income level, lifestyle, and personal patterns
- **Demographic Analytics**: City, state, and ZIP prefix data drives marketing and logistics decisions
- **Compliance Requirements**: Address data is PII under GDPR and protected under various privacy laws
- **Business Operations**: Shipping, billing, and customer service require different levels of address detail

## What We'll Encrypt vs Preserve

**Fields to Encrypt (Privacy Protection):**
- ❌ Full street address (exact location information)
- ❌ Complete ZIP+4 code (precise geographic location)
- ❌ Apartment/unit numbers (specific residence identification)

**Fields to Preserve (Demographic Analytics):**
- ✅ City (urban analytics, market penetration)
- ✅ State/province (regional trends, compliance requirements)
- ✅ ZIP prefix (3-digit demographic clustering)
- ✅ Country code (international market analytics)
- ✅ Address type indicators (residential vs business)

## Input Data Structure

Here's the address data we'll be encrypting:

```json title="Sample billing and shipping addresses"
{
  "billing_address": {
    "street": "123 Main St, Apt 4B",      // ❌ Specific location - encrypt
    "city": "San Francisco",             // ✅ Urban analytics
    "state": "CA",                       // ✅ Regional trends  
    "zip": "94102-1234",                 // ❌ Precise location - encrypt
    "country": "US"                      // ✅ International analytics
  },
  "shipping_address": {
    "street": "456 Oak Ave",             // ❌ Specific location - encrypt
    "city": "Palo Alto",                 // ✅ Urban analytics
    "state": "CA",                       // ✅ Regional trends
    "zip": "94301-5678",                 // ❌ Precise location - encrypt  
    "country": "US"                      // ✅ International analytics
  }
}
```

## Step 3.1: Address Classification and Validation

Classify addresses and validate formats before encryption.

```yaml title="Address classification processor"
pipeline:
  processors:
    # Classify and validate addresses before encryption
    - mapping: |
        root = this
        
        # Classify billing address type
        root.billing_address.address_type = if this.billing_address.street.exists() {
          let street = this.billing_address.street.lowercase()
          
          match {
            # Business indicators
            street.re_match(".*(suite|ste|floor|bldg|building|office|plaza|tower|center|centre).*") => "business"
            
            # Apartment indicators  
            street.re_match(".*(apt|apartment|unit|#).*") => "residential_multi"
            
            # PO Box
            street.re_match(".*p\\.?o\\.? box.*") => "po_box"
            
            # Rural route
            street.re_match(".*(rural route|rr|hc|hwy).*") => "rural"
            
            _ => "residential_single"
          }
        }
        
        # Classify shipping address type
        root.shipping_address.address_type = if this.shipping_address.street.exists() {
          let street = this.shipping_address.street.lowercase()
          
          match {
            street.re_match(".*(suite|ste|floor|bldg|building|office|plaza|tower|center|centre).*") => "business"
            street.re_match(".*(apt|apartment|unit|#).*") => "residential_multi"
            street.re_match(".*p\\.?o\\.? box.*") => "po_box"
            street.re_match(".*(rural route|rr|hc|hwy).*") => "rural"
            _ => "residential_single"
          }
        }
        
        # Validate ZIP code formats
        root.billing_address.zip_format = if this.billing_address.zip.exists() {
          let zip = this.billing_address.zip.re_replace_all("[^0-9-]", "")
          
          match {
            zip.re_match("^[0-9]{5}$") => "zip5"                    # 12345
            zip.re_match("^[0-9]{5}-[0-9]{4}$") => "zip9"          # 12345-6789
            zip.re_match("^[0-9]{5} [0-9]{4}$") => "zip9_space"    # 12345 6789
            _ => "non_us"
          }
        }
        
        root.shipping_address.zip_format = if this.shipping_address.zip.exists() {
          let zip = this.shipping_address.zip.re_replace_all("[^0-9-]", "")
          
          match {
            zip.re_match("^[0-9]{5}$") => "zip5"
            zip.re_match("^[0-9]{5}-[0-9]{4}$") => "zip9"
            zip.re_match("^[0-9]{5} [0-9]{4}$") => "zip9_space"
            _ => "non_us"
          }
        }
```

## Step 3.2: Extract Demographic Analytics Data

Extract demographic indicators before encrypting addresses.

```yaml title="Demographic extraction processor"
    # Extract demographic and geographic analytics before encryption
    - mapping: |
        root = this
        
        # Extract ZIP code prefix for demographic clustering (billing)
        root.billing_address.zip_prefix = if this.billing_address.zip.exists() {
          let zip_clean = this.billing_address.zip.re_replace_all("[^0-9]", "")
          
          if zip_clean.length() >= 3 {
            zip_clean.slice(0, 3)
          }
        }
        
        # Extract ZIP code prefix (shipping)  
        root.shipping_address.zip_prefix = if this.shipping_address.zip.exists() {
          let zip_clean = this.shipping_address.zip.re_replace_all("[^0-9]", "")
          
          if zip_clean.length() >= 3 {
            zip_clean.slice(0, 3)
          }
        }
        
        # Determine metropolitan area from city/state (billing)
        root.billing_address.metro_area = if this.billing_address.city.exists() &&
                                             this.billing_address.state.exists() {
          let city = this.billing_address.city.lowercase()
          let state = this.billing_address.state.uppercase()
          
          match {
            # Major metropolitan areas
            city.re_match(".*(san francisco|sf|oakland|san jose).*") && state == "CA" => "sf_bay_area"
            city.re_match(".*(los angeles|la|hollywood|beverly hills).*") && state == "CA" => "la_metro"
            city.re_match(".*(new york|nyc|brooklyn|queens|manhattan).*") && state == "NY" => "nyc_metro"  
            city.re_match(".*(chicago|cicero).*") && state == "IL" => "chicago_metro"
            city.re_match(".*(houston|katy|sugar land).*") && state == "TX" => "houston_metro"
            city.re_match(".*(phoenix|scottsdale|mesa).*") && state == "AZ" => "phoenix_metro"
            city.re_match(".*(philadelphia|philly).*") && state == "PA" => "philadelphia_metro"
            city.re_match(".*(san antonio).*") && state == "TX" => "san_antonio_metro"
            city.re_match(".*(san diego).*") && state == "CA" => "san_diego_metro"
            city.re_match(".*(dallas|plano|irving).*") && state == "TX" => "dallas_metro"
            
            # State capitals and major cities
            city.re_match("(sacramento|fresno|bakersfield)") && state == "CA" => "ca_other"
            city.re_match("(austin|fort worth|el paso)") && state == "TX" => "tx_other"
            city.re_match("(albany|buffalo|rochester)") && state == "NY" => "ny_other"
            
            _ => "other_urban"
          }
        }
        
        # Same metro area classification for shipping address
        root.shipping_address.metro_area = if this.shipping_address.city.exists() &&
                                              this.shipping_address.state.exists() {
          let city = this.shipping_address.city.lowercase()
          let state = this.shipping_address.state.uppercase()
          
          match {
            city.re_match(".*(san francisco|sf|oakland|san jose).*") && state == "CA" => "sf_bay_area"
            city.re_match(".*(los angeles|la|hollywood|beverly hills).*") && state == "CA" => "la_metro"
            city.re_match(".*(new york|nyc|brooklyn|queens|manhattan).*") && state == "NY" => "nyc_metro"
            _ => "other_urban"
          }
        }
        
        # Determine urban vs suburban vs rural classification
        root.billing_address.area_density = if this.billing_address.zip_prefix.exists() {
          let zip_prefix = this.billing_address.zip_prefix.number()
          
          match {
            # High-density urban ZIP codes (examples)
            zip_prefix >= 100 && zip_prefix <= 119 => "urban_dense"      # NYC area
            zip_prefix >= 940 && zip_prefix <= 941 => "urban_dense"      # SF downtown
            zip_prefix >= 900 && zip_prefix <= 908 => "urban_dense"      # LA central
            
            # Suburban ZIP codes
            zip_prefix >= 940 && zip_prefix <= 949 => "suburban"         # Bay Area suburbs
            zip_prefix >= 910 && zip_prefix <= 935 => "suburban"         # LA suburbs
            
            # Rural ZIP codes (sparse population areas)
            zip_prefix >= 590 && zip_prefix <= 599 => "rural"            # Montana
            zip_prefix >= 820 && zip_prefix <= 831 => "rural"            # Wyoming
            
            _ => "mixed"
          }
        }
```

## Step 3.3: Encrypt Sensitive Address Fields

Encrypt street addresses and detailed ZIP codes while preserving geographic analytics.

```yaml title="Address encryption processor"
    # Encrypt sensitive address components
    - mapping: |
        root = this
        
        # Encrypt billing street address
        root.billing_address.street_encrypted = if this.billing_address.street.exists() {
          this.billing_address.street.encrypt_aes("gcm", env("ADDRESS_ENCRYPTION_KEY"))
        }
        
        # Encrypt detailed ZIP code (keep prefix for analytics)
        root.billing_address.zip_encrypted = if this.billing_address.zip.exists() {
          this.billing_address.zip.encrypt_aes("gcm", env("ADDRESS_ENCRYPTION_KEY"))
        }
        
        # Encrypt shipping street address
        root.shipping_address.street_encrypted = if this.shipping_address.street.exists() {
          this.shipping_address.street.encrypt_aes("gcm", env("ADDRESS_ENCRYPTION_KEY"))
        }
        
        # Encrypt detailed ZIP code
        root.shipping_address.zip_encrypted = if this.shipping_address.zip.exists() {
          this.shipping_address.zip.encrypt_aes("gcm", env("ADDRESS_ENCRYPTION_KEY"))
        }
        
        # Remove plaintext sensitive address fields
        root.billing_address = this.billing_address.without("street", "zip")
        root.shipping_address = this.shipping_address.without("street", "zip")
```

## Step 3.4: Address Matching Analysis

Analyze address relationships for fraud detection and customer insights.

```yaml title="Address relationship processor"
    # Analyze address relationships for business intelligence
    - mapping: |
        root = this
        
        # Compare billing and shipping addresses
        root.address_analysis = {
          # Same city analysis
          "same_city": if this.billing_address.city.exists() &&
                         this.shipping_address.city.exists() {
            this.billing_address.city.lowercase() == this.shipping_address.city.lowercase()
          },
          
          # Same state analysis
          "same_state": if this.billing_address.state.exists() &&
                          this.shipping_address.state.exists() {
            this.billing_address.state.uppercase() == this.shipping_address.state.uppercase()
          },
          
          # Same ZIP prefix analysis (demographic area)
          "same_zip_area": if this.billing_address.zip_prefix.exists() &&
                             this.shipping_address.zip_prefix.exists() {
            this.billing_address.zip_prefix == this.shipping_address.zip_prefix
          },
          
          # Same metro area analysis
          "same_metro": if this.billing_address.metro_area.exists() &&
                          this.shipping_address.metro_area.exists() {
            this.billing_address.metro_area == this.shipping_address.metro_area
          },
          
          # Address type matching (business vs residential)
          "address_type_match": if this.billing_address.address_type.exists() &&
                                   this.shipping_address.address_type.exists() {
            this.billing_address.address_type == this.shipping_address.address_type
          },
          
          # Cross-country shipping indicator  
          "international_shipping": if this.billing_address.country.exists() &&
                                       this.shipping_address.country.exists() {
            this.billing_address.country != this.shipping_address.country
          },
          
          # Distance category (using ZIP prefix as proxy)
          "distance_category": if this.billing_address.zip_prefix.exists() &&
                                 this.shipping_address.zip_prefix.exists() {
            let bill_zip = this.billing_address.zip_prefix.number()
            let ship_zip = this.shipping_address.zip_prefix.number()
            let zip_diff = if bill_zip > ship_zip { bill_zip - ship_zip } else { ship_zip - bill_zip }
            
            match {
              zip_diff == 0 => "same_area"
              zip_diff <= 5 => "local"
              zip_diff <= 50 => "regional" 
              zip_diff <= 100 => "cross_region"
              _ => "cross_country"
            }
          }
        }
```

## Step 3.5: Address Encryption Metadata

Add comprehensive metadata for location privacy compliance.

```yaml title="Address encryption metadata processor"
    # Add address-specific encryption metadata
    - mapping: |
        root = this
        
        # Address encryption audit metadata
        root.address_encryption_metadata = {
          "encrypted": true,
          "encryption_timestamp": now(),
          "key_version": env("KEY_VERSION").or("unknown"),
          "algorithm": "AES-256-GCM",
          "node_id": env("NODE_ID").or("unknown"),
          "compliance_standards": ["location_privacy", "gdpr_article_4"],
          
          # Track address fields encrypted
          "address_fields_encrypted": [
            if this.billing_address.street_encrypted.exists() { "billing_address.street" },
            if this.billing_address.zip_encrypted.exists() { "billing_address.zip" },
            if this.shipping_address.street_encrypted.exists() { "shipping_address.street" },
            if this.shipping_address.zip_encrypted.exists() { "shipping_address.zip" }
          ].filter(v -> v != null),
          
          # Track geographic analytics preserved
          "geographic_analytics_preserved": [
            if this.billing_address.city.exists() { "billing_address.city" },
            if this.billing_address.state.exists() { "billing_address.state" },
            if this.billing_address.country.exists() { "billing_address.country" },
            if this.billing_address.zip_prefix.exists() { "billing_address.zip_prefix" },
            if this.billing_address.metro_area.exists() { "billing_address.metro_area" },
            if this.shipping_address.city.exists() { "shipping_address.city" },
            if this.shipping_address.state.exists() { "shipping_address.state" },
            if this.shipping_address.country.exists() { "shipping_address.country" },
            if this.shipping_address.zip_prefix.exists() { "shipping_address.zip_prefix" },
            if this.shipping_address.metro_area.exists() { "shipping_address.metro_area" }
          ].filter(v -> v != null),
          
          # Geographic privacy assessment
          "privacy_level": {
            "street_level": "encrypted",
            "zip_plus_4": "encrypted", 
            "zip_3": "preserved_for_analytics",
            "city_state": "preserved_for_demographics",
            "metro_area": "derived_for_analytics"
          },
          
          # Business intelligence capabilities preserved
          "analytics_capabilities": [
            "demographic_clustering",
            "regional_trend_analysis", 
            "urban_rural_segmentation",
            "shipping_pattern_analysis",
            "fraud_detection_indicators"
          ]
        }
```

## Complete Address Encryption Pipeline

Here's the complete pipeline combining all address encryption steps:

```yaml title="step-3-address-encryption.yaml"
input:
  file:
    paths: 
      - "./step-2-output.jsonl"  # Use PII-encrypted data from step 2
    codec: "lines"

pipeline:
  processors:
    # Step 3.1: Address classification and validation
    - mapping: |
        root = this
        
        # Classify address types
        root.billing_address.address_type = if this.billing_address.street.exists() {
          let street = this.billing_address.street.lowercase()
          match {
            street.re_match(".*(suite|office|plaza|tower|center).*") => "business"
            street.re_match(".*(apt|apartment|unit|#).*") => "residential_multi"
            street.re_match(".*p\\.?o\\.? box.*") => "po_box"
            _ => "residential_single"
          }
        }
        
        root.shipping_address.address_type = if this.shipping_address.street.exists() {
          let street = this.shipping_address.street.lowercase()
          match {
            street.re_match(".*(suite|office|plaza|tower|center).*") => "business"
            street.re_match(".*(apt|apartment|unit|#).*") => "residential_multi" 
            street.re_match(".*p\\.?o\\.? box.*") => "po_box"
            _ => "residential_single"
          }
        }

    # Step 3.2: Extract demographic analytics
    - mapping: |
        root = this
        
        # Extract ZIP prefixes
        root.billing_address.zip_prefix = if this.billing_address.zip.exists() {
          let zip_clean = this.billing_address.zip.re_replace_all("[^0-9]", "")
          if zip_clean.length() >= 3 { zip_clean.slice(0, 3) }
        }
        
        root.shipping_address.zip_prefix = if this.shipping_address.zip.exists() {
          let zip_clean = this.shipping_address.zip.re_replace_all("[^0-9]", "")
          if zip_clean.length() >= 3 { zip_clean.slice(0, 3) }
        }
        
        # Determine metro areas
        root.billing_address.metro_area = if this.billing_address.city.exists() &&
                                             this.billing_address.state.exists() {
          let city = this.billing_address.city.lowercase()
          let state = this.billing_address.state.uppercase()
          
          match {
            city.re_match(".*(san francisco|sf|oakland|san jose).*") && state == "CA" => "sf_bay_area"
            city.re_match(".*(los angeles|la|hollywood).*") && state == "CA" => "la_metro"
            city.re_match(".*(new york|nyc|brooklyn|queens|manhattan).*") && state == "NY" => "nyc_metro"
            _ => "other_urban"
          }
        }

    # Step 3.3: Encrypt sensitive address fields
    - mapping: |
        root = this
        
        # Encrypt street addresses
        root.billing_address.street_encrypted = if this.billing_address.street.exists() {
          this.billing_address.street.encrypt_aes("gcm", env("ADDRESS_ENCRYPTION_KEY"))
        }
        
        root.billing_address.zip_encrypted = if this.billing_address.zip.exists() {
          this.billing_address.zip.encrypt_aes("gcm", env("ADDRESS_ENCRYPTION_KEY"))
        }
        
        root.shipping_address.street_encrypted = if this.shipping_address.street.exists() {
          this.shipping_address.street.encrypt_aes("gcm", env("ADDRESS_ENCRYPTION_KEY"))
        }
        
        root.shipping_address.zip_encrypted = if this.shipping_address.zip.exists() {
          this.shipping_address.zip.encrypt_aes("gcm", env("ADDRESS_ENCRYPTION_KEY"))
        }
        
        # Remove plaintext sensitive fields
        root.billing_address = this.billing_address.without("street", "zip")
        root.shipping_address = this.shipping_address.without("street", "zip")

    # Step 3.4: Address relationship analysis
    - mapping: |
        root = this
        
        root.address_analysis = {
          "same_city": if this.billing_address.city.exists() &&
                         this.shipping_address.city.exists() {
            this.billing_address.city.lowercase() == this.shipping_address.city.lowercase()
          },
          
          "same_state": if this.billing_address.state.exists() &&
                          this.shipping_address.state.exists() {
            this.billing_address.state.uppercase() == this.shipping_address.state.uppercase()
          },
          
          "same_zip_area": if this.billing_address.zip_prefix.exists() &&
                             this.shipping_address.zip_prefix.exists() {
            this.billing_address.zip_prefix == this.shipping_address.zip_prefix
          }
        }

    # Step 3.5: Address encryption metadata
    - mapping: |
        root = this
        
        root.address_encryption_metadata = {
          "encrypted": true,
          "encryption_timestamp": now(),
          "key_version": env("KEY_VERSION").or("unknown"),
          "algorithm": "AES-256-GCM",
          "compliance_standards": ["location_privacy", "gdpr_article_4"],
          "address_fields_encrypted": [
            "billing_address.street", "billing_address.zip",
            "shipping_address.street", "shipping_address.zip"
          ],
          "geographic_analytics_preserved": [
            "billing_address.city", "billing_address.state", "billing_address.zip_prefix",
            "shipping_address.city", "shipping_address.state", "shipping_address.zip_prefix"
          ]
        }

output:
  file:
    path: "./step-3-output.jsonl"
    codec: "lines"

logger:
  level: "INFO"
  add_timestamp: true
```

## Testing Address Encryption

Deploy and test the address encryption pipeline:

```bash
# Deploy the address encryption pipeline
expanso job deploy step-3-address-encryption.yaml

# Verify deployment
expanso job status step-3-address-encryption

# Wait for processing
sleep 3

# Check the encrypted output
echo "Address encryption results:"
cat step-3-output.jsonl | jq '.billing_address, .shipping_address, .address_analysis'
```

**Expected output structure:**
```json
{
  "billing_address": {
    "street_encrypted": "AES256GCM:v1:c3RyZWV0ZGF0YQ==:9f8e7d6c5b4a3g2f1h0g",
    "zip_encrypted": "AES256GCM:v1:emlwZGF0YWhlcmU=:8e7d6c5b4a3g2f1h0g9e",
    "city": "San Francisco",
    "state": "CA",
    "country": "US",
    "zip_prefix": "941",
    "metro_area": "sf_bay_area",
    "address_type": "residential_multi"
  },
  "shipping_address": {
    "street_encrypted": "AES256GCM:v1:c2hpcGFkZHJlc3M=:7d6c5b4a3g2f1h0g9e8d",
    "zip_encrypted": "AES256GCM:v1:c2hpcHppcA==:6c5b4a3g2f1h0g9e8d7c",
    "city": "Palo Alto", 
    "state": "CA",
    "country": "US",
    "zip_prefix": "943",
    "metro_area": "sf_bay_area",
    "address_type": "residential_single"
  },
  "address_analysis": {
    "same_city": false,
    "same_state": true,
    "same_zip_area": false
  }
}
```

## Validation and Privacy Testing

### Verify Location Privacy

```bash
# Check that specific location data is encrypted
echo "Location Privacy Check..."

# Verify no plaintext street addresses
if cat step-3-output.jsonl | jq -r '.billing_address.street // empty' | grep -q "Main St"; then
    echo "❌ Plaintext street address found - privacy violation!"
else
    echo "✅ Street addresses encrypted"
fi

# Verify no detailed ZIP codes
if cat step-3-output.jsonl | jq -r '.billing_address.zip // empty' | grep -q "94102"; then
    echo "❌ Plaintext detailed ZIP found - privacy violation!"
else
    echo "✅ Detailed ZIP codes encrypted"
fi

# Verify preserved analytics data exists
if cat step-3-output.jsonl | jq -r '.billing_address.city' | grep -q "San Francisco"; then
    echo "✅ City preserved for demographics"
fi

if cat step-3-output.jsonl | jq -r '.billing_address.zip_prefix' | grep -q "941"; then
    echo "✅ ZIP prefix preserved for analytics"
fi

if cat step-3-output.jsonl | jq -r '.billing_address.metro_area' | grep -q "sf_bay_area"; then
    echo "✅ Metro area derived for regional analysis"
fi
```

### Test Demographic Analytics

```bash
# Test demographic analytics capabilities
echo "Testing demographic analytics..."

# Extract demographic insights from encrypted data
cat step-3-output.jsonl | jq '{
  regional_distribution: {
    metro_area: .billing_address.metro_area,
    state: .billing_address.state,
    zip_prefix: .billing_address.zip_prefix
  },
  address_patterns: {
    address_type: .billing_address.address_type,
    same_state_billing_shipping: .address_analysis.same_state,
    cross_metro_shipping: (.billing_address.metro_area != .shipping_address.metro_area)
  }
}'
```

## Common Variations

### Variation 1: International Address Support

Handle international address formats and privacy requirements:

```yaml title="International address encryption"
# International address patterns
root.billing_address.country_privacy_level = if this.billing_address.country.exists() {
  let country = this.billing_address.country.uppercase()
  
  match {
    # GDPR countries (strict privacy)
    country.re_match("(DE|FR|IT|ES|NL|BE|AT|DK|SE|NO|FI)") => "gdpr_strict"
    
    # GDPR but different postal systems
    country == "GB" => "gdpr_postal_code"
    
    # CCPA and other US privacy laws
    country == "US" => "ccpa_state_privacy"
    
    # Other privacy-conscious countries
    country.re_match("(CA|AU|JP)") => "moderate_privacy"
    
    _ => "standard_privacy"
  }
}

# International postal code handling
root.billing_address.postal_area = if this.billing_address.zip.exists() &&
                                      this.billing_address.country.exists() {
  let country = this.billing_address.country.uppercase()
  let postal = this.billing_address.zip.uppercase()
  
  match {
    # UK postcodes - preserve outward code (e.g., "SW1A" from "SW1A 1AA")
    country == "GB" => postal.split(" ").index(0)
    
    # Canadian postal codes - preserve first character (e.g., "K" from "K1A 0A6")  
    country == "CA" => postal.slice(0, 1)
    
    # German postal codes - preserve first 2 digits
    country == "DE" => postal.slice(0, 2)
    
    # US ZIP codes - preserve 3-digit prefix
    country == "US" => postal.slice(0, 3)
    
    _ => null
  }
}
```

### Variation 2: Fraud Detection Integration

Enhance address analysis for fraud detection:

```yaml title="Fraud detection address patterns"
# Advanced fraud detection patterns
root.address_fraud_indicators = {
  # High-risk shipping patterns
  "high_risk_shipping": if this.address_analysis.exists() {
    [
      # Different states
      this.address_analysis.same_state == false,
      
      # Business billing, residential shipping (or vice versa)
      this.billing_address.address_type == "business" && 
      this.shipping_address.address_type.re_match("residential.*"),
      
      # PO Box shipping with residential billing
      this.shipping_address.address_type == "po_box" &&
      this.billing_address.address_type.re_match("residential.*"),
      
      # International shipping from domestic billing
      this.address_analysis.international_shipping == true
    ].filter(v -> v == true).length() >= 2
  },
  
  # Address velocity (would require historical data)
  "new_shipping_location": true,  # Placeholder for historical check
  
  # Geographic anomalies
  "unusual_distance": this.address_analysis.distance_category == "cross_country",
  
  # Address type mismatches
  "type_mismatch": this.billing_address.address_type != this.shipping_address.address_type
}
```

### Variation 3: GDPR Article 17 (Right to Erasure) Support

Implement location data deletion for privacy compliance:

```yaml title="Location data deletion for GDPR"
# GDPR location data deletion
root.address_deletion_capability = {
  "can_delete_precise_location": true,
  "preserved_after_deletion": [
    "city", "state", "country",      # Geographic indicators
    "zip_prefix",                     # Demographic clustering
    "metro_area",                     # Regional analytics
    "address_type"                    # Business intelligence
  ],
  "deleted_on_request": [
    "street_encrypted",               # Specific address
    "zip_encrypted"                   # Precise location
  ]
}
```

## Location Privacy Compliance

### Geographic Privacy Principles

✅ **Precision Gradient**: More precise = more encrypted (street > ZIP+4 > ZIP3 > city)
✅ **Business Utility**: Preserve minimum viable geographic data for operations
✅ **Demographic Clustering**: ZIP prefix enables analytics without personal identification
✅ **Consent Alignment**: Different encryption levels based on consent granularity
✅ **Deletion Support**: Can remove precise location while keeping regional indicators

### Production Privacy Requirements

For location privacy compliance in production:

1. **Consent Granularity**: Separate consent for precise vs demographic location data
2. **Retention Policies**: Different retention for encrypted vs demographic data
3. **Cross-Border**: Consider data residency requirements for encrypted location data
4. **Audit Trails**: Track all location data access and processing operations
5. **De-identification Standards**: Ensure ZIP prefix aggregation meets k-anonymity requirements

## Troubleshooting

### Issue: "ZIP prefix extraction failed"

**Cause**: Non-US postal codes or invalid format.

**Solution**: Add international postal code support:
```yaml
root.postal_area = if this.billing_address.country == "US" {
  this.billing_address.zip.re_replace_all("[^0-9]", "").slice(0, 3)
} else if this.billing_address.country == "CA" {
  this.billing_address.zip.re_replace_all("[^A-Z0-9]", "").slice(0, 1)
} else if this.billing_address.country == "GB" {
  this.billing_address.zip.split(" ").index(0)
}
```

### Issue: "Metro area not detected"

**Cause**: City name variations or missing city/state data.

**Solution**: Add city name normalization:
```yaml
let city_normalized = this.billing_address.city.lowercase().
  re_replace_all("(\\.|,|')", "").        # Remove punctuation
  re_replace_all("\\s+", "_")             # Replace spaces with underscores
```

### Issue: "Address type classification incorrect"

**Cause**: Regional variations in address format.

**Solution**: Add regional address pattern matching:
```yaml
# Regional business address patterns
street.re_match(".*(mall|shopping center|strip|retail).*") => "retail_business"
street.re_match(".*(industrial|warehouse|distribution).*") => "industrial"
street.re_match(".*(medical|hospital|clinic).*") => "healthcare"
```

## What's Next

You've successfully implemented location privacy encryption with demographic analytics preservation! Address data is now protected while maintaining essential business intelligence capabilities.

**Key accomplishments:**
- ✅ Street addresses encrypted for location privacy
- ✅ Detailed ZIP codes encrypted while preserving 3-digit demographic clusters
- ✅ City, state, country preserved for regional analytics and compliance
- ✅ Address type classification for fraud detection and customer insights
- ✅ Metropolitan area derivation for market analysis
- ✅ Address relationship analysis for shipping pattern detection
- ✅ GDPR-compliant location privacy with selective data preservation

**Next step:** [Step 4: Encrypt Dates](./step-4-encrypt-dates) - Implement temporal privacy encryption for birth dates and sensitive timestamps while preserving age cohorts and temporal analytics.

---

**Privacy consideration:** Location data is particularly sensitive. Always review with privacy and legal teams to ensure your geographic data retention meets local privacy requirements and customer expectations.
