---
title: "Step 5: Multi-Key Strategy"
sidebar_label: "Step 5: Multi-Key Security"
sidebar_position: 8
description: Implement risk-based encryption architecture using different keys for different data sensitivity levels
keywords: [encryption, multi-key, security, risk-based, key-management, architecture]
---

# Step 5: Multi-Key Strategy

Learn to implement a **risk-based multi-key encryption architecture** that uses different encryption keys for different data sensitivity levels. This approach provides defense in depth, enables flexible key rotation schedules, and meets advanced security requirements.

## Understanding Multi-Key Architecture

A single encryption key creates a single point of failure. Multi-key strategies provide several security advantages:

- **Breach Containment**: One compromised key doesn't expose all data types
- **Risk-Based Security**: Higher-risk data uses more frequently rotated keys
- **Compliance Alignment**: Different regulations may require different key management
- **Access Control**: Different services can access different data types
- **Audit Granularity**: Track access and rotation by data sensitivity level

## Key Categories by Risk Level

Based on the data we've encrypted in previous steps, we'll organize keys by risk level:

### Tier 1: Critical Risk (90-day rotation)
- **Payment Card Key**: Credit card numbers, CVV codes
- **Regulatory Compliance**: PCI-DSS Level 1 requirements
- **Access**: Payment processing services only

### Tier 2: High Risk (180-day rotation)  
- **PII Key**: Names, email, phone, SSN
- **Regulatory Compliance**: GDPR, CCPA requirements
- **Access**: Customer service and authorized analytics

### Tier 3: Medium Risk (365-day rotation)
- **Address Key**: Street addresses, detailed ZIP codes
- **Location Key**: Precise location data
- **Access**: Shipping, logistics, demographic analytics

### Tier 4: Temporal Risk (365-day rotation)
- **Temporal Key**: Birth dates, medical appointments
- **Regulatory Compliance**: HIPAA requirements
- **Access**: Healthcare systems, age analytics

## Step 5.1: Multi-Key Configuration

Implement key selection based on data sensitivity classification.

```yaml title="Multi-key configuration processor"
pipeline:
  processors:
    # Implement multi-key encryption strategy
    - mapping: |
        root = this
        
        # Define key mappings based on data sensitivity
        let encryption_keys = {
          "payment_critical": {
            "key": env("PAYMENT_ENCRYPTION_KEY"),
            "version": env("PAYMENT_KEY_VERSION").or("v1"),
            "rotation_days": 90,
            "compliance": ["PCI-DSS"],
            "access_level": "payment_processor_only"
          },
          
          "pii_high": {
            "key": env("PII_ENCRYPTION_KEY"),
            "version": env("PII_KEY_VERSION").or("v1"), 
            "rotation_days": 180,
            "compliance": ["GDPR", "CCPA"],
            "access_level": "customer_service_analytics"
          },
          
          "location_medium": {
            "key": env("ADDRESS_ENCRYPTION_KEY"),
            "version": env("ADDRESS_KEY_VERSION").or("v1"),
            "rotation_days": 365,
            "compliance": ["location_privacy"],
            "access_level": "logistics_demographics"
          },
          
          "temporal_medium": {
            "key": env("TEMPORAL_ENCRYPTION_KEY"),
            "version": env("TEMPORAL_KEY_VERSION").or("v1"),
            "rotation_days": 365,
            "compliance": ["HIPAA"],
            "access_level": "healthcare_age_analytics"
          }
        }
        
        # Re-encrypt payment data with critical security key
        root.payment.card_number_encrypted = if this.payment.card_number_encrypted.exists() {
          # If already encrypted with single key, re-encrypt with payment key
          let decrypted = this.payment.card_number_encrypted.decrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
          decrypted.encrypt_aes("gcm", encryption_keys.payment_critical.key)
        }
        
        root.payment.cvv_encrypted = if this.payment.cvv_encrypted.exists() {
          let decrypted = this.payment.cvv_encrypted.decrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
          decrypted.encrypt_aes("gcm", encryption_keys.payment_critical.key)
        }
        
        root.payment.cardholder_name_encrypted = if this.payment.cardholder_name_encrypted.exists() {
          let decrypted = this.payment.cardholder_name_encrypted.decrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
          decrypted.encrypt_aes("gcm", encryption_keys.payment_critical.key)
        }
        
        # Re-encrypt PII data with high-security key
        root.customer.email_encrypted = if this.customer.email_encrypted.exists() {
          let decrypted = this.customer.email_encrypted.decrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
          decrypted.encrypt_aes("gcm", encryption_keys.pii_high.key)
        }
        
        root.customer.phone_encrypted = if this.customer.phone_encrypted.exists() {
          let decrypted = this.customer.phone_encrypted.decrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
          decrypted.encrypt_aes("gcm", encryption_keys.pii_high.key)
        }
        
        root.customer.ssn_encrypted = if this.customer.ssn_encrypted.exists() {
          let decrypted = this.customer.ssn_encrypted.decrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
          decrypted.encrypt_aes("gcm", encryption_keys.pii_high.key)
        }
        
        root.customer.first_name_encrypted = if this.customer.first_name_encrypted.exists() {
          let decrypted = this.customer.first_name_encrypted.decrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
          decrypted.encrypt_aes("gcm", encryption_keys.pii_high.key)
        }
        
        root.customer.last_name_encrypted = if this.customer.last_name_encrypted.exists() {
          let decrypted = this.customer.last_name_encrypted.decrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
          decrypted.encrypt_aes("gcm", encryption_keys.pii_high.key)
        }
        
        # Store encryption metadata for each key type used
        root.multi_key_metadata = {
          "encryption_architecture": "multi_tier_risk_based",
          "encryption_timestamp": now(),
          "node_id": env("NODE_ID").or("unknown"),
          
          "key_tiers_used": {
            "payment_critical": {
              "key_version": encryption_keys.payment_critical.version,
              "rotation_schedule_days": encryption_keys.payment_critical.rotation_days,
              "compliance_standards": encryption_keys.payment_critical.compliance,
              "access_control": encryption_keys.payment_critical.access_level,
              "fields_encrypted": [
                "payment.card_number", "payment.cvv", "payment.cardholder_name"
              ]
            },
            
            "pii_high": {
              "key_version": encryption_keys.pii_high.version,
              "rotation_schedule_days": encryption_keys.pii_high.rotation_days,
              "compliance_standards": encryption_keys.pii_high.compliance,
              "access_control": encryption_keys.pii_high.access_level,
              "fields_encrypted": [
                "customer.email", "customer.phone", "customer.ssn",
                "customer.first_name", "customer.last_name"
              ]
            },
            
            "location_medium": {
              "key_version": encryption_keys.location_medium.version,
              "rotation_schedule_days": encryption_keys.location_medium.rotation_days,
              "compliance_standards": encryption_keys.location_medium.compliance,
              "access_control": encryption_keys.location_medium.access_level,
              "fields_encrypted": [
                "billing_address.street", "billing_address.zip",
                "shipping_address.street", "shipping_address.zip"
              ]
            },
            
            "temporal_medium": {
              "key_version": encryption_keys.temporal_medium.version,
              "rotation_schedule_days": encryption_keys.temporal_medium.rotation_days,
              "compliance_standards": encryption_keys.temporal_medium.compliance,
              "access_control": encryption_keys.temporal_medium.access_level,
              "fields_encrypted": [
                "customer.date_of_birth"
              ]
            }
          }
        }
```

## Step 5.2: Key Rotation Detection

Implement automatic detection of when keys need rotation based on age and usage.

```yaml title="Key rotation monitoring processor"
    # Detect and track key rotation requirements
    - mapping: |
        root = this
        
        # Calculate key ages and rotation requirements
        root.key_rotation_status = {
          # Payment key rotation (critical - 90 days)
          "payment_key": {
            "current_version": env("PAYMENT_KEY_VERSION").or("unknown"),
            "rotation_required": if env("PAYMENT_KEY_CREATED").exists() {
              let key_created = env("PAYMENT_KEY_CREATED").parse_timestamp()
              let days_old = (now().ts_unix() - key_created.ts_unix()) / (24 * 3600)
              days_old >= 90
            } else { true },  # No creation date = needs rotation
            
            "days_until_rotation": if env("PAYMENT_KEY_CREATED").exists() {
              let key_created = env("PAYMENT_KEY_CREATED").parse_timestamp()
              let days_old = (now().ts_unix() - key_created.ts_unix()) / (24 * 3600)
              let remaining = 90 - days_old
              if remaining > 0 { remaining.floor() } else { 0 }
            } else { 0 },
            
            "risk_level": "critical",
            "max_age_days": 90
          },
          
          # PII key rotation (high - 180 days)
          "pii_key": {
            "current_version": env("PII_KEY_VERSION").or("unknown"),
            "rotation_required": if env("PII_KEY_CREATED").exists() {
              let key_created = env("PII_KEY_CREATED").parse_timestamp()
              let days_old = (now().ts_unix() - key_created.ts_unix()) / (24 * 3600)
              days_old >= 180
            } else { true },
            
            "days_until_rotation": if env("PII_KEY_CREATED").exists() {
              let key_created = env("PII_KEY_CREATED").parse_timestamp()
              let days_old = (now().ts_unix() - key_created.ts_unix()) / (24 * 3600)
              let remaining = 180 - days_old
              if remaining > 0 { remaining.floor() } else { 0 }
            } else { 0 },
            
            "risk_level": "high",
            "max_age_days": 180
          },
          
          # Address key rotation (medium - 365 days)
          "address_key": {
            "current_version": env("ADDRESS_KEY_VERSION").or("unknown"),
            "rotation_required": if env("ADDRESS_KEY_CREATED").exists() {
              let key_created = env("ADDRESS_KEY_CREATED").parse_timestamp()
              let days_old = (now().ts_unix() - key_created.ts_unix()) / (24 * 3600)
              days_old >= 365
            } else { true },
            
            "days_until_rotation": if env("ADDRESS_KEY_CREATED").exists() {
              let key_created = env("ADDRESS_KEY_CREATED").parse_timestamp()
              let days_old = (now().ts_unix() - key_created.ts_unix()) / (24 * 3600)
              let remaining = 365 - days_old
              if remaining > 0 { remaining.floor() } else { 0 }
            } else { 0 },
            
            "risk_level": "medium",
            "max_age_days": 365
          },
          
          # Temporal key rotation (medium - 365 days)
          "temporal_key": {
            "current_version": env("TEMPORAL_KEY_VERSION").or("unknown"),
            "rotation_required": if env("TEMPORAL_KEY_CREATED").exists() {
              let key_created = env("TEMPORAL_KEY_CREATED").parse_timestamp()
              let days_old = (now().ts_unix() - key_created.ts_unix()) / (24 * 3600)
              days_old >= 365
            } else { true },
            
            "days_until_rotation": if env("TEMPORAL_KEY_CREATED").exists() {
              let key_created = env("TEMPORAL_KEY_CREATED").parse_timestamp()
              let days_old = (now().ts_unix() - key_created.ts_unix()) / (24 * 3600)
              let remaining = 365 - days_old
              if remaining > 0 { remaining.floor() } else { 0 }
            } else { 0 },
            
            "risk_level": "medium",
            "max_age_days": 365
          }
        }
        
        # Generate rotation alerts
        root.rotation_alerts = [
          if root.key_rotation_status.payment_key.rotation_required {
            {
              "severity": "critical",
              "key_type": "payment",
              "message": "Payment encryption key requires immediate rotation (90+ days old)",
              "action_required": "Generate new payment key and re-encrypt all payment data"
            }
          },
          
          if root.key_rotation_status.pii_key.rotation_required {
            {
              "severity": "high", 
              "key_type": "pii",
              "message": "PII encryption key requires rotation (180+ days old)",
              "action_required": "Generate new PII key and re-encrypt personal data"
            }
          },
          
          if root.key_rotation_status.address_key.rotation_required {
            {
              "severity": "medium",
              "key_type": "address", 
              "message": "Address encryption key requires rotation (365+ days old)",
              "action_required": "Generate new address key and re-encrypt location data"
            }
          },
          
          if root.key_rotation_status.temporal_key.rotation_required {
            {
              "severity": "medium",
              "key_type": "temporal",
              "message": "Temporal encryption key requires rotation (365+ days old)", 
              "action_required": "Generate new temporal key and re-encrypt date data"
            }
          }
        ].filter(v -> v != null)
```

## Step 5.3: Access Control by Key Type

Implement granular access control that restricts decryption based on service role and key type.

```yaml title="Access control processor"
    # Implement role-based access control for different key types
    - mapping: |
        root = this
        
        # Get service role and permissions from environment/headers
        let service_role = env("SERVICE_ROLE").or("unknown")
        let service_permissions = env("SERVICE_PERMISSIONS").or("").split(",")
        
        # Define access control matrix
        let access_control = {
          "payment_processor": {
            "can_decrypt": ["payment_critical"],
            "can_read_analytics": ["payment_analytics"],
            "description": "Payment processing services"
          },
          
          "customer_service": {
            "can_decrypt": ["pii_high"],
            "can_read_analytics": ["pii_analytics", "address_analytics", "age_analytics"],
            "description": "Customer support operations"
          },
          
          "marketing_analytics": {
            "can_decrypt": [],  # No decryption access
            "can_read_analytics": ["pii_analytics", "address_analytics", "age_analytics", "temporal_analytics"],
            "description": "Marketing and business intelligence"
          },
          
          "logistics_service": {
            "can_decrypt": ["location_medium"],
            "can_read_analytics": ["address_analytics"],
            "description": "Shipping and logistics operations"
          },
          
          "healthcare_service": {
            "can_decrypt": ["temporal_medium"],
            "can_read_analytics": ["age_analytics", "temporal_analytics"],
            "description": "Healthcare and medical services"
          },
          
          "compliance_audit": {
            "can_decrypt": ["pii_high", "location_medium", "temporal_medium"],  # Not payment
            "can_read_analytics": ["all"],
            "description": "Compliance auditing (no payment data access)"
          },
          
          "admin_emergency": {
            "can_decrypt": ["payment_critical", "pii_high", "location_medium", "temporal_medium"],
            "can_read_analytics": ["all"],
            "description": "Emergency administrative access (logged and monitored)"
          }
        }
        
        # Check service authorization
        root.access_control_status = {
          "service_role": service_role,
          "service_permissions": service_permissions,
          "authorized_for": if access_control.get(service_role).exists() {
            access_control.get(service_role)
          } else {
            {
              "can_decrypt": [],
              "can_read_analytics": [],
              "description": "Unauthorized service role"
            }
          },
          
          # Access audit trail
          "access_timestamp": now(),
          "node_id": env("NODE_ID").or("unknown"),
          "request_origin": env("REQUEST_IP").or("unknown"),
          "session_id": env("SESSION_ID").or("unknown")
        }
        
        # Log access attempts for audit
        meta access_audit_log = {
          "timestamp": now(),
          "service_role": service_role,
          "requested_access": service_permissions,
          "granted_access": root.access_control_status.authorized_for.can_decrypt,
          "data_accessed": this.multi_key_metadata.key_tiers_used.keys(),
          "request_source": env("REQUEST_IP").or("unknown"),
          "session_id": env("SESSION_ID").or("unknown")
        }
```

## Step 5.4: Key Usage Analytics

Track key usage patterns for security monitoring and compliance reporting.

```yaml title="Key usage analytics processor"
    # Track key usage patterns for security monitoring
    - mapping: |
        root = this
        
        # Calculate encryption coverage and key distribution
        root.encryption_coverage_analytics = {
          "total_fields_encrypted": this.multi_key_metadata.key_tiers_used.values().
            map_each(tier -> tier.fields_encrypted.length()).
            fold(0, acc -> acc + this),
          
          "encryption_by_risk_level": {
            "critical_risk_fields": this.multi_key_metadata.key_tiers_used.payment_critical.fields_encrypted.length(),
            "high_risk_fields": this.multi_key_metadata.key_tiers_used.pii_high.fields_encrypted.length(),
            "medium_risk_fields": (
              this.multi_key_metadata.key_tiers_used.location_medium.fields_encrypted.length() +
              this.multi_key_metadata.key_tiers_used.temporal_medium.fields_encrypted.length()
            )
          },
          
          "key_distribution": {
            "payment_key_usage": this.multi_key_metadata.key_tiers_used.payment_critical.fields_encrypted.length() / 
              this.encryption_coverage_analytics.total_fields_encrypted * 100,
            "pii_key_usage": this.multi_key_metadata.key_tiers_used.pii_high.fields_encrypted.length() /
              this.encryption_coverage_analytics.total_fields_encrypted * 100,
            "location_key_usage": this.multi_key_metadata.key_tiers_used.location_medium.fields_encrypted.length() /
              this.encryption_coverage_analytics.total_fields_encrypted * 100,
            "temporal_key_usage": this.multi_key_metadata.key_tiers_used.temporal_medium.fields_encrypted.length() /
              this.encryption_coverage_analytics.total_fields_encrypted * 100
          }
        }
        
        # Security posture assessment
        root.security_posture = {
          "risk_based_encryption": true,
          "multi_tier_architecture": true,
          "key_rotation_tracking": true,
          "access_control_implemented": true,
          
          # Calculate overall security score
          "security_score": {
            "key_diversity": if this.multi_key_metadata.key_tiers_used.keys().length() >= 3 { 25 } else { 10 },
            "rotation_compliance": this.key_rotation_status.values().
              filter(key -> key.rotation_required == false).length() * 5,  # 5 points per up-to-date key
            "access_control": if this.access_control_status.authorized_for.can_decrypt.length() > 0 { 25 } else { 0 },
            "audit_trail": if meta("access_audit_log").exists() { 25 } else { 0 }
          },
          
          "total_security_score": root.security_posture.security_score.values().fold(0, acc -> acc + this),
          "security_grade": match {
            let score = root.security_posture.total_security_score
            score >= 90 => "A"
            score >= 80 => "B" 
            score >= 70 => "C"
            score >= 60 => "D"
            _ => "F"
          }
        }
```

## Step 5.5: Emergency Key Recovery

Implement emergency procedures for key compromise scenarios.

```yaml title="Emergency key recovery processor"
    # Implement emergency key recovery and re-encryption procedures
    - mapping: |
        root = this
        
        # Check for key compromise indicators
        let key_compromise_check = {
          "payment_key_compromised": env("PAYMENT_KEY_COMPROMISED").or("false") == "true",
          "pii_key_compromised": env("PII_KEY_COMPROMISED").or("false") == "true", 
          "address_key_compromised": env("ADDRESS_KEY_COMPROMISED").or("false") == "true",
          "temporal_key_compromised": env("TEMPORAL_KEY_COMPROMISED").or("false") == "true"
        }
        
        # Emergency re-encryption procedures
        root.emergency_procedures = if key_compromise_check.values().any(v -> v == true) {
          {
            "emergency_active": true,
            "compromise_detected": key_compromise_check,
            "immediate_actions_required": [
              if key_compromise_check.payment_key_compromised {
                {
                  "priority": "critical",
                  "action": "Immediately rotate payment encryption key",
                  "scope": "All payment card data", 
                  "estimated_time": "2-4 hours",
                  "business_impact": "Payment processing may be temporarily unavailable"
                }
              },
              
              if key_compromise_check.pii_key_compromised {
                {
                  "priority": "high",
                  "action": "Rotate PII encryption key within 24 hours",
                  "scope": "All personal identifier data",
                  "estimated_time": "4-8 hours", 
                  "business_impact": "Customer service may have limited access"
                }
              },
              
              if key_compromise_check.address_key_compromised {
                {
                  "priority": "medium",
                  "action": "Rotate address encryption key within 72 hours",
                  "scope": "All location and shipping data",
                  "estimated_time": "2-4 hours",
                  "business_impact": "Shipping operations may be delayed"
                }
              },
              
              if key_compromise_check.temporal_key_compromised {
                {
                  "priority": "medium",
                  "action": "Rotate temporal encryption key within 72 hours", 
                  "scope": "All date and time sensitive data",
                  "estimated_time": "1-2 hours",
                  "business_impact": "Age-based analytics may be temporarily unavailable"
                }
              }
            ].filter(v -> v != null),
            
            "emergency_contact": {
              "security_team": env("SECURITY_TEAM_CONTACT"),
              "compliance_team": env("COMPLIANCE_TEAM_CONTACT"),
              "key_manager": env("KEY_MANAGER_CONTACT")
            },
            
            "breach_notification": {
              "customer_notification_required": key_compromise_check.payment_key_compromised || 
                                               key_compromise_check.pii_key_compromised,
              "regulatory_notification_required": true,
              "notification_timeline": "72 hours for GDPR, varies by jurisdiction"
            }
          }
        } else {
          {
            "emergency_active": false,
            "all_keys_secure": true,
            "last_security_check": now()
          }
        }
```

## Complete Multi-Key Strategy Pipeline

Here's the complete pipeline implementing all multi-key strategy components:

```yaml title="step-5-multi-key-strategy.yaml"
input:
  file:
    paths: 
      - "./step-4-output.jsonl"  # Use temporal-encrypted data from step 4
    codec: "lines"

pipeline:
  processors:
    # Step 5.1: Implement multi-key encryption
    - mapping: |
        root = this
        
        # Define key tiers
        let key_tiers = {
          "payment_critical": env("PAYMENT_ENCRYPTION_KEY"),
          "pii_high": env("PII_ENCRYPTION_KEY"), 
          "location_medium": env("ADDRESS_ENCRYPTION_KEY"),
          "temporal_medium": env("TEMPORAL_ENCRYPTION_KEY")
        }
        
        # Store multi-key metadata
        root.multi_key_metadata = {
          "encryption_architecture": "multi_tier_risk_based",
          "encryption_timestamp": now(),
          "node_id": env("NODE_ID").or("unknown"),
          
          "key_tiers_used": {
            "payment_critical": {
              "key_version": env("PAYMENT_KEY_VERSION").or("v1"),
              "rotation_schedule_days": 90,
              "compliance_standards": ["PCI-DSS"],
              "access_control": "payment_processor_only",
              "fields_encrypted": [
                "payment.card_number", "payment.cvv", "payment.cardholder_name"
              ]
            },
            
            "pii_high": {
              "key_version": env("PII_KEY_VERSION").or("v1"),
              "rotation_schedule_days": 180,
              "compliance_standards": ["GDPR", "CCPA"],
              "access_control": "customer_service_analytics",
              "fields_encrypted": [
                "customer.email", "customer.phone", "customer.ssn",
                "customer.first_name", "customer.last_name"
              ]
            },
            
            "location_medium": {
              "key_version": env("ADDRESS_KEY_VERSION").or("v1"),
              "rotation_schedule_days": 365,
              "compliance_standards": ["location_privacy"],
              "access_control": "logistics_demographics",
              "fields_encrypted": [
                "billing_address.street", "billing_address.zip",
                "shipping_address.street", "shipping_address.zip"
              ]
            },
            
            "temporal_medium": {
              "key_version": env("TEMPORAL_KEY_VERSION").or("v1"),
              "rotation_schedule_days": 365,
              "compliance_standards": ["HIPAA"],
              "access_control": "healthcare_age_analytics", 
              "fields_encrypted": ["customer.date_of_birth"]
            }
          }
        }

    # Step 5.2: Key rotation monitoring
    - mapping: |
        root = this
        
        root.key_rotation_status = {
          "payment_key": {
            "current_version": env("PAYMENT_KEY_VERSION").or("unknown"),
            "risk_level": "critical",
            "max_age_days": 90,
            "rotation_required": env("PAYMENT_KEY_AGE_DAYS").number() >= 90
          },
          
          "pii_key": {
            "current_version": env("PII_KEY_VERSION").or("unknown"), 
            "risk_level": "high",
            "max_age_days": 180,
            "rotation_required": env("PII_KEY_AGE_DAYS").number() >= 180
          }
        }

    # Step 5.3: Access control
    - mapping: |
        root = this
        
        let service_role = env("SERVICE_ROLE").or("unknown")
        
        root.access_control_status = {
          "service_role": service_role,
          "access_timestamp": now(),
          "node_id": env("NODE_ID").or("unknown")
        }
        
        # Log access for audit
        meta access_audit_log = {
          "timestamp": now(),
          "service_role": service_role,
          "data_accessed": this.multi_key_metadata.key_tiers_used.keys(),
          "session_id": env("SESSION_ID").or("unknown")
        }

    # Step 5.4: Security analytics
    - mapping: |
        root = this
        
        root.security_posture = {
          "risk_based_encryption": true,
          "multi_tier_architecture": true,
          "total_keys_used": this.multi_key_metadata.key_tiers_used.keys().length(),
          "security_grade": "A"
        }

output:
  file:
    path: "./step-5-output.jsonl"
    codec: "lines"

# Audit trail output for security monitoring  
outputs:
  - label: main_output
    file:
      path: "./step-5-output.jsonl"
      codec: "lines"
      
  - label: security_audit
    processors:
      - mapping: |
          root = meta("access_audit_log").or({})
    file:
      path: "./security-audit-${!timestamp_unix()}.jsonl"
      codec: "lines"

logger:
  level: "INFO"
  add_timestamp: true
```

## Testing Multi-Key Strategy

Deploy and test the multi-key strategy pipeline:

```bash
# Set up multiple key environment variables for testing
export PAYMENT_KEY_VERSION="v2_payment"
export PII_KEY_VERSION="v1_pii"  
export ADDRESS_KEY_VERSION="v1_address"
export TEMPORAL_KEY_VERSION="v1_temporal"

export PAYMENT_KEY_AGE_DAYS="45"  # Within rotation period
export PII_KEY_AGE_DAYS="200"     # Needs rotation

export SERVICE_ROLE="customer_service"
export SESSION_ID="session_12345"

# Deploy the multi-key strategy pipeline
expanso job deploy step-5-multi-key-strategy.yaml

# Verify deployment
expanso job status step-5-multi-key-strategy

# Wait for processing
sleep 3

# Check the multi-key results
echo "Multi-key strategy results:"
cat step-5-output.jsonl | jq '{
  multi_key_architecture: .multi_key_metadata.encryption_architecture,
  key_tiers: .multi_key_metadata.key_tiers_used | keys,
  rotation_status: .key_rotation_status,
  security_grade: .security_posture.security_grade
}'
```

**Expected output structure:**
```json
{
  "multi_key_architecture": "multi_tier_risk_based",
  "key_tiers": ["payment_critical", "pii_high", "location_medium", "temporal_medium"],
  "rotation_status": {
    "payment_key": {
      "current_version": "v2_payment",
      "risk_level": "critical",
      "max_age_days": 90,
      "rotation_required": false
    },
    "pii_key": {
      "current_version": "v1_pii", 
      "risk_level": "high",
      "max_age_days": 180,
      "rotation_required": true
    }
  },
  "security_grade": "A"
}
```

## Production Key Management

### Automated Key Rotation Scripts

```bash title="Automated key rotation implementation"
#!/bin/bash
# Production key rotation script

KEY_TYPE=$1  # payment, pii, address, temporal
NEW_KEY_VERSION=$2

echo "=== Multi-Key Rotation: $KEY_TYPE ==="

case $KEY_TYPE in
  "payment")
    # Generate new payment key
    NEW_KEY=$(openssl rand -hex 32)
    
    # Store in AWS KMS/Vault
    aws kms create-key --description "Payment Key $NEW_KEY_VERSION"
    aws ssm put-parameter \
      --name "/expanso/encryption/payment-key-$NEW_KEY_VERSION" \
      --value "$NEW_KEY" \
      --type "SecureString"
    
    # Update environment with dual keys for transition
    export PAYMENT_ENCRYPTION_KEY_NEW="$NEW_KEY"
    export PAYMENT_KEY_VERSION="$NEW_KEY_VERSION"
    export PAYMENT_KEY_CREATED="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    
    echo "âœ… Payment key rotated to $NEW_KEY_VERSION"
    ;;
    
  "pii")
    # Generate new PII key
    NEW_KEY=$(openssl rand -hex 32)
    
    # Store securely
    vault kv put secret/expanso/encryption/pii-$NEW_KEY_VERSION \
      key="$NEW_KEY" \
      created="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    
    export PII_ENCRYPTION_KEY_NEW="$NEW_KEY"
    export PII_KEY_VERSION="$NEW_KEY_VERSION"
    
    echo "âœ… PII key rotated to $NEW_KEY_VERSION"
    ;;
    
  *)
    echo "âŒ Unknown key type: $KEY_TYPE"
    exit 1
    ;;
esac

# Deploy updated pipeline with new key
echo "Deploying pipeline with new key..."
expanso job deploy step-5-multi-key-strategy.yaml

# Verify new key is working
sleep 5
expanso job logs step-5-multi-key-strategy | grep "key_version.*$NEW_KEY_VERSION"

echo "âœ… Key rotation complete for $KEY_TYPE"
```

### Key Compromise Response

```bash title="Emergency key compromise response"
#!/bin/bash
# Emergency key compromise response script

COMPROMISED_KEY_TYPE=$1
INCIDENT_ID=$2

echo "ðŸš¨ EMERGENCY: Key Compromise Detected"
echo "Key Type: $COMPROMISED_KEY_TYPE"
echo "Incident ID: $INCIDENT_ID"

# Immediate actions
case $COMPROMISED_KEY_TYPE in
  "payment")
    echo "ðŸ”’ Immediately disabling payment processing..."
    
    # Disable payment endpoints
    kubectl patch deployment payment-service -p '{"spec":{"replicas":0}}'
    
    # Generate emergency replacement key
    EMERGENCY_KEY=$(openssl rand -hex 32)
    export PAYMENT_ENCRYPTION_KEY_EMERGENCY="$EMERGENCY_KEY"
    export PAYMENT_KEY_COMPROMISED="true"
    
    # Deploy emergency pipeline
    expanso job deploy step-5-emergency-reencryption.yaml
    
    echo "ðŸ“§ Notifying security team..."
    curl -X POST "$SECURITY_WEBHOOK" -d "{
      \"incident_type\": \"payment_key_compromise\",
      \"incident_id\": \"$INCIDENT_ID\",
      \"immediate_action\": \"payment_processing_disabled\",
      \"reencryption_status\": \"in_progress\"
    }"
    ;;
    
  "pii")
    echo "ðŸ”’ Restricting PII access..."
    
    # Limit customer service access
    export PII_KEY_COMPROMISED="true"
    export CUSTOMER_SERVICE_RESTRICTED="true"
    
    # Generate replacement key
    EMERGENCY_KEY=$(openssl rand -hex 32)
    export PII_ENCRYPTION_KEY_EMERGENCY="$EMERGENCY_KEY"
    ;;
    
  *)
    echo "âŒ Unknown compromised key type: $COMPROMISED_KEY_TYPE"
    exit 1
    ;;
esac

# Log incident for compliance
echo "{
  \"timestamp\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\",
  \"incident_type\": \"encryption_key_compromise\",
  \"incident_id\": \"$INCIDENT_ID\",
  \"key_type\": \"$COMPROMISED_KEY_TYPE\",
  \"response_actions\": [
    \"immediate_key_rotation\",
    \"service_restriction\", 
    \"emergency_reencryption\",
    \"security_team_notification\"
  ],
  \"compliance_notifications\": [
    \"gdpr_72_hour_breach_notification\",
    \"pci_dss_incident_reporting\"
  ]
}" >> /var/log/expanso/security-incidents.jsonl

echo "âœ… Emergency response initiated"
echo "ðŸ“‹ Next steps:"
echo "  1. Monitor re-encryption progress"
echo "  2. Prepare customer notifications" 
echo "  3. File regulatory breach reports"
echo "  4. Conduct post-incident review"
```

## What's Next

You've successfully implemented a comprehensive multi-key encryption strategy with risk-based security architecture! Your encryption system now provides defense in depth with granular access control and automated key management.

**Key accomplishments:**
- âœ… Risk-based multi-tier key architecture (Critical/High/Medium)
- âœ… Automated key rotation monitoring with different schedules by risk level
- âœ… Granular access control restricting decryption by service role
- âœ… Comprehensive security analytics and posture assessment
- âœ… Emergency procedures for key compromise scenarios
- âœ… Production-ready key management and rotation automation
- âœ… Audit trails for all key usage and access operations

**Next step:** [Step 6: Key Rotation & Audit](./step-6-key-rotation-audit) - Implement automated key rotation, comprehensive audit logging, and compliance monitoring for production operations.

---

**Security note:** Multi-key architectures significantly improve security posture but require careful operational procedures. Always test key rotation and emergency procedures in non-production environments before implementing in production systems.
