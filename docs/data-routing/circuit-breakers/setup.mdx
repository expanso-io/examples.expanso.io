---
title: Setup Environment for Circuit Breakers
sidebar_label: Setup
sidebar_position: 2
description: Configure test environment, mock downstream systems, and deploy a shell circuit breaker pipeline
keywords: [setup, environment, circuit-breakers, testing, mock-services]
---

# Setup Environment for Circuit Breakers

Before building circuit breaker patterns, you'll set up a test environment with mock downstream systems that can fail on demand, allowing you to observe circuit breaker behavior.

## Prerequisites

- ✅ Expanso CLI installed ([Installation Guide](https://docs.expanso.io/installation))
- ✅ Docker installed for mock services
- ✅ Basic familiarity with HTTP APIs and databases

## Step 1: Configure Environment Variables

Set up environment variables for connecting to downstream systems:

```bash
# Circuit breaker configuration
export CIRCUIT_BREAKER_TIMEOUT="5s"
export CIRCUIT_BREAKER_RETRIES="3"
export CIRCUIT_BREAKER_RETRY_PERIOD="2s"

# Mock API configuration
export MOCK_API_URL="http://localhost:8081"
export API_TOKEN="test-token"

# Mock database configuration  
export DB_CONNECTION_STRING="postgres://test:test@localhost:5432/circuit_test?sslmode=disable"

# Kafka configuration (for outputs)
export KAFKA_BROKERS="localhost:9092"

# Verify configuration
echo "Circuit breaker timeout: $CIRCUIT_BREAKER_TIMEOUT"
echo "Mock API URL: $MOCK_API_URL"
echo "Database connection: $DB_CONNECTION_STRING"
```

## Step 2: Start Mock Downstream Services

Create mock services that can simulate failures for testing circuit breakers.

### Mock HTTP API Server

Create a simple mock API that can simulate different failure scenarios:

```bash
# Create mock API script
cat > mock-api-server.py << 'EOF'
#!/usr/bin/env python3
import json
import time
import random
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs

class MockAPIHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        path = urlparse(self.path).path
        query = parse_qs(urlparse(self.path).query)
        
        # Simulate different failure modes based on query parameters
        failure_mode = query.get('failure_mode', ['none'])[0]
        
        if failure_mode == 'timeout':
            # Simulate timeout by sleeping longer than circuit breaker timeout
            time.sleep(10)
        elif failure_mode == 'slow':
            # Simulate slow response
            time.sleep(3)
        elif failure_mode == 'error':
            # Simulate HTTP error
            self.send_response(500)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({"error": "Internal server error"}).encode())
            return
        elif failure_mode == 'intermittent':
            # Randomly fail 50% of requests
            if random.random() < 0.5:
                self.send_response(500)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps({"error": "Random failure"}).encode())
                return
        
        # Successful response
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        
        # Extract sensor_id from path if present
        sensor_id = path.split('/')[-1] if path != '/' else 'unknown'
        
        response = {
            "sensor_id": sensor_id,
            "metadata": {
                "location": "Building A, Floor 2",
                "device_type": "temperature_sensor",
                "last_calibration": "2024-01-15T10:00:00Z"
            },
            "status": "healthy",
            "timestamp": time.strftime('%Y-%m-%dT%H:%M:%SZ')
        }
        
        self.wfile.write(json.dumps(response).encode())
    
    def do_POST(self):
        # Handle POST requests for processing
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = self.rfile.read(content_length)
        
        # Parse failure mode from headers or body
        failure_mode = self.headers.get('X-Failure-Mode', 'none')
        
        if failure_mode == 'timeout':
            time.sleep(10)
        elif failure_mode == 'error':
            self.send_response(503)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({"error": "Service unavailable"}).encode())
            return
        
        # Successful response
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        
        response = {
            "processed": True,
            "received_data": post_data.decode() if post_data else None,
            "timestamp": time.strftime('%Y-%m-%dT%H:%M:%SZ')
        }
        
        self.wfile.write(json.dumps(response).encode())
    
    def log_message(self, format, *args):
        print(f"[MOCK API] {format % args}")

if __name__ == '__main__':
    server = HTTPServer(('localhost', 8081), MockAPIHandler)
    print("Mock API server started on http://localhost:8081")
    print("Failure modes:")
    print("  - ?failure_mode=timeout (10s delay)")
    print("  - ?failure_mode=slow (3s delay)")
    print("  - ?failure_mode=error (500 error)")
    print("  - ?failure_mode=intermittent (random failures)")
    server.serve_forever()
EOF

# Make executable and start
chmod +x mock-api-server.py
python3 mock-api-server.py &
MOCK_API_PID=$!
echo "Mock API started with PID: $MOCK_API_PID"
```

### Mock Database with Docker

Start a PostgreSQL container for database circuit breaker testing:

```bash
# Start PostgreSQL container
docker run -d \
  --name circuit-test-db \
  -e POSTGRES_USER=test \
  -e POSTGRES_PASSWORD=test \
  -e POSTGRES_DB=circuit_test \
  -p 5432:5432 \
  postgres:13-alpine

# Wait for database to be ready
echo "Waiting for database to be ready..."
sleep 10

# Create test table and data
docker exec circuit-test-db psql -U test -d circuit_test -c "
  CREATE TABLE IF NOT EXISTS users (
    user_id VARCHAR(50) PRIMARY KEY,
    user_name VARCHAR(100),
    user_tier VARCHAR(20),
    account_type VARCHAR(30),
    created_at TIMESTAMP DEFAULT NOW()
  );

  INSERT INTO users (user_id, user_name, user_tier, account_type) VALUES
    ('user_001', 'Alice Johnson', 'premium', 'business'),
    ('user_002', 'Bob Smith', 'standard', 'personal'),
    ('user_003', 'Carol Brown', 'enterprise', 'business'),
    ('user_004', 'David Wilson', 'premium', 'personal'),
    ('user_005', 'Eve Davis', 'standard', 'business')
  ON CONFLICT (user_id) DO NOTHING;
"

echo "Database setup complete"
```

### Start Kafka with Docker (Optional)

If you need Kafka for output testing:

```bash
# Start Kafka and Zookeeper
docker run -d \
  --name circuit-test-zookeeper \
  -p 2181:2181 \
  -e ZOOKEEPER_CLIENT_PORT=2181 \
  confluentinc/cp-zookeeper:latest

docker run -d \
  --name circuit-test-kafka \
  -p 9092:9092 \
  -e KAFKA_ZOOKEEPER_CONNECT=localhost:2181 \
  -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092 \
  -e KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1 \
  confluentinc/cp-kafka:latest

echo "Kafka setup complete (optional)"
```

## Step 3: Deploy Shell Circuit Breaker Pipeline

Before adding full circuit breaker logic, deploy a minimal "shell" pipeline that just processes data without downstream calls. This verifies your setup works.

Create `shell-circuit-breaker.yaml`:

```yaml title="shell-circuit-breaker.yaml"
name: shell-circuit-breaker
description: Basic pipeline to verify setup before adding circuit breakers
type: pipeline
namespace: circuit-breaker-test

config:
  input:
    http_server:
      address: 0.0.0.0:8080
      path: /events
      timeout: 30s

  pipeline:
    processors:
      # Basic validation
      - mapping: |
          root = this
          root.processed_at = now()
          root.setup_test = true
          if !this.exists() {
            throw("empty payload received")
          }

      # Log for verification
      - log:
          level: INFO
          message: "Shell pipeline processed: ${!this.id || this.sensor_id || 'unknown'}"

  output:
    # Simple stdout for testing
    stdout:
      codec: lines
```

Deploy the shell pipeline:

```bash
# Deploy to Expanso
expanso apply -f shell-circuit-breaker.yaml

# Verify deployment
expanso get pipeline shell-circuit-breaker
```

**Expected output:**
```
NAME                  STATUS    NAMESPACE               REPLICAS
shell-circuit-breaker Running   circuit-breaker-test    1/1
```

## Step 4: Test Shell Pipeline

Test the basic pipeline to ensure your environment is working:

```bash
# Test with sample data
curl -X POST http://localhost:8080/events \
  -H "Content-Type: application/json" \
  -d '{
    "sensor_id": "temp_001",
    "temperature": 23.5,
    "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
    "location": "lab_a"
  }'

# Check the logs
expanso logs pipeline shell-circuit-breaker --tail=20
```

**Expected output:**
```json
{"processed_at":"2024-01-15T14:30:15.123456Z","setup_test":true,"sensor_id":"temp_001","temperature":23.5,"timestamp":"2024-01-15T14:30:10Z","location":"lab_a"}
```

:::tip Success!
If you see the processed JSON output with `"setup_test": true`, your environment is correctly configured!

**Next step:** Continue to Step 1 to implement HTTP circuit breakers
:::

## Step 5: Test Mock Services

Verify your mock services are responding correctly:

### Test Mock API

```bash
# Test normal response
curl "http://localhost:8081/metadata/sensor_001"

# Test timeout simulation (this will timeout)
curl --max-time 3 "http://localhost:8081/metadata/sensor_001?failure_mode=timeout" || echo "Timeout as expected"

# Test error simulation
curl "http://localhost:8081/metadata/sensor_001?failure_mode=error"

# Test slow response
time curl "http://localhost:8081/metadata/sensor_001?failure_mode=slow"
```

### Test Mock Database

```bash
# Test database connection
docker exec circuit-test-db psql -U test -d circuit_test -c "SELECT user_id, user_name FROM users LIMIT 3;"
```

**Expected output:**
```
 user_id | user_name   
---------+-------------
 user_001| Alice Johnson
 user_002| Bob Smith
 user_003| Carol Brown
```

### Test Failure Scenarios

```bash
# Simulate database failure by stopping container
docker stop circuit-test-db
echo "Database stopped - this will cause connection failures"

# Restart for next steps
docker start circuit-test-db
sleep 5
echo "Database restarted"
```

## Step 6: Verify Prerequisites

Before proceeding, verify all required components are ready:

```bash
# Run this verification script
cat > verify-setup.sh << 'EOF'
#!/bin/bash

echo "=== Circuit Breaker Setup Verification ==="

# Check Expanso CLI
if command -v expanso &> /dev/null; then
    echo "✅ Expanso CLI is installed"
else
    echo "❌ Expanso CLI not found"
    exit 1
fi

# Check environment variables
for var in CIRCUIT_BREAKER_TIMEOUT MOCK_API_URL DB_CONNECTION_STRING; do
    if [ ! -z "${!var}" ]; then
        echo "✅ $var is set"
    else
        echo "❌ $var is not set"
        exit 1
    fi
done

# Check mock API
if curl -s --max-time 2 "$MOCK_API_URL/health" > /dev/null 2>&1; then
    echo "✅ Mock API is responding"
else
    echo "❌ Mock API not responding on $MOCK_API_URL"
fi

# Check database
if docker exec circuit-test-db psql -U test -d circuit_test -c "SELECT 1;" > /dev/null 2>&1; then
    echo "✅ Database is accessible"
else
    echo "❌ Database not accessible"
fi

# Check pipeline
if expanso get pipeline shell-circuit-breaker > /dev/null 2>&1; then
    echo "✅ Shell pipeline is deployed"
else
    echo "❌ Shell pipeline not found"
fi

echo ""
echo "Setup verification complete!"
echo "Ready to proceed to Step 1: HTTP Circuit Breakers"
EOF

chmod +x verify-setup.sh
./verify-setup.sh
```

## Cleanup (When Done)

When you're finished with the tutorial, clean up the test environment:

```bash
# Stop and remove containers
docker stop circuit-test-db circuit-test-zookeeper circuit-test-kafka 2>/dev/null
docker rm circuit-test-db circuit-test-zookeeper circuit-test-kafka 2>/dev/null

# Stop mock API
kill $MOCK_API_PID 2>/dev/null

# Remove pipeline
expanso delete pipeline shell-circuit-breaker

echo "Cleanup complete"
```

---

**Next:** [Step 1: HTTP Circuit Breakers](./step-1-http-circuit-breakers) - Implement circuit breaker protection for HTTP APIs
