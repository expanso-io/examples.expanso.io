---
title: Step 3 - Multi-Criteria Priority Scoring
sidebar_label: Step 3 - Multi-Criteria Scoring
sidebar_position: 6
description: Build sophisticated priority scoring that combines severity, customer tier, event type, urgency, and business context
keywords: [multi-criteria, scoring, priority, algorithm, weighted, event-type, urgency, business-context]
---

# Step 3: Multi-Criteria Priority Scoring

**Master complex prioritization with sophisticated scoring algorithms.** This step implements a weighted scoring system that considers multiple factors—severity, customer tier, event type, urgency, and business context—to make nuanced routing decisions that align with business priorities.

## Why Multi-Criteria Scoring Is Essential

Real-world prioritization rarely depends on a single factor. A routine ERROR from an enterprise customer's payment system deserves higher priority than a CRITICAL log from a free user's analytics service. Similarly, an authentication failure during business hours needs faster handling than the same event at 3 AM. Multi-criteria scoring addresses these nuances:

- **Business-aligned prioritization** that considers customer value and event impact
- **Context-aware routing** that adapts to time, service criticality, and operational state
- **Sophisticated decision making** that balances multiple competing priorities
- **Transparent scoring** that can be audited and tuned based on business outcomes

## The Advanced Transformation

**Before (Simple Tier + Severity):**
```json
{
  "severity": "WARNING",            // ❌ Simple mapping: WARNING → normal priority
  "customer_tier": "enterprise",    // ❌ Basic boost: enterprise → high priority  
  "priority": "high"                // ❌ Limited context, ignores event nuance
}
```

**After (Multi-Criteria Scoring):**
```json
{
  "severity": "WARNING",            // ✅ Base score: 30 points
  "customer_tier": "enterprise",    // ✅ Multiplier: 3.0x = 90 points
  "event_type": "auth.failure",     // ✅ Boost: +25 points = 115 points
  "urgency": "high",               // ✅ Boost: +15 points = 130 points
  "business_hours": true,          // ✅ Boost: +10 points = 140 points
  "service_criticality": "core",   // ✅ Boost: +20 points = 160 points
  "priority_score": 160,           // ✅ Final calculated score
  "priority": "critical",          // ✅ Score-based routing: 160 → critical
  "score_breakdown": {...}         // ✅ Transparent decision audit trail
}
```

## Implementation

Enhance your tier-based pipeline with sophisticated multi-criteria scoring:

```yaml title="multi-criteria-priority-queues.yaml"
name: multi-criteria-priority-queues
description: Priority routing based on event type, customer tier, severity, urgency, and business context
type: pipeline
namespace: production

config:
  input:
    http_server:
      address: 0.0.0.0:8080
      path: /events
      timeout: 5s

  pipeline:
    processors:
      # Step 1: Parse and validate incoming events
      - json_documents:
          parts: []

      # Step 2: Comprehensive multi-criteria priority scoring
      - mapping: |
          root = this

          # === FIELD NORMALIZATION ===
          # Extract and normalize all priority factors
          root.severity = this.severity.or("INFO").string().uppercase()
          root.customer_tier = this.customer_tier.or(this.user.subscription_plan.or("free")).lowercase()
          root.event_type = this.event_type.or(this.type.or("unknown")).lowercase()
          root.urgency = this.urgency.or("normal").lowercase()
          root.service = this.service.or(this.source_service.or("unknown")).lowercase()
          
          # Extract temporal and operational context
          let current_hour = now().hour()
          let current_day = now().day()  # 0=Sunday, 1=Monday, etc.
          root.business_hours = current_hour >= 9 && current_hour < 17 && current_day >= 1 && current_day <= 5
          root.weekend = current_day == 0 || current_day == 6

          # === SEVERITY SCORING (Base: 0-100 points) ===
          let severity_score = match root.severity {
            "CRITICAL" => 85       # Critical system failures
            "FATAL" => 85          # Application crashes
            "ERROR" => 60          # Error conditions requiring attention
            "WARNING" => 35        # Warnings that should be reviewed
            "WARN" => 35           # Alternative warning format
            "INFO" => 15           # Informational messages
            "DEBUG" => 8           # Debug information
            "TRACE" => 5           # Detailed trace information
            _ => 20                # Unknown severity default
          }

          # === CUSTOMER TIER MULTIPLIER (0.5x - 4.0x) ===
          let tier_multiplier = match root.customer_tier {
            "enterprise" => 4.0    # Enterprise gets maximum boost
            "premium" => 3.0       # Premium tier significant boost
            "pro" => 2.5           # Pro tier moderate boost
            "standard" => 2.0      # Standard tier slight boost
            "basic" => 1.5         # Basic tier minimal boost
            "free" => 1.0          # Free tier no boost
            "trial" => 0.8         # Trial tier slight penalty
            "suspended" => 0.5     # Suspended accounts low priority
            _ => 1.0               # Unknown tier default
          }

          # === EVENT TYPE SCORING (+0 to +50 points) ===
          let event_type_score = match {
            # Security events get highest priority
            root.event_type.has_prefix("security.") => 50
            root.event_type.has_prefix("auth.") => 45
            root.event_type.has_prefix("fraud.") => 45
            
            # Business-critical payment events
            root.event_type.has_prefix("payment.failed") => 40
            root.event_type.has_prefix("payment.disputed") => 35
            root.event_type.has_prefix("payment.") => 25
            
            # Billing and subscription events
            root.event_type.has_prefix("billing.failed") => 35
            root.event_type.has_prefix("subscription.") => 20
            
            # API and system events
            root.event_type.has_prefix("api.error") => 30
            root.event_type.has_prefix("system.") => 25
            root.event_type.has_prefix("database.") => 30
            
            # User experience events
            root.event_type.has_prefix("user.login") => 20
            root.event_type.has_prefix("user.") => 15
            
            # Analytics and tracking (lowest priority)
            root.event_type.has_prefix("analytics.") => 5
            root.event_type.has_prefix("tracking.") => 3
            root.event_type.has_prefix("metrics.") => 8
            
            _ => 10                # Default for unknown event types
          }

          # === URGENCY SCORING (+0 to +20 points) ===
          let urgency_score = match root.urgency {
            "critical" => 20       # User-specified critical urgency
            "high" => 15           # High urgency
            "normal" => 5          # Normal urgency (default)
            "low" => 0             # Low urgency
            "deferred" => -5       # Can be deferred (negative score)
            _ => 5                 # Default urgency
          }

          # === SERVICE CRITICALITY SCORING (+0 to +30 points) ===
          let service_criticality_score = match root.service {
            # Core business services
            "auth-service" => 30          # Authentication is critical
            "payment-service" => 30       # Payment processing critical
            "billing-service" => 25       # Billing important
            "user-service" => 25          # User management important
            "api-gateway" => 25           # Gateway important
            
            # Supporting services
            "notification-service" => 20  # Notifications important
            "email-service" => 15         # Email moderately important
            "search-service" => 15        # Search moderately important
            
            # Operational services
            "logging-service" => 10       # Logging useful but not critical
            "metrics-service" => 8        # Metrics useful
            "analytics-service" => 5      # Analytics least critical
            
            _ => 12                       # Default for unknown services
          }

          # === TEMPORAL CONTEXT SCORING (+0 to +15 points) ===
          let temporal_score = match {
            root.business_hours => 15     # Business hours get priority boost
            root.weekend => -5            # Weekend events slightly deprioritized
            current_hour >= 22 || current_hour <= 6 => -3  # Night hours deprioritized
            _ => 0                        # Standard hours
          }

          # === FREQUENCY-BASED ADJUSTMENT (anti-spam) ===
          # Note: In production, you'd track this in external state store
          # This is a simplified version for demonstration
          let frequency_penalty = match {
            root.event_type == "user.pageview" => -5      # Common events get penalty
            root.event_type == "analytics.click" => -5    # High-frequency analytics
            root.event_type == "metrics.heartbeat" => -8  # Very frequent metrics
            _ => 0
          }

          # === CALCULATE FINAL PRIORITY SCORE ===
          let base_score = severity_score * tier_multiplier
          let bonus_score = event_type_score + urgency_score + service_criticality_score + temporal_score
          let adjusted_score = base_score + bonus_score + frequency_penalty
          
          root.priority_score = if adjusted_score < 0 { 0 } else { adjusted_score.round() }

          # === MAP SCORE TO PRIORITY TIER ===
          root.priority = match {
            root.priority_score >= 200 => "critical"      # Enterprise critical events during business hours
            root.priority_score >= 120 => "high"          # Premium important events or enterprise routine
            root.priority_score >= 60 => "normal"         # Standard events or lower tier important
            root.priority_score >= 20 => "low"            # Routine events
            _ => "bulk"                                    # Very low priority bulk processing
          }

          # === ADD COMPREHENSIVE AUDIT TRAIL ===
          root.scoring_breakdown = {
            "severity": {
              "value": root.severity,
              "score": severity_score
            },
            "customer_tier": {
              "value": root.customer_tier,
              "multiplier": tier_multiplier,
              "weighted_score": severity_score * tier_multiplier
            },
            "event_type": {
              "value": root.event_type,
              "score": event_type_score
            },
            "urgency": {
              "value": root.urgency,
              "score": urgency_score
            },
            "service": {
              "value": root.service,
              "criticality_score": service_criticality_score
            },
            "temporal": {
              "business_hours": root.business_hours,
              "weekend": root.weekend,
              "current_hour": current_hour,
              "score": temporal_score
            },
            "frequency_penalty": frequency_penalty,
            "final_calculation": {
              "base_score": base_score,
              "bonus_score": bonus_score,
              "frequency_adjustment": frequency_penalty,
              "final_score": root.priority_score,
              "assigned_priority": root.priority
            }
          }

          # === ADD SLA AND PROCESSING METADATA ===
          root.sla_target_ms = match root.priority {
            "critical" => 100      # Critical events: 100ms SLA
            "high" => 500          # High priority: 500ms SLA
            "normal" => 2000       # Normal: 2s SLA
            "low" => 10000         # Low: 10s SLA
            "bulk" => 60000        # Bulk: 1 minute SLA
            _ => 5000              # Default: 5s SLA
          }

          # Add processing metadata
          root.processed_at = now()
          root.edge_node_id = env("NODE_ID").or("unknown")
          root.routing_strategy = "multi-criteria-scoring-v2"

  output:
    switch:
      cases:
        # Case 1: Critical priority (score >= 200)
        - check: this.priority == "critical"
          output:
            label: critical_priority_queue
            kafka:
              addresses: ["${KAFKA_BROKERS}"]
              topic: critical-priority-events
              
              # Immediate delivery for critical events
              batching:
                count: 1
                period: 0s
              
              # Maximum reliability configuration
              max_in_flight: 1
              ack_replicas: true
              idempotent_write: true
              max_retries: 12
              
              backoff:
                initial_interval: 50ms
                max_interval: 1s
              
              compression: none      # No compression for minimum latency

        # Case 2: High priority (score 120-199)
        - check: this.priority == "high"
          output:
            label: high_priority_queue
            kafka:
              addresses: ["${KAFKA_BROKERS}"]
              topic: high-priority-events
              
              # Small batches for fast delivery
              batching:
                count: 15
                period: 2s
              
              max_in_flight: 5
              ack_replicas: true
              max_retries: 8
              
              backoff:
                initial_interval: 200ms
                max_interval: 3s
              
              compression: snappy

        # Case 3: Normal priority (score 60-119)
        - check: this.priority == "normal"
          output:
            label: normal_priority_queue
            kafka:
              addresses: ["${KAFKA_BROKERS}"]
              topic: normal-priority-events
              
              # Balanced batching
              batching:
                count: 75
                period: 8s
              
              max_in_flight: 10
              max_retries: 5
              
              backoff:
                initial_interval: 1s
                max_interval: 8s
              
              compression: snappy

        # Case 4: Low priority (score 20-59)
        - check: this.priority == "low"
          output:
            label: low_priority_queue
            kafka:
              addresses: ["${KAFKA_BROKERS}"]
              topic: low-priority-events
              
              # Larger batches for efficiency
              batching:
                count: 500
                period: 30s
              
              max_in_flight: 15
              max_retries: 3
              
              compression: snappy

        # Case 5: Bulk processing (score < 20)
        - check: this.priority == "bulk"
          output:
            label: bulk_priority_queue
            kafka:
              addresses: ["${KAFKA_BROKERS}"]
              topic: bulk-priority-events
              
              # Very large batches for maximum efficiency
              batching:
                count: 2000
                period: 5m
              
              max_in_flight: 25
              max_retries: 1
              
              compression: gzip

        # Default: Normal processing
        - output:
            kafka:
              addresses: ["${KAFKA_BROKERS}"]
              topic: normal-priority-events
              batching:
                count: 75
                period: 8s
```

## Deploy and Test Multi-Criteria Scoring

Deploy the advanced scoring pipeline:

```bash
# Deploy the multi-criteria pipeline
expanso pipeline deploy multi-criteria-priority-queues.yaml

# Verify deployment
expanso pipeline status multi-criteria-priority-queues
```

Test sophisticated scoring scenarios:

```bash
# Scenario 1: Enterprise payment failure during business hours (should score very high)
curl -X POST http://localhost:8080/events \
  -H "Content-Type: application/json" \
  -d '{
    "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
    "event_type": "payment.failed",
    "severity": "ERROR",
    "urgency": "critical",
    "customer_tier": "enterprise",
    "service": "payment-service",
    "message": "Payment processing failed for enterprise customer",
    "customer_id": "enterprise_123",
    "amount": 100000
  }'

# Scenario 2: Free tier analytics event (should score low)
curl -X POST http://localhost:8080/events \
  -H "Content-Type: application/json" \
  -d '{
    "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
    "event_type": "analytics.pageview",
    "severity": "INFO",
    "urgency": "low",
    "customer_tier": "free",
    "service": "analytics-service",
    "message": "Page view recorded",
    "page": "/dashboard"
  }'

# Scenario 3: Premium auth failure (moderately high priority)
curl -X POST http://localhost:8080/events \
  -H "Content-Type: application/json" \
  -d '{
    "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
    "event_type": "auth.failure",
    "severity": "WARNING",
    "urgency": "high",
    "customer_tier": "premium",
    "service": "auth-service",
    "message": "Authentication failed for premium user",
    "user_id": "premium_user_456",
    "failure_reason": "invalid_password"
  }'

# Scenario 4: Standard database warning at night (should be deprioritized)
curl -X POST http://localhost:8080/events \
  -H "Content-Type: application/json" \
  -d '{
    "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
    "event_type": "database.slow_query",
    "severity": "WARNING", 
    "urgency": "normal",
    "customer_tier": "standard",
    "service": "database",
    "message": "Slow query detected during off-hours",
    "query_time": 2.5
  }'
```

## Analyze Scoring Decisions

Create a script to analyze and visualize the scoring decisions:

```bash
# Create scoring analysis script
cat << 'EOF' > analyze-scoring.py
#!/usr/bin/env python3
import json
import subprocess
import sys

def get_recent_messages(topic, count=10):
    """Get recent messages from Kafka topic"""
    cmd = [
        f"{os.environ.get('KAFKA_HOME', '/opt/kafka')}/bin/kafka-console-consumer.sh",
        "--bootstrap-server", os.environ.get('KAFKA_BROKERS', 'localhost:9092'),
        "--topic", topic,
        "--from-beginning",
        f"--max-messages", str(count)
    ]
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
        messages = []
        for line in result.stdout.strip().split('\n'):
            if line:
                try:
                    messages.append(json.loads(line))
                except json.JSONDecodeError:
                    continue
        return messages
    except subprocess.TimeoutExpired:
        return []

def analyze_scoring(messages):
    """Analyze scoring decisions"""
    print("=== SCORING ANALYSIS ===\n")
    
    for msg in messages:
        if 'scoring_breakdown' not in msg:
            continue
            
        breakdown = msg['scoring_breakdown']
        print(f"Event: {msg.get('event_type', 'unknown')}")
        print(f"Customer: {msg.get('customer_tier', 'unknown')}")
        print(f"Final Priority: {msg.get('priority', 'unknown')} (score: {msg.get('priority_score', 0)})")
        print()
        
        # Show scoring components
        print(f"  Severity: {breakdown['severity']['value']} → {breakdown['severity']['score']} points")
        print(f"  Customer Tier: {breakdown['customer_tier']['value']} → {breakdown['customer_tier']['multiplier']}x multiplier")
        print(f"  Event Type: {breakdown['event_type']['value']} → +{breakdown['event_type']['score']} points")
        print(f"  Urgency: {breakdown['urgency']['value']} → +{breakdown['urgency']['score']} points")
        print(f"  Service: {breakdown['service']['value']} → +{breakdown['service']['criticality_score']} points")
        print(f"  Temporal: Business hours={breakdown['temporal']['business_hours']} → {breakdown['temporal']['score']} points")
        
        if 'frequency_penalty' in breakdown:
            print(f"  Frequency Penalty: {breakdown['frequency_penalty']} points")
        
        print(f"  Final Calculation: {breakdown['final_calculation']['base_score']} + {breakdown['final_calculation']['bonus_score']} = {breakdown['final_calculation']['final_score']}")
        print("-" * 80)

if __name__ == "__main__":
    import os
    
    # Analyze messages from each priority queue
    for priority in ['critical', 'high', 'normal', 'low', 'bulk']:
        topic = f"{priority}-priority-events"
        print(f"\n=== {priority.upper()} PRIORITY QUEUE ===")
        messages = get_recent_messages(topic, 5)
        if messages:
            analyze_scoring(messages)
        else:
            print("No messages found")
            
EOF

chmod +x analyze-scoring.py
python3 analyze-scoring.py
```

## Advanced Scoring Strategies

### Strategy 1: Machine Learning-Enhanced Scoring

Use historical data to improve scoring accuracy:

```bloblang
# ML-enhanced scoring (conceptual - requires external ML service)
let ml_score = if env("ML_SCORING_ENABLED") == "true" {
  # Call ML service for enhanced scoring
  http_client(
    env("ML_SCORING_URL"),
    {"timeout": "100ms", "verb": "POST"}, 
    {
      "event_type": root.event_type,
      "customer_tier": root.customer_tier,
      "severity": root.severity,
      "historical_context": this.without("message", "details")
    }
  ).score.or(0)
} else {
  0
}

# Blend traditional scoring with ML insights
root.priority_score = (root.priority_score * 0.8) + (ml_score * 0.2)
```

### Strategy 2: Dynamic Scoring Based on System Load

Adjust priorities based on current system capacity:

```bloblang
# System load-based adjustments
let system_load = http_client(
  "http://monitoring.internal/api/load",
  {"timeout": "50ms", "verb": "GET"}
).cpu_utilization.or(50)

# Under high load, be more selective about high priorities
let load_adjustment = match {
  system_load > 80 => -10      # Reduce priority scores when overloaded
  system_load < 30 => 5        # Boost priorities when underloaded
  _ => 0
}

root.priority_score = root.priority_score + load_adjustment
```

### Strategy 3: Customer Journey-Aware Scoring

Boost priority based on customer lifecycle stage:

```bloblang
# Customer journey context
let journey_stage = this.user.lifecycle_stage.or("active").lowercase()

let journey_boost = match journey_stage {
  "onboarding" => 15           # New customers get priority
  "trial_ending" => 20         # Trial users about to convert
  "at_risk" => 25              # Customers showing churn signals
  "vip" => 30                  # VIP customers
  "churned" => -20             # Churned customers deprioritized
  _ => 0
}

# Apply journey boost
root.priority_score = root.priority_score + journey_boost
```

## Performance Tuning by Score Ranges

Fine-tune processing characteristics based on score distributions:

| Score Range | Priority | Processing Strategy | Batching | Target SLA |
|-------------|----------|-------------------|----------|------------|
| 200+ | Critical | Immediate, maximum reliability | 1 msg, 0s | <100ms |
| 120-199 | High | Fast lanes, strong guarantees | 15 msgs, 2s | <500ms |
| 60-119 | Normal | Balanced efficiency | 75 msgs, 8s | <2s |
| 20-59 | Low | Throughput optimized | 500 msgs, 30s | <10s |
| 0-19 | Bulk | Maximum efficiency | 2000 msgs, 5m | <1m |

## Monitoring Multi-Criteria Scoring

### Score Distribution Analysis

Monitor how events distribute across score ranges:

```bash
# Create scoring dashboard script
cat << 'EOF' > scoring-dashboard.sh
#!/bin/bash

echo "=== PRIORITY SCORING DASHBOARD ==="
echo "Generated at: $(date)"
echo

# Get message counts by priority queue
echo "Message Distribution by Priority:"
for priority in critical high normal low bulk; do
  topic="${priority}-priority-events"
  count=$(curl -s http://localhost:8081/metrics | grep "output_sent_total.*${priority}_priority_queue" | awk '{print $2}' | tail -1)
  printf "  %-10s: %8s messages\n" "$priority" "${count:-0}"
done

echo
echo "Average Latency by Priority:"
curl -s http://localhost:8081/metrics | grep 'output_latency.*priority_queue' | while read line; do
  if [[ $line == *"critical"* ]]; then
    echo "  Critical:  $(echo $line | awk '{print $2}')ms"
  elif [[ $line == *"high"* ]]; then
    echo "  High:      $(echo $line | awk '{print $2}')ms"
  elif [[ $line == *"normal"* ]]; then
    echo "  Normal:    $(echo $line | awk '{print $2}')ms"
  elif [[ $line == *"low"* ]]; then
    echo "  Low:       $(echo $line | awk '{print $2}')ms"
  fi
done

echo
echo "Recent High-Priority Events:"
timeout 5s $KAFKA_HOME/bin/kafka-console-consumer.sh \
  --bootstrap-server $KAFKA_BROKERS \
  --topic critical-priority-events \
  --from-beginning \
  --max-messages 3 | jq -r '"\(.timestamp) \(.customer_tier) \(.event_type) score:\(.priority_score)"'

EOF

chmod +x scoring-dashboard.sh
./scoring-dashboard.sh
```

### Scoring Accuracy Monitoring

Track whether scoring decisions align with business outcomes:

```bloblang
# Add scoring validation metadata
root.scoring_validation = {
  "decision_timestamp": now(),
  "score": root.priority_score,
  "assigned_priority": root.priority,
  "expected_impact": match root.priority {
    "critical" => "immediate_attention_required"
    "high" => "review_within_hours"
    "normal" => "review_within_day"
    _ => "batch_processing_acceptable"
  }
}

# Add business outcome tracking placeholders
root.outcome_tracking = {
  "requires_followup": root.priority == "critical" || root.priority == "high",
  "escalation_path": match root.priority {
    "critical" => "pagerduty_immediate"
    "high" => "slack_ops_channel"
    _ => "dashboard_monitoring"
  }
}
```

## Troubleshooting Multi-Criteria Scoring

### Issue: Unexpected Priority Classifications

**Symptom:** Events getting classified differently than expected.

**Solution:** Enable detailed scoring breakdown logging:

```bloblang
# Enhanced debugging for scoring decisions
root.debug_scoring = {
  "input_factors": {
    "severity": this.severity,
    "customer_tier": this.customer_tier,
    "event_type": this.event_type,
    "urgency": this.urgency,
    "service": this.service
  },
  "calculated_scores": {
    "severity_base": severity_score,
    "tier_multiplier": tier_multiplier,
    "event_type_boost": event_type_score,
    "urgency_boost": urgency_score,
    "service_boost": service_criticality_score,
    "temporal_adjustment": temporal_score,
    "frequency_penalty": frequency_penalty
  },
  "decision_path": {
    "base_calculation": severity_score * tier_multiplier,
    "with_bonuses": base_score + bonus_score,
    "final_score": root.priority_score,
    "priority_thresholds": {
      "critical": ">=200",
      "high": "120-199", 
      "normal": "60-119",
      "low": "20-59",
      "bulk": "<20"
    }
  }
}
```

### Issue: Score Inflation

**Symptom:** Most events getting high scores, defeating the purpose of prioritization.

**Solution:** Recalibrate scoring weights:

```bloblang
# More conservative scoring to prevent inflation
let severity_score = match root.severity {
  "CRITICAL" => 50    # Reduced from 85
  "FATAL" => 50       # Reduced from 85
  "ERROR" => 35       # Reduced from 60
  "WARNING" => 20     # Reduced from 35
  _ => 10             # Reduced defaults
}

# More selective tier multipliers
let tier_multiplier = match root.customer_tier {
  "enterprise" => 2.5  # Reduced from 4.0
  "premium" => 2.0     # Reduced from 3.0
  "pro" => 1.8         # Reduced from 2.5
  _ => 1.0
}
```

### Issue: Business Hours Not Detected Correctly

**Symptom:** Temporal scoring not working due to timezone issues.

**Solution:** Add explicit timezone handling:

```bloblang
# Timezone-aware business hours detection
let user_timezone = this.user.timezone.or(this.timezone.or("UTC"))
let local_time = now().format_timestamp("15:04", user_timezone)
let local_hour = local_time[0:2].number()

# Business hours in user's timezone
root.business_hours_local = local_hour >= 9 && local_hour < 17

# Use local business hours for scoring
let temporal_score = match {
  root.business_hours_local => 15
  local_hour >= 22 || local_hour <= 6 => -3
  _ => 0
}
```

## Security and Compliance

### Audit Trail for Priority Decisions

Maintain comprehensive audit trails for compliance:

```bloblang
# Comprehensive audit trail
root.priority_audit = {
  "decision_id": uuid_v4(),
  "timestamp": now(),
  "edge_node": env("NODE_ID"),
  "pipeline_version": "multi-criteria-v2",
  "input_factors": {
    "customer_tier": root.customer_tier,
    "event_type": root.event_type,
    "severity": root.severity,
    "urgency": root.urgency,
    "service": root.service
  },
  "scoring_algorithm": "weighted_multi_criteria",
  "final_decision": {
    "priority_score": root.priority_score,
    "assigned_priority": root.priority,
    "routing_destination": match root.priority {
      "critical" => "critical-priority-events"
      "high" => "high-priority-events"
      _ => "normal-priority-events"
    }
  },
  "compliance_metadata": {
    "data_classification": "operational",
    "processing_justification": "business_priority_optimization",
    "retention_policy": "audit_trail_1yr"
  }
}
```

## Next Steps

With multi-criteria scoring implemented, you now have:

✅ **Sophisticated prioritization** combining 6+ factors for nuanced routing decisions
✅ **Business-aligned scoring** that considers customer value, event impact, and operational context
✅ **Transparent decision making** with comprehensive audit trails and scoring breakdowns
✅ **Tunable algorithms** that can be adjusted based on business outcomes and system performance
✅ **Context-aware routing** that adapts to time of day, service criticality, and customer journey

**Next:** Implement age-based priority escalation to prevent starvation of low-priority messages.

<div style={{display: 'flex', gap: '1rem', marginTop: '2rem', marginBottom: '2rem', flexWrap: 'wrap'}}>
  <a href="./step-4-prevent-starvation" className="button button--primary button--lg" style={{flex: '1', minWidth: '200px'}}>
    Step 4: Prevent Starvation
  </a>
  <a href="./troubleshooting" className="button button--secondary button--lg" style={{flex: '1', minWidth: '200px'}}>
    Troubleshooting Guide
  </a>
</div>

## What You Built

This step added sophisticated multi-criteria scoring that considers:

- **Severity levels** with weighted base scores (5-85 points)
- **Customer tiers** with multiplication factors (0.5x-4.0x)  
- **Event types** with business impact bonuses (+0 to +50 points)
- **Urgency levels** with explicit priority boosts (+0 to +20 points)
- **Service criticality** based on business importance (+0 to +30 points)
- **Temporal context** for business hours and operational windows (+/- 15 points)

The result is a comprehensive scoring system (0-300+ points) that routes messages with business-aligned priority decisions and full audit transparency.
