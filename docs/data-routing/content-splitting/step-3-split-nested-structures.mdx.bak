---
title: "Step 3: Split Nested Structures"
sidebar_label: "Step 3: Split Nested Structures"
sidebar_position: 6
description: Handle complex nested JSON with multi-level context preservation and hierarchical data splitting
keywords: [nested-json, hierarchical-data, e-commerce, order-processing, inventory-management, complex-structures]
---

# Step 3: Split Nested Structures

**Master complex nested JSON splitting while preserving hierarchical context across multiple levels.** This advanced technique is essential for e-commerce orders, inventory systems, and any multi-level data structures requiring granular processing.

## Learning Objectives

By completing this step, you'll understand:

✅ **Nested Structure Analysis** - Identify splittable arrays within complex hierarchies  
✅ **Multi-Level Context Preservation** - Store parent, sibling, and metadata context  
✅ **Hierarchical Data Reconstruction** - Rebuild complete records with full context  
✅ **Complex Field Mapping** - Handle deeply nested fields and relationships  
✅ **Business Logic Integration** - Apply domain-specific rules to split data

## The Problem: E-Commerce Order Processing

E-commerce platforms receive complex order structures containing multiple levels of nested data. Each order contains line items that need individual processing for inventory, fulfillment, and analytics:

```json title="Input: Complex e-commerce order"
{
  "order_id": "order-12345",
  "customer": {
    "customer_id": "customer-001",
    "email": "john.doe@example.com",
    "tier": "premium",
    "address": {
      "street": "123 Main St",
      "city": "San Francisco", 
      "state": "CA",
      "zip": "94105",
      "country": "US"
    }
  },
  "order_metadata": {
    "order_date": "2025-10-20T09:00:00Z",
    "channel": "web",
    "currency": "USD",
    "tax_rate": 0.0875,
    "discount_code": "SAVE20"
  },
  "items": [
    {
      "sku": "WIDGET-A",
      "product_name": "Premium Widget",
      "quantity": 5,
      "unit_price": 19.99,
      "warehouse": "US-EAST",
      "category": "electronics",
      "vendor": "ACME Corp"
    },
    {
      "sku": "GADGET-B", 
      "product_name": "Smart Gadget",
      "quantity": 2,
      "unit_price": 49.99,
      "warehouse": "EU-WEST",
      "category": "electronics",
      "vendor": "TechCo"
    },
    {
      "sku": "TOOL-C",
      "product_name": "Professional Tool",
      "quantity": 1,
      "unit_price": 129.99, 
      "warehouse": "US-WEST",
      "category": "tools",
      "vendor": "ToolMaker"
    }
  ],
  "shipping": {
    "method": "standard",
    "carrier": "FedEx", 
    "tracking_number": "1234567890",
    "estimated_delivery": "2025-10-25T17:00:00Z"
  },
  "payment": {
    "method": "credit_card",
    "last_four": "1234",
    "processor": "stripe",
    "transaction_id": "txn_abc123"
  }
}
```

**Processing challenges:**
- Can't route items to different warehouses based on inventory location
- Can't apply vendor-specific processing rules per line item
- Can't track individual item fulfillment status and analytics
- Can't implement per-item pricing, tax, and discount calculations

**Business impact:**
- Inventory allocation and fulfillment delays due to batch processing
- Unable to implement per-warehouse routing and SLA requirements  
- Complex order analytics impossible without individual item metrics
- Vendor-specific compliance and processing requirements not enforceable

## The Solution: Nested Context Preservation

Nested structure splitting requires careful analysis of what context to preserve at each level and how to reconstruct meaningful individual messages:

### Core Pattern: Analyze → Preserve → Split → Reconstruct

```yaml
pipeline:
  processors:
    # Step 1: Analyze structure and validate
    - mapping: |
        if !this.order_id.exists() {
          throw("order_id is required")
        }
        
        if !this.items.exists() || this.items.type() != "array" {
          throw("items must be an array")
        }
        
        root = this

    # Step 2: Store multi-level context in metadata
    - mapping: |
        # Order-level context  
        meta order_id = this.order_id
        meta order_date = this.order_metadata.order_date
        meta order_channel = this.order_metadata.channel
        meta currency = this.order_metadata.currency
        meta tax_rate = this.order_metadata.tax_rate
        meta discount_code = this.order_metadata.discount_code
        
        # Customer context
        meta customer_id = this.customer.customer_id
        meta customer_email = this.customer.email
        meta customer_tier = this.customer.tier
        meta customer_address = this.customer.address.encode("json")
        
        # Shipping context
        meta shipping_method = this.shipping.method
        meta shipping_carrier = this.shipping.carrier
        meta tracking_number = this.shipping.tracking_number
        meta estimated_delivery = this.shipping.estimated_delivery
        
        # Payment context
        meta payment_method = this.payment.method
        meta payment_processor = this.payment.processor
        meta transaction_id = this.payment.transaction_id
        
        root = this

    # Step 3: Split items array
    - unarchive:
        format: json_array
        field: items

    # Step 4: Reconstruct complete line item messages
    - mapping: |
        root = this
        
        # Restore order context
        root.order_id = meta("order_id")
        root.order_date = meta("order_date")
        root.order_channel = meta("order_channel") 
        root.currency = meta("currency")
        root.tax_rate = meta("tax_rate").number()
        root.discount_code = meta("discount_code")
        
        # Restore customer context
        root.customer_id = meta("customer_id")
        root.customer_email = meta("customer_email")
        root.customer_tier = meta("customer_tier")
        root.customer_address = meta("customer_address").decode("json")
        
        # Restore shipping context
        root.shipping_method = meta("shipping_method")
        root.shipping_carrier = meta("shipping_carrier")
        root.tracking_number = meta("tracking_number")
        root.estimated_delivery = meta("estimated_delivery")
        
        # Restore payment context  
        root.payment_method = meta("payment_method")
        root.payment_processor = meta("payment_processor")
        root.transaction_id = meta("transaction_id")
```

## Implementation: Complete Order Item Processor

Let's build a comprehensive order processing pipeline with business logic, calculations, and routing:

```yaml title="order-item-processor.yaml"
name: order-item-processor
description: Split complex e-commerce orders into individual line items with full context
type: pipeline
namespace: production

config:
  input:
    http_server:
      address: 0.0.0.0:8080
      path: /orders
      timeout: 15s
      allowed_verbs: [POST]
      
  pipeline:
    processors:
      # Step 1: Comprehensive structure validation
      - mapping: |
          # Validate required top-level fields
          if !this.order_id.exists() || this.order_id.string() == "" {
            throw("order_id is required and cannot be empty")
          }
          
          if !this.customer.customer_id.exists() {
            throw("customer.customer_id is required")
          }
          
          if !this.items.exists() || this.items.type() != "array" {
            throw("items must be an array")
          }
          
          # Validate items array
          let item_count = this.items.length()
          if $item_count == 0 {
            throw("orders must contain at least one item")
          }
          
          if $item_count > 100 {
            throw("orders cannot exceed 100 items (got " + $item_count.string() + ")")
          }
          
          # Validate item structure
          range this.items | {
            if !this.sku.exists() || this.sku.string() == "" {
              throw("all items must have a non-empty sku")
            }
            
            if !this.quantity.exists() || this.quantity.number() <= 0 {
              throw("all items must have a positive quantity")  
            }
            
            if !this.unit_price.exists() || this.unit_price.number() <= 0 {
              throw("all items must have a positive unit_price")
            }
          }
          
          root = this

      # Step 2: Store comprehensive context metadata  
      - mapping: |
          # Order metadata
          meta order_id = this.order_id
          meta order_date = this.order_metadata.order_date.or(now())
          meta order_channel = this.order_metadata.channel.or("unknown")
          meta currency = this.order_metadata.currency.or("USD")
          meta tax_rate = this.order_metadata.tax_rate.or(0).number()
          meta discount_code = this.order_metadata.discount_code.or("")
          meta total_items = this.items.length()
          
          # Customer context with nested address
          meta customer_id = this.customer.customer_id
          meta customer_email = this.customer.email.or("")
          meta customer_tier = this.customer.tier.or("standard")
          meta customer_address_street = this.customer.address.street.or("")
          meta customer_address_city = this.customer.address.city.or("")
          meta customer_address_state = this.customer.address.state.or("")
          meta customer_address_zip = this.customer.address.zip.or("")
          meta customer_address_country = this.customer.address.country.or("US")
          
          # Shipping information
          meta shipping_method = this.shipping.method.or("standard")
          meta shipping_carrier = this.shipping.carrier.or("") 
          meta tracking_number = this.shipping.tracking_number.or("")
          meta estimated_delivery = this.shipping.estimated_delivery.or("")
          
          # Payment information (anonymized)
          meta payment_method = this.payment.method.or("unknown")
          meta payment_processor = this.payment.processor.or("")
          meta transaction_id = this.payment.transaction_id.or("")
          
          # Calculate order totals for context
          let order_subtotal = 0
          range this.items | {
            $order_subtotal = $order_subtotal + (this.quantity.number() * this.unit_price.number())
          }
          meta order_subtotal = $order_subtotal
          
          root = this

      # Step 3: Split items array into individual line items
      - unarchive:
          format: json_array
          field: items

      # Step 4: Reconstruct complete line item with full context and calculations
      - mapping: |
          # Start with the item data
          root = this
          
          # Add order context
          root.order_id = meta("order_id")
          root.order_date = meta("order_date")  
          root.order_channel = meta("order_channel")
          root.currency = meta("currency")
          root.tax_rate = meta("tax_rate")
          root.discount_code = meta("discount_code")
          root.total_items_in_order = meta("total_items")
          root.order_subtotal = meta("order_subtotal")
          
          # Add customer information
          root.customer_id = meta("customer_id")
          root.customer_email = meta("customer_email")
          root.customer_tier = meta("customer_tier")
          root.customer_address = {
            "street": meta("customer_address_street"),
            "city": meta("customer_address_city"),
            "state": meta("customer_address_state"), 
            "zip": meta("customer_address_zip"),
            "country": meta("customer_address_country")
          }
          
          # Add shipping context
          root.shipping_method = meta("shipping_method")
          root.shipping_carrier = meta("shipping_carrier")
          root.tracking_number = meta("tracking_number")
          root.estimated_delivery = meta("estimated_delivery")
          
          # Add payment context
          root.payment_method = meta("payment_method")
          root.payment_processor = meta("payment_processor")
          root.transaction_id = meta("transaction_id")
          
          # Calculate line item totals and business logic
          root.line_subtotal = this.quantity.number() * this.unit_price.number()
          root.line_tax = root.line_subtotal * meta("tax_rate").number()
          root.line_total = root.line_subtotal + root.line_tax
          
          # Apply business rules and classifications
          root.item_priority = match {
            this.category == "electronics" && root.line_total >= 100 => "high"
            this.category == "tools" => "medium"
            root.line_total >= 50 => "medium"
            _ => "standard"
          }
          
          # Warehouse routing logic
          root.fulfillment_region = match {
            this.warehouse.has_prefix("US") => "north_america"
            this.warehouse.has_prefix("EU") => "europe" 
            this.warehouse.has_prefix("ASIA") => "asia_pacific"
            _ => "global"
          }
          
          # Vendor processing requirements
          root.vendor_sla_hours = match {
            this.vendor == "ACME Corp" => 24
            this.vendor == "TechCo" => 48
            _ => 72
          }
          
          # Customer tier benefits
          root.expedited_shipping = meta("customer_tier") == "premium" && 
                                   meta("shipping_method") == "standard"
          
          # Processing metadata
          root.processed_at = now()
          root.line_item_sequence = count("line_sequence_" + meta("order_id"))
          root.processing_node = hostname()
          
          # Generate unique line item identifier
          root.line_item_id = meta("order_id") + "-line-" + 
                             root.line_item_sequence.string()

  output:
    switch:
      cases:
        # High priority items: Immediate fulfillment processing
        - check: this.item_priority == "high"
          output:
            broker:
              pattern: fan_out
              outputs:
                # Priority fulfillment queue
                - kafka:
                    addresses: ["${KAFKA_BROKERS}"]
                    topic: fulfillment-priority
                    key: ${!json("warehouse")}
                    headers:
                      priority: "high"
                      warehouse: ${!json("warehouse")}
                      customer_tier: ${!json("customer_tier")}
                    batching:
                      count: 10
                      period: 5s
                
                # Inventory allocation service
                - http_client:
                    url: ${INVENTORY_SERVICE_URL}/allocate
                    verb: POST
                    headers:
                      Authorization: Bearer ${INVENTORY_API_KEY}
                      X-Request-Priority: high
                    timeout: 10s
                    batching:
                      count: 1
                      period: 1s

        # European fulfillment: Regional processing
        - check: this.fulfillment_region == "europe"
          output:
            kafka:
              addresses: ["${EU_KAFKA_BROKERS}"]
              topic: eu-fulfillment
              key: ${!json("warehouse")}
              headers:
                region: "europe"
                gdpr_compliant: "true"
                currency: ${!json("currency")}
              batching:
                count: 50
                period: 30s
                compression: snappy

        # Vendor-specific processing  
        - check: this.vendor == "ACME Corp"
          output:
            http_client:
              url: ${ACME_VENDOR_WEBHOOK}
              verb: POST
              headers:
                Vendor-ID: ACME
                SLA-Hours: ${!json("vendor_sla_hours")}
                Authorization: Bearer ${ACME_API_KEY}
              timeout: 15s
              batching:
                count: 25
                period: 60s

        # Standard fulfillment: Regular processing
        - output:
            kafka:
              addresses: ["${KAFKA_BROKERS}"]
              topic: fulfillment-standard
              key: ${!json("warehouse")}
              partition: ${!json("warehouse").hash("xxhash64").mod(10)}
              batching:
                count: 200
                period: 300s
                compression: lz4
```

## Advanced Nested Processing Patterns

### Pattern 1: Multiple Array Splitting

Handle orders with multiple array types (items, discounts, payments):

```yaml
pipeline:
  processors:
    # Store base context
    - mapping: |
        meta order_id = this.order_id
        meta customer_id = this.customer_id
        root = this

    # Process items first
    - branch:
        request_map: |
          root = {
            "type": "item",
            "order_context": {
              "order_id": this.order_id,
              "customer_id": this.customer_id
            },
            "data": this.items
          }
        processors:
          - unarchive:
              format: json_array
              field: data
          - mapping: |
              root = this.data
              root.record_type = "line_item"
              root.order_id = this.order_context.order_id
              root.customer_id = this.order_context.customer_id

    # Process applied discounts separately
    - branch:
        request_map: |
          if this.applied_discounts.exists() && this.applied_discounts.type() == "array" {
            root = {
              "type": "discount",
              "order_context": {
                "order_id": this.order_id,
                "customer_id": this.customer_id
              },
              "data": this.applied_discounts
            }
          } else {
            root = deleted()
          }
        processors:
          - unarchive:
              format: json_array
              field: data
          - mapping: |
              root = this.data
              root.record_type = "discount_application"
              root.order_id = this.order_context.order_id
              root.customer_id = this.order_context.customer_id
```

### Pattern 2: Conditional Nested Splitting

Split only certain nested arrays based on conditions:

```yaml
pipeline:
  processors:
    # Split items only for orders above threshold
    - mapping: |
        let total = 0
        range this.items | {
          $total = $total + (this.quantity.number() * this.unit_price.number())
        }
        
        if $total >= 1000 {
          # High-value order: Split for detailed processing
          meta order_id = this.order_id
          meta order_total = $total
          meta split_required = true
          root = this
        } else {
          # Low-value order: Process as single unit
          root = this
          root.order_total = $total
          root.processing_type = "batch"
        }

    # Conditional splitting
    - unarchive:
        format: json_array
        field: items
        # Only split if metadata indicates it's required

    # Restore context only for split items
    - mapping: |
        if meta("split_required").exists() {
          root = this
          root.order_id = meta("order_id")
          root.order_total = meta("order_total")
          root.processing_type = "individual"
        } else {
          root = this
        }
```

### Pattern 3: Hierarchical Nested Structures

Split orders containing items with their own sub-items:

```json title="Input: Order with item configurations"
{
  "order_id": "order-67890",
  "customer_id": "customer-002",
  "items": [
    {
      "sku": "COMPUTER-A",
      "quantity": 1,
      "configurations": [
        {"component": "RAM", "spec": "16GB DDR4"},
        {"component": "SSD", "spec": "1TB NVMe"},
        {"component": "GPU", "spec": "RTX 4080"}
      ]
    },
    {
      "sku": "MONITOR-B", 
      "quantity": 2,
      "configurations": [
        {"component": "SIZE", "spec": "27 inch"},
        {"component": "RESOLUTION", "spec": "4K"}
      ]
    }
  ]
}
```

```yaml
pipeline:
  processors:
    # First level: Split main items
    - mapping: |
        meta order_id = this.order_id
        meta customer_id = this.customer_id
        root = this

    - unarchive:
        format: json_array
        field: items

    # Store item context for configuration splitting
    - mapping: |
        meta item_sku = this.sku
        meta item_quantity = this.quantity
        root = this

    # Second level: Split configurations if they exist
    - branch:
        request_map: |
          if this.configurations.exists() && this.configurations.type() == "array" {
            root = this.configurations
          } else {
            root = [{"component": "base", "spec": "standard"}]
          }
        processors:
          - unarchive:
              format: json_array
          - mapping: |
              root = this
              # Restore all context levels
              root.order_id = meta("order_id")
              root.customer_id = meta("customer_id")
              root.item_sku = meta("item_sku")
              root.item_quantity = meta("item_quantity")
              root.config_component = this.component
              root.config_spec = this.spec
```

## Business Logic Integration

### E-Commerce Inventory Allocation

Split orders with sophisticated inventory logic:

```yaml
pipeline:
  processors:
    - mapping: |
        # Store context and calculate inventory needs
        meta order_id = this.order_id
        meta customer_tier = this.customer.tier
        meta order_priority = match {
          this.customer.tier == "premium" => "high"
          this.order_metadata.channel == "mobile" => "medium"
          _ => "standard"
        }
        root = this

    - unarchive:
        format: json_array
        field: items

    - mapping: |
        root = this
        root.order_id = meta("order_id")
        root.customer_tier = meta("customer_tier")
        root.order_priority = meta("order_priority")
        
        # Calculate inventory requirements
        root.inventory_needed = this.quantity.number()
        root.inventory_critical = this.quantity.number() > 10
        
        # Determine warehouse priority
        root.warehouse_priority = match {
          # Premium customers get priority allocation
          meta("customer_tier") == "premium" => 1
          # High quantity orders get secondary priority  
          this.quantity.number() >= 5 => 2
          _ => 3
        }
        
        # Calculate expected ship date based on availability
        root.expected_ship_date = match {
          this.warehouse == "US-EAST" && root.warehouse_priority == 1 => 
            now().add_duration("24h")
          this.warehouse == "US-EAST" => 
            now().add_duration("48h")
          _ => 
            now().add_duration("72h")
        }
```

### Multi-Currency Tax Calculations

Handle complex tax calculations for international orders:

```yaml
pipeline:
  processors:
    - mapping: |
        # Store order-level tax context
        meta base_currency = this.order_metadata.currency
        meta customer_country = this.customer.address.country
        meta order_date = this.order_metadata.order_date
        root = this

    - unarchive:
        format: json_array
        field: items

    - mapping: |
        root = this
        root.base_currency = meta("base_currency")
        root.customer_country = meta("customer_country")
        
        # Calculate line totals
        root.line_subtotal = this.quantity.number() * this.unit_price.number()
        
        # Apply country-specific tax rates
        root.tax_rate = match {
          meta("customer_country") == "US" => 0.0875  # 8.75% average US rate
          meta("customer_country") == "CA" => 0.13    # 13% Canadian GST/HST
          meta("customer_country") == "GB" => 0.20    # 20% UK VAT
          meta("customer_country") == "DE" => 0.19    # 19% German VAT
          _ => 0.0  # No tax for other countries
        }
        
        # Calculate tax amount
        root.line_tax = root.line_subtotal * root.tax_rate
        root.line_total = root.line_subtotal + root.line_tax
        
        # Add currency conversion if needed
        root.requires_currency_conversion = meta("base_currency") != "USD"
        
        # Calculate international shipping surcharge
        root.international_shipping = meta("customer_country") != "US"
        root.shipping_surcharge = match {
          root.international_shipping == true => root.line_subtotal * 0.05
          _ => 0.0
        }
```

## Performance Optimization for Nested Structures

### Memory-Efficient Nested Processing

Optimize memory usage when processing large nested orders:

```yaml
pipeline:
  processors:
    # Validate size before processing
    - mapping: |
        let item_count = this.items.length()
        let max_items = 50  # Conservative limit for nested processing
        
        if $item_count > $max_items {
          throw("Order too large for nested processing: " + $item_count.string() + 
                " items (max: " + $max_items.string() + ")")
        }
        
        # Store only essential context to minimize metadata memory
        meta order_id = this.order_id
        meta customer_id = this.customer.customer_id
        meta currency = this.order_metadata.currency.or("USD")
        
        root = this

    - unarchive:
        format: json_array
        field: items

    # Lightweight reconstruction
    - mapping: |
        root = this
        root.order_id = meta("order_id")
        root.customer_id = meta("customer_id")
        root.currency = meta("currency")
        
        # Calculate only essential fields
        root.line_total = this.quantity.number() * this.unit_price.number()
```

### Streaming Nested Processing

For very large orders, process items as streams:

```yaml
# Use workflow branching for streaming
config:
  pipeline:
    processors:
      # Extract items for streaming
      - workflow:
          branches:
            process_items:
              request_map: |
                root = this.items
              processors:
                - unarchive:
                    format: json_array
                - mapping: |
                    # Lightweight processing per item
                    root = this
                    root.order_id = this.order_id  # Passed through workflow
                    
  output:
    # Stream items directly to output without accumulation
    kafka:
      topic: order-items-stream
      batching:
        count: 1  # Process items individually
        period: 100ms
```

## Summary

You've mastered nested structure splitting with multi-level context preservation. Key takeaways:

✅ **Context Analysis:** Identify what information each level needs from parents  
✅ **Metadata Strategy:** Store hierarchical context systematically in metadata  
✅ **Complex Reconstruction:** Rebuild complete messages with full business context  
✅ **Business Logic:** Apply domain-specific rules during the splitting process  
✅ **Performance:** Balance completeness with memory and processing efficiency

**Next:** [Step 4: Advanced Patterns](./step-4-advanced-patterns) to learn split-and-rebatch optimization and filtering techniques.
