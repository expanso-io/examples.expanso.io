---
title: "Step 3: Split Nested Structures"
sidebar_label: "Step 3: Split Nested Structures"
sidebar_position: 6
description: Apply the core splitting pattern to a nested JSON object.
keywords: [nested-json, hierarchical-data, e-commerce, order-processing]
---

# Step 3: Split Nested Structures

The "Store -> Split -> Restore" pattern you learned in Step 1 works for any JSON structure, no matter how complex. This step demonstrates how to apply that same pattern to a more realistic, nested e-commerce order.

## The Goal

You will transform a single, complex order object into multiple `line_item` messages, each containing the relevant context from the parent order.

```json title="Input: E-commerce Order"
{
  "order_id": "order-12345",
  "customer": {
    "customer_id": "customer-001",
    "email": "john.doe@example.com"
  },
  "items": [
    {
      "sku": "WIDGET-A",
      "quantity": 5,
      "unit_price": 19.99
    },
    {
      "sku": "GADGET-B",
      "quantity": 2,
      "unit_price": 49.99
    }
  ]
}
```

## Implementation

The pattern is exactly the same as before, you just need to store more context from the nested structure.

1.  **Start with the Foundation:** Copy the `order-processing-foundation.yaml` file to a new file named `order-splitter.yaml`.
    ```bash
    cp examples/data-routing/order-processing-foundation.yaml order-splitter.yaml
    ```

2.  **Add the Splitting Logic:** Open `order-splitter.yaml` and replace the entire `pipeline` section with the three-processor block below.

    ```yaml title="Insert this into order-splitter.yaml"
pipeline:
  processors:
    # 1. STORE context from the nested structure
    - mapping: |
        meta order_id = this.order_id
        meta customer_id = this.customer.customer_id
        meta customer_email = this.customer.email
        root = this

    # 2. SPLIT the 'items' array
    - unarchive:
        format: json_array
        field: items

    # 3. RESTORE the context into each new line item message
    - mapping: |
        root = this
        root.order_id = meta("order_id")
        root.customer_id = meta("customer_id")
        root.customer_email = meta("customer_email")
    ```

3.  **Deploy and Test:**
    ```bash
    # Send the test order
    curl -X POST http://localhost:8080/orders \
      -H "Content-Type: application/json" \
      -d '{ 
        "order_id": "order-12345",
        "customer": { "customer_id": "customer-001", "email": "john.doe@example.com" },
        "items": [
          { "sku": "WIDGET-A", "quantity": 5, "unit_price": 19.99 },
          { "sku": "GADGET-B", "quantity": 2, "unit_price": 49.99 }
        ]
      }'
    ```

4.  **Verify:** Check your output. You will see two separate `line_item` messages, each containing the `order_id` and customer details, demonstrating that you have successfully preserved context from a nested structure.

This scalable pattern is the key to handling complex, hierarchical data.