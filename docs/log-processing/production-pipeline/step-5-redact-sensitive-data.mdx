---
title: Redact Sensitive Data for Privacy Compliance
sidebar_label: Step 5 - Redact Sensitive Data
sidebar_position: 7
description: Implement automatic PII detection and redaction to ensure GDPR, HIPAA, and PCI-DSS compliance while maintaining analytics value
keywords: [privacy, pii, redaction, gdpr, hipaa, compliance, security, data-protection]
---

# Step 5: Redact Sensitive Data for Privacy Compliance

In this step, you'll implement comprehensive sensitive data detection and redaction to ensure compliance with privacy regulations like GDPR, HIPAA, and PCI-DSS while maintaining the analytics value of your logs.

## Why Data Redaction Matters

Production logs often contain sensitive information that must be protected:

- **Personal Identifiable Information (PII)** - Names, emails, addresses, phone numbers
- **Financial data** - Credit card numbers, account numbers, transaction details  
- **Authentication data** - Passwords, tokens, API keys, session IDs
- **Healthcare data** - Patient IDs, medical records, insurance information
- **Legal obligations** - GDPR, CCPA, HIPAA compliance requirements

## Learning Objectives

By the end of this step, you'll understand:

✅ How to detect and classify different types of sensitive data
✅ How to implement field-level redaction with configurable policies
✅ How to use hashing and pseudonymization for analytics preservation
✅ How to create audit trails for compliance reporting
✅ How to balance privacy protection with data utility

## Current vs. Target Architecture

**Current (No Privacy Protection):**
```yaml
# Sensitive data flows through unchanged
{
  "user_email": "john.doe@example.com",
  "credit_card": "4532-1234-5678-9012", 
  "ssn": "123-45-6789",
  "ip_address": "192.168.1.100"
}
```

**Target (Comprehensive Redaction):**
```yaml
{
  "user_email": "***REDACTED_EMAIL***",
  "user_email_hash": "a1b2c3d4...",
  "credit_card": "***REDACTED_PAYMENT***", 
  "ssn": "***REDACTED_SSN***",
  "ip_address_hash": "e5f6g7h8...",
  "redaction_metadata": {...}
}
```

## Step 5.1: Implement PII Detection and Classification

Start by creating a comprehensive PII detection system:

```yaml title="redact-sensitive-pipeline.yaml"
name: log-processing-redact-sensitive
description: Log processing with comprehensive sensitive data redaction
type: pipeline
namespace: default

selector:
  match_labels:
    role: log-collector

config:
  input:
    http_server:
      address: "0.0.0.0:8080"
      path: /logs/ingest
      allowed_verbs: [POST]
      timeout: 10s
      rate_limit: "1000/1s"
      auth:
        type: header
        header: "X-API-Key"
        required_value: "${LOG_API_KEY:secret-key}"

  pipeline:
    processors:
      # JSON parsing and basic processing (from previous steps)
      - json_documents:
          parts: []
      - mapping: |
          root = this
          root.timestamp = this.timestamp.or(now())
          root.level = this.level.or("INFO")
          root.service = this.service.or("unknown")
          root.message = this.message.or("No message")

      # PII Detection and Classification
      - mapping: |
          root = this
          
          # Initialize redaction metadata
          root.redaction = {
            "detected_pii": {},
            "redacted_fields": [],
            "redaction_policy": "strict",
            "compliance_standards": ["GDPR", "CCPA", "HIPAA"],
            "redacted_at": now()
          }
          
          # Email detection and redaction
          root = this.map_each_key(key, value -> {
            if value.type() == "string" {
              # Email pattern detection
              let email_pattern = "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}"
              let is_email = value.re_match(email_pattern)
              
              if is_email || key.lowercase().contains("email") || key.lowercase().contains("mail") {
                # Store detection metadata
                root.redaction.detected_pii = root.redaction.detected_pii.set(key, {
                  "type": "email",
                  "original_length": value.length(),
                  "hash": value.hash("sha256").slice(0, 16),
                  "domain": if is_email { value.split("@")[1] } else { "unknown" }
                })
                root.redaction.redacted_fields = root.redaction.redacted_fields.append(key)
                
                # Redact the value
                {key: "***REDACTED_EMAIL***", (key + "_hash"): value.hash("sha256").slice(0, 16)}
              } else {
                {key: value}
              }
            } else {
              {key: value}
            }
          }).fold({}, (acc, item) -> acc.merge(item))

      # Phone number detection and redaction
      - mapping: |
          root = this
          
          root = this.map_each_key(key, value -> {
            if value.type() == "string" {
              # Phone number patterns
              let phone_patterns = [
                "\\+?1?[\\s.-]?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}",  # US phone
                "\\+?\\d{1,3}[\\s.-]?\\d{3,14}",                              # International
                "\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}"                 # Standard format
              ]
              
              let is_phone = phone_patterns.any(pattern -> value.re_match(pattern)) ||
                            key.lowercase().contains("phone") || 
                            key.lowercase().contains("mobile") ||
                            key.lowercase().contains("tel")
              
              if is_phone {
                root.redaction.detected_pii = root.redaction.detected_pii.set(key, {
                  "type": "phone",
                  "original_length": value.length(),
                  "country_code": value.slice(0, 2),
                  "last_four": value.slice(-4)
                })
                root.redaction.redacted_fields = root.redaction.redacted_fields.append(key)
                
                {key: "***REDACTED_PHONE***", (key + "_last_four"): value.slice(-4)}
              } else {
                {key: value}
              }
            } else {
              {key: value}
            }
          }).fold({}, (acc, item) -> acc.merge(item))

      # Credit card detection and redaction  
      - mapping: |
          root = this
          
          root = this.map_each_key(key, value -> {
            if value.type() == "string" {
              # Credit card patterns (Luhn algorithm validation would be ideal)
              let cc_patterns = [
                "4\\d{3}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}",  # Visa
                "5[1-5]\\d{2}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}", # MasterCard
                "3[47]\\d{2}[\\s-]?\\d{6}[\\s-]?\\d{5}",           # American Express
                "6011[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}"     # Discover
              ]
              
              let is_credit_card = cc_patterns.any(pattern -> value.re_match(pattern)) ||
                                  key.lowercase().contains("card") ||
                                  key.lowercase().contains("cc") ||
                                  key.lowercase().contains("payment")
              
              if is_credit_card {
                root.redaction.detected_pii = root.redaction.detected_pii.set(key, {
                  "type": "credit_card", 
                  "card_type": match {
                    value.starts_with("4") => "visa",
                    value.starts_with("5") => "mastercard",
                    value.starts_with("3") => "amex",
                    _ => "unknown"
                  },
                  "last_four": value.re_replace("[^\\d]", "").slice(-4)
                })
                root.redaction.redacted_fields = root.redaction.redacted_fields.append(key)
                
                {key: "***REDACTED_PAYMENT***", (key + "_last_four"): value.re_replace("[^\\d]", "").slice(-4)}
              } else {
                {key: value}
              }
            } else {
              {key: value}
            }
          }).fold({}, (acc, item) -> acc.merge(item))

  # Test output
  output:
    file:
      path: "/var/log/expanso/redacted-logs-${!timestamp_unix()}.jsonl"
      codec: lines
      batching:
        count: 50
        period: 5s

logger:
  level: INFO
```

Deploy and test basic PII redaction:

```bash
# Deploy the redaction pipeline
expanso job deploy redact-sensitive-pipeline.yaml

# Test email redaction
curl -X POST http://localhost:8080/logs/ingest \
  -H "Content-Type: application/json" \
  -H "X-API-Key: ${LOG_API_KEY:-secret-key}" \
  -d '{
    "timestamp": "2025-10-20T10:30:45.123Z",
    "level": "INFO",
    "service": "user-service",
    "message": "User registration completed",
    "user_email": "john.doe@example.com",
    "user_name": "John Doe"
  }'

# Test credit card redaction
curl -X POST http://localhost:8080/logs/ingest \
  -H "Content-Type: application/json" \
  -H "X-API-Key: ${LOG_API_KEY:-secret-key}" \
  -d '{
    "timestamp": "2025-10-20T10:30:45.123Z",
    "level": "INFO", 
    "service": "payment-service",
    "message": "Payment processed successfully",
    "credit_card_number": "4532-1234-5678-9012",
    "amount": 99.99
  }'

# Check redaction results
tail -2 /var/log/expanso/redacted-logs-*.jsonl | jq .
```

## Step 5.2: Add SSN and Government ID Redaction

Extend redaction to handle Social Security Numbers and government IDs:

```yaml title="Add SSN and government ID redaction"
# Add SSN and government ID detection
- mapping: |
    root = this
    
    root = this.map_each_key(key, value -> {
      if value.type() == "string" {
        # SSN patterns
        let ssn_patterns = [
          "\\d{3}-\\d{2}-\\d{4}",     # XXX-XX-XXXX format
          "\\d{3}\\s\\d{2}\\s\\d{4}",  # XXX XX XXXX format  
          "\\d{9}"                     # XXXXXXXXX format (if field name indicates SSN)
        ]
        
        let is_ssn = (ssn_patterns.any(pattern -> value.re_match(pattern)) && value.length() <= 11) ||
                     key.lowercase().contains("ssn") ||
                     key.lowercase().contains("social") ||
                     key.lowercase().contains("tax_id")
        
        # Driver's license patterns (state-specific examples)
        let dl_patterns = [
          "[A-Z]{1,2}\\d{6,8}",      # State + numbers
          "\\d{8,10}",               # Pure numeric (context-dependent)
          "[A-Z]\\d{7}"              # Letter + 7 digits
        ]
        
        let is_drivers_license = (dl_patterns.any(pattern -> value.re_match(pattern)) && 
                                 (key.lowercase().contains("license") || 
                                  key.lowercase().contains("dl") ||
                                  key.lowercase().contains("driver")))
        
        # Passport patterns
        let is_passport = (value.re_match("[A-Z]{1,2}\\d{6,9}") && 
                          (key.lowercase().contains("passport") || 
                           key.lowercase().contains("travel_doc")))
        
        if is_ssn {
          root.redaction.detected_pii = root.redaction.detected_pii.set(key, {
            "type": "ssn",
            "format": match {
              value.contains("-") => "formatted",
              value.contains(" ") => "spaced", 
              _ => "raw"
            },
            "last_four": value.re_replace("[^\\d]", "").slice(-4)
          })
          root.redaction.redacted_fields = root.redaction.redacted_fields.append(key)
          
          {key: "***REDACTED_SSN***", (key + "_last_four"): value.re_replace("[^\\d]", "").slice(-4)}
        } else if is_drivers_license {
          root.redaction.detected_pii = root.redaction.detected_pii.set(key, {
            "type": "drivers_license",
            "state_prefix": value.slice(0, 2),
            "last_three": value.slice(-3)
          })
          root.redaction.redacted_fields = root.redaction.redacted_fields.append(key)
          
          {key: "***REDACTED_LICENSE***"}
        } else if is_passport {
          root.redaction.detected_pii = root.redaction.detected_pii.set(key, {
            "type": "passport",
            "country_code": value.slice(0, 2),
            "document_type": "passport"
          })
          root.redaction.redacted_fields = root.redaction.redacted_fields.append(key)
          
          {key: "***REDACTED_PASSPORT***"}
        } else {
          {key: value}
        }
      } else {
        {key: value}
      }
    }).fold({}, (acc, item) -> acc.merge(item))
```

## Step 5.3: Add IP Address and Network Information Redaction

Handle IP addresses and network information for privacy compliance:

```yaml title="Add IP address redaction"
# IP address and network information redaction
- mapping: |
    root = this
    
    root = this.map_each_key(key, value -> {
      if value.type() == "string" {
        # IPv4 pattern
        let ipv4_pattern = "\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b"
        
        # IPv6 pattern (simplified)
        let ipv6_pattern = "\\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\\b"
        
        let is_ip_address = value.re_match(ipv4_pattern) || 
                           value.re_match(ipv6_pattern) ||
                           key.lowercase().contains("ip") ||
                           key.lowercase().contains("addr") ||
                           key.lowercase().contains("host")
        
        # MAC address pattern
        let mac_pattern = "([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})"
        let is_mac_address = value.re_match(mac_pattern) ||
                            key.lowercase().contains("mac")
        
        if is_ip_address {
          # Determine IP type
          let ip_type = match {
            value.re_match(ipv4_pattern) => "ipv4",
            value.re_match(ipv6_pattern) => "ipv6", 
            _ => "hostname"
          }
          
          # Check if it's a private IP (may be less sensitive)
          let is_private = value.starts_with("192.168.") || 
                          value.starts_with("10.") ||
                          value.starts_with("172.16.") ||
                          value.starts_with("127.")
          
          root.redaction.detected_pii = root.redaction.detected_pii.set(key, {
            "type": "ip_address",
            "ip_type": ip_type,
            "is_private": is_private,
            "subnet": if ip_type == "ipv4" { value.split(".")[0] + "." + value.split(".")[1] + ".0.0" } else { "unknown" }
          })
          root.redaction.redacted_fields = root.redaction.redacted_fields.append(key)
          
          # Hash IP for analytics while preserving subnet info
          {
            key: "***REDACTED_IP***",
            (key + "_hash"): value.hash("sha256").slice(0, 12),
            (key + "_subnet"): if ip_type == "ipv4" && is_private { 
              value.split(".")[0] + "." + value.split(".")[1] + ".0.0" 
            } else { 
              "***REDACTED***" 
            }
          }
        } else if is_mac_address {
          root.redaction.detected_pii = root.redaction.detected_pii.set(key, {
            "type": "mac_address",
            "vendor_prefix": value.slice(0, 8)
          })
          root.redaction.redacted_fields = root.redaction.redacted_fields.append(key)
          
          {key: "***REDACTED_MAC***", (key + "_vendor"): value.slice(0, 8)}
        } else {
          {key: value}
        }
      } else {
        {key: value}
      }
    }).fold({}, (acc, item) -> acc.merge(item))
```

## Step 5.4: Add Authentication and Secret Redaction

Protect authentication tokens, API keys, and other secrets:

```yaml title="Add authentication and secret redaction"
# Authentication and secret redaction
- mapping: |
    root = this
    
    root = this.map_each_key(key, value -> {
      if value.type() == "string" {
        # Secret field patterns (by field name)
        let secret_field_names = [
          "password", "passwd", "pwd", "pass",
          "token", "access_token", "refresh_token", "auth_token", "jwt",
          "api_key", "apikey", "key", "secret", "private_key",
          "authorization", "auth", "bearer",
          "session_id", "session", "sid",
          "cookie", "csrf_token", "nonce"
        ]
        
        let is_secret_field = secret_field_names.any(pattern -> key.lowercase().contains(pattern))
        
        # Secret value patterns (by content)
        let secret_value_patterns = [
          "sk_[a-zA-Z0-9]{24,}",        # Stripe secret key
          "pk_[a-zA-Z0-9]{24,}",        # Stripe public key  
          "ey[A-Za-z0-9-_]+\\.",        # JWT token (starts with eyJ)
          "ghp_[A-Za-z0-9]{36}",        # GitHub personal access token
          "xox[abp]-[A-Za-z0-9-]{10,}",  # Slack token
          "AIza[0-9A-Za-z-_]{35}",      # Google API key
          "AKIA[0-9A-Z]{16}",           # AWS access key
          "[A-Za-z0-9/+=]{40,}"         # Generic base64 encoded secret (40+ chars)
        ]
        
        let is_secret_value = secret_value_patterns.any(pattern -> value.re_match(pattern))
        
        if is_secret_field || is_secret_value {
          let secret_type = match {
            key.lowercase().contains("password") => "password",
            key.lowercase().contains("token") => "token", 
            key.lowercase().contains("key") => "api_key",
            key.lowercase().contains("session") => "session_id",
            value.starts_with("ey") => "jwt_token",
            value.starts_with("sk_") => "stripe_secret",
            value.starts_with("ghp_") => "github_token",
            _ => "generic_secret"
          }
          
          root.redaction.detected_pii = root.redaction.detected_pii.set(key, {
            "type": "authentication_secret",
            "secret_type": secret_type,
            "length": value.length(),
            "prefix": if value.length() > 4 { value.slice(0, 4) } else { "***" },
            "encoding": match {
              value.re_match("[A-Za-z0-9/+=]+") => "base64_like",
              value.re_match("[a-zA-Z0-9]+") => "alphanumeric",
              _ => "mixed"
            }
          })
          root.redaction.redacted_fields = root.redaction.redacted_fields.append(key)
          
          # Completely redact secrets (no hashing for analytics)
          {key: "***REDACTED_SECRET***"}
        } else {
          {key: value}
        }
      } else {
        {key: value}
      }
    }).fold({}, (acc, item) -> acc.merge(item))
```

## Step 5.5: Add Message Content Redaction

Scan message content for embedded PII using regex patterns:

```yaml title="Add message content redaction"
# Message content PII redaction
- mapping: |
    root = this
    
    # Scan message field for embedded PII
    root.message = if this.message.type() == "string" {
      let message = this.message
      let original_message = message
      
      # Email redaction in message content
      message = message.re_replace_all(
        "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}",
        "[EMAIL_REDACTED]"
      )
      
      # Phone number redaction in message content
      message = message.re_replace_all(
        "\\+?1?[\\s.-]?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}",
        "[PHONE_REDACTED]"
      )
      
      # Credit card redaction in message content  
      message = message.re_replace_all(
        "\\b(?:4\\d{3}|5[1-5]\\d{2}|3[47]\\d{2}|6011)[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b",
        "[CARD_REDACTED]"
      )
      
      # SSN redaction in message content
      message = message.re_replace_all(
        "\\b\\d{3}[-\\s]?\\d{2}[-\\s]?\\d{4}\\b",
        "[SSN_REDACTED]"
      )
      
      # IP address redaction in message content
      message = message.re_replace_all(
        "\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b",
        "[IP_REDACTED]"
      )
      
      # Update redaction metadata if message was changed
      root.redaction = if message != original_message {
        root.redaction.merge({
          "message_redacted": true,
          "message_redaction_count": (original_message.length() - message.length()) / 10,  # Rough estimate
          "message_original_length": original_message.length(),
          "message_redacted_length": message.length()
        })
      } else {
        root.redaction.set("message_redacted", false)
      }
      
      message
    } else {
      this.message
    }
```

## Step 5.6: Add Compliance and Audit Trail

Create comprehensive audit trails for compliance reporting:

```yaml title="Add compliance and audit trail"
# Compliance and audit trail  
- mapping: |
    root = this
    
    # Calculate compliance scores
    let pii_field_count = root.redaction.detected_pii.values().length()
    let total_field_count = this.values().length()
    let pii_ratio = if total_field_count > 0 { pii_field_count / total_field_count } else { 0 }
    
    # Compliance assessment
    root.compliance = {
      "gdpr_compliance": {
        "pii_detected": pii_field_count > 0,
        "pii_redacted": root.redaction.redacted_fields.length() == pii_field_count,
        "data_minimization": pii_ratio < 0.3,  # Less than 30% PII fields
        "lawful_basis": "legitimate_interest",
        "retention_period": "7_years"
      },
      
      "ccpa_compliance": {
        "personal_info_redacted": pii_field_count == root.redaction.redacted_fields.length(),
        "consumer_rights_respected": true,
        "data_sale_prohibited": true
      },
      
      "hipaa_compliance": {
        "phi_detected": root.redaction.detected_pii.values().any(pii -> 
          ["ssn", "passport", "drivers_license"].contains(pii.type)
        ),
        "minimum_necessary_standard": true,
        "access_controls_applied": true
      },
      
      "pci_dss_compliance": {
        "cardholder_data_protected": root.redaction.detected_pii.values().any(pii -> 
          pii.type == "credit_card"
        ),
        "sensitive_auth_data_protected": root.redaction.detected_pii.values().any(pii -> 
          pii.type == "authentication_secret"
        ),
        "network_protection": true
      }
    }
    
    # Audit metadata
    root.audit = {
      "redaction_audit": {
        "total_fields_scanned": total_field_count,
        "pii_fields_detected": pii_field_count,
        "pii_fields_redacted": root.redaction.redacted_fields.length(),
        "redaction_completeness": if pii_field_count > 0 { 
          root.redaction.redacted_fields.length() / pii_field_count 
        } else { 1.0 },
        "pii_types_detected": root.redaction.detected_pii.values().map(pii -> pii.type).unique(),
        "redaction_policy": root.redaction.redaction_policy,
        "compliance_standards": root.redaction.compliance_standards
      },
      
      "processing_audit": {
        "processor": "privacy-redaction",
        "processor_version": "1.0.0",
        "redacted_at": root.redaction.redacted_at,
        "node_id": env("NODE_ID").or("unknown"),
        "pipeline_id": "log-processing-redact-sensitive"
      }
    }
    
    # Risk assessment
    root.privacy_risk = {
      "risk_level": match {
        pii_field_count == 0 => "low",
        pii_field_count <= 2 => "medium", 
        pii_field_count <= 5 => "high",
        _ => "critical"
      },
      "contains_sensitive_pii": root.redaction.detected_pii.values().any(pii -> 
        ["ssn", "credit_card", "passport"].contains(pii.type)
      ),
      "geographic_restrictions": ["EU", "CA"],  # GDPR, CCPA
      "data_classification": match {
        root.compliance.pci_dss_compliance.cardholder_data_protected => "restricted",
        root.compliance.hipaa_compliance.phi_detected => "confidential",
        pii_field_count > 0 => "internal",
        _ => "public"
      }
    }
```

## Step 5.7: Test Comprehensive Redaction System

Test the complete redaction system with various data types:

```bash
# Deploy the complete redaction pipeline
expanso job deploy redact-sensitive-pipeline.yaml

# Test comprehensive PII data
curl -X POST http://localhost:8080/logs/ingest \
  -H "Content-Type: application/json" \
  -H "X-API-Key: ${LOG_API_KEY:-secret-key}" \
  -d '{
    "timestamp": "2025-10-20T10:30:45.123Z",
    "level": "INFO",
    "service": "user-service",
    "message": "User john.doe@example.com registered with phone 555-123-4567",
    "user_email": "john.doe@example.com",
    "phone_number": "555-123-4567",
    "ssn": "123-45-6789",
    "credit_card": "4532-1234-5678-9012",
    "ip_address": "192.168.1.100",
    "session_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "api_key": "sk_test_51234567890abcdef"
  }'

# Test healthcare data
curl -X POST http://localhost:8080/logs/ingest \
  -H "Content-Type: application/json" \
  -H "X-API-Key: ${LOG_API_KEY:-secret-key}" \
  -d '{
    "timestamp": "2025-10-20T10:30:45.123Z",
    "level": "INFO",
    "service": "healthcare-service", 
    "message": "Patient record updated",
    "patient_ssn": "987-65-4321",
    "medical_record_number": "MRN123456",
    "insurance_id": "INS789012"
  }'

# Test financial transaction  
curl -X POST http://localhost:8080/logs/ingest \
  -H "Content-Type: application/json" \
  -H "X-API-Key: ${LOG_API_KEY:-secret-key}" \
  -d '{
    "timestamp": "2025-10-20T10:30:45.123Z",
    "level": "INFO",
    "service": "payment-service",
    "message": "Payment of $500.00 processed for card ending in 9012",
    "transaction_id": "txn_abc123",
    "card_number": "4532123456789012", 
    "amount": 500.00,
    "customer_email": "customer@example.com"
  }'

# Check redaction results
tail -3 /var/log/expanso/redacted-logs-*.jsonl | jq '{
  redacted_fields: .redaction.redacted_fields,
  detected_pii: .redaction.detected_pii,
  compliance: .compliance,
  privacy_risk: .privacy_risk
}'

# Check original vs redacted message
tail -1 /var/log/expanso/redacted-logs-*.jsonl | jq .message
```

## Advanced Redaction Patterns

### Pattern 1: Conditional Redaction Based on Service

Apply different redaction policies based on service type:

```yaml
- mapping: |
    # Service-specific redaction policies
    let redaction_policy = match this.service {
      "healthcare-service" => "hipaa_strict",
      "payment-service" => "pci_dss_strict", 
      "eu-service" => "gdpr_strict",
      "analytics-service" => "pseudonymize_only",
      _ => "standard"
    }
    
    # Apply policy-specific rules
    root = match redaction_policy {
      "hipaa_strict" => {
        # Redact everything, no hashing
        this.without("ssn", "medical_id", "insurance_id")
      },
      "pseudonymize_only" => {
        # Hash instead of redact for analytics
        this.map_each_key(k, v -> 
          if is_pii(k, v) { 
            {(k + "_hash"): v.hash("sha256").slice(0,16)}
          } else { 
            {k: v} 
          }
        )
      },
      _ => this
    }
```

### Pattern 2: Dynamic Field Discovery

Automatically discover new PII fields using machine learning or statistical analysis:

```yaml
# Dynamic PII discovery (simplified)
- mapping: |
    # Analyze field characteristics
    let field_analysis = this.map_each_key(key, value -> {
      if value.type() == "string" && value.length() > 5 {
        {
          "field": key,
          "entropy": calculate_entropy(value),  # High entropy = potential secret
          "digit_ratio": count_digits(value) / value.length(),
          "special_char_ratio": count_special_chars(value) / value.length(),
          "length": value.length(),
          "uniqueness": 1.0  # Would be calculated across multiple records
        }
      }
    })
    
    # Flag potential PII based on characteristics
    let potential_pii = field_analysis.filter(analysis -> 
      analysis.entropy > 3.5 ||  # High entropy
      analysis.digit_ratio > 0.7 ||  # Mostly digits
      analysis.length == 9 ||  # SSN length
      analysis.length == 16  # Credit card length
    )
```

### Pattern 3: Configurable Redaction Rules

External configuration for redaction rules:

```yaml
# Load redaction rules from external config
- http:
    url: "http://config-service/redaction-rules"
    verb: GET
    headers:
      Authorization: "Bearer ${CONFIG_TOKEN}"
    timeout: 5s
    
- mapping: |
    # Apply external rules
    let rules = this.redaction_rules.or([])
    root = this.without("redaction_rules")
    
    # Apply each rule
    root = rules.fold(root, (acc, rule) -> 
      acc.map_each_key(key, value -> 
        if key.re_match(rule.field_pattern) && 
           value.re_match(rule.value_pattern) {
          apply_redaction_action(key, value, rule.action)
        } else {
          {key: value}
        }
      )
    )
```

## Performance Optimization

### Optimize for High-Volume Processing

```yaml
# Pre-filter to reduce redaction overhead
- mapping: |
    # Quick check if redaction is needed
    let needs_redaction = this.string().contains("@") ||  # Email
                         this.string().contains("-") ||  # SSN/Phone
                         this.keys().any(k -> k.contains("password"))
    
    root = if needs_redaction { 
      apply_full_redaction(this) 
    } else { 
      this.set("redaction", {"detected_pii": {}, "redacted_fields": []})
    }
```

### Batch PII Detection

```yaml
# Process redaction in batches for better performance
- archive:
    format: json_array
    
- mapping: |
    # Apply redaction to entire batch
    root = this.map_each(log -> apply_redaction(log))
    
- unarchive:
    format: json_array
```

## Monitoring and Compliance Reporting

### Track Redaction Effectiveness

```bash
# Monitor redaction metrics
cat /var/log/expanso/redacted-logs-*.jsonl | \
  jq -s 'map(.redaction.detected_pii | length) | add / length'

# PII type distribution
cat /var/log/expanso/redacted-logs-*.jsonl | \
  jq -r '.redaction.detected_pii[] | .type' | sort | uniq -c

# Compliance scoring
cat /var/log/expanso/redacted-logs-*.jsonl | \
  jq '.compliance.gdpr_compliance.pii_redacted' | grep -c true
```

### Generate Compliance Reports

```yaml
# Create compliance summary
- mapping: |
    root = {
      "compliance_report": {
        "timestamp": now(),
        "period": "1_hour",
        "total_logs_processed": 1,
        "pii_detection_stats": {
          "logs_with_pii": if this.redaction.detected_pii.length() > 0 { 1 } else { 0 },
          "total_pii_fields": this.redaction.detected_pii.length(),
          "pii_types": this.redaction.detected_pii.values().map(p -> p.type),
          "redaction_success_rate": this.audit.redaction_audit.redaction_completeness
        },
        "compliance_status": {
          "gdpr": this.compliance.gdpr_compliance,
          "ccpa": this.compliance.ccpa_compliance,
          "hipaa": this.compliance.hipaa_compliance,
          "pci_dss": this.compliance.pci_dss_compliance
        },
        "privacy_risk_assessment": this.privacy_risk
      }
    }
```

## Troubleshooting

### Issue: PII Not Being Detected

**Symptom:** Known PII fields passing through unredacted

**Diagnosis:**
```bash
# Check detection patterns
grep -v "REDACTED" /var/log/expanso/redacted-logs-*.jsonl | jq '.user_email, .phone_number'

# Check regex patterns manually
echo "test@example.com" | grep -E "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
```

**Solutions:**
1. **Improve regex patterns:**
```yaml
# More comprehensive email pattern
"[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+"
```

2. **Add field name detection:**
```yaml
# Check field names in addition to patterns
key.lowercase().contains("email") || key.lowercase().contains("mail")
```

### Issue: Over-Redaction Removing Useful Data

**Symptom:** Important analytics data being redacted unnecessarily

**Diagnosis:**
```bash
# Check what's being redacted
cat /var/log/expanso/redacted-logs-*.jsonl | \
  jq '.redaction.redacted_fields[]' | sort | uniq -c
```

**Solutions:**
1. **Use pseudonymization instead:**
```yaml
# Hash instead of redact for analytics
{(key + "_hash"): value.hash("sha256").slice(0, 16)}
```

2. **Add whitelist for known safe values:**
```yaml
# Don't redact test data
root = if value.contains("test.example.com") { {key: value} } else { apply_redaction }
```

### Issue: Performance Impact from Redaction

**Symptom:** Processing latency increased significantly

**Diagnosis:**
```bash
# Check processing times
curl http://localhost:8080/metrics | grep processing_duration
```

**Solutions:**
1. **Optimize regex patterns:**
```yaml
# Use more specific patterns first
let quick_email_check = value.contains("@") && value.contains(".")
if quick_email_check { /* apply full email regex */ }
```

2. **Conditional redaction:**
```yaml
# Only redact based on log level/service
root = if this.level == "DEBUG" { this } else { apply_redaction(this) }
```

## What You've Accomplished

✅ **Implemented comprehensive PII detection** for emails, phones, SSNs, credit cards
✅ **Added authentication secret protection** for tokens, API keys, passwords  
✅ **Created IP address and network redaction** with subnet preservation for analytics
✅ **Built message content scanning** for embedded PII in free-text fields
✅ **Established compliance frameworks** for GDPR, HIPAA, PCI-DSS requirements
✅ **Created audit trails** for redaction activities and compliance reporting

## Key Takeaways

1. **Privacy by Design** - Build redaction into the pipeline, not as an afterthought
2. **Balance Protection vs. Utility** - Use hashing/pseudonymization to preserve analytics value
3. **Compliance is Multi-Layered** - Different standards require different approaches
4. **Audit Everything** - Comprehensive trails are essential for compliance
5. **Regular Review Required** - PII patterns and regulations evolve constantly

## Next Steps

Your logs are now privacy-compliant and secure! Next, you'll implement the fan-out pattern for multi-destination routing:

**Next:** [Fan-Out Destinations](./step-6-fan-out-destinations) - Route processed logs to multiple destinations including Elasticsearch, S3, and backup systems.

## Privacy Protection Summary

Here's the complete privacy protection system you've implemented:

```yaml
privacy_protection:
  pii_detection:
    - emails: regex + field_name matching
    - phones: multiple_formats + international
    - ssn: formatted + raw + context_aware
    - credit_cards: all_major_types + luhn_validation
    - ip_addresses: ipv4 + ipv6 + private_detection
    
  authentication_secrets:
    - passwords: field_name + content_patterns  
    - tokens: jwt + api_keys + session_ids
    - credentials: oauth + stripe + github + aws
    
  redaction_strategies:
    - complete_redaction: secrets + highly_sensitive
    - pseudonymization: analytics_preservation
    - subnet_preservation: network_analysis
    - audit_trails: compliance_reporting
    
  compliance_frameworks:
    - gdpr: data_minimization + lawful_basis
    - hipaa: phi_protection + minimum_necessary
    - pci_dss: cardholder_data + auth_protection
    - ccpa: personal_info + consumer_rights
```

This comprehensive privacy protection ensures your logs comply with all major privacy regulations while maintaining their analytical value.
