name: payment-field-encryption
description: Encrypt sensitive payment and PII data with AES-256-GCM
type: pipeline
namespace: production
labels:
  environment: production
  data-type: payments
  security: pci-dss
  encryption: enabled
priority: 200

selector:
  match_labels:
    role: payment-processor
    pci-compliant: "true"

deployment:
  strategy: rolling
  max_parallel: 1
  health_check:
    type: http
    endpoint: /ping
    interval: 30s
  auto_rollback: true

config:
  input:
    http_server:
      address: "0.0.0.0:8443"
      path: /payments/transactions
      allowed_verbs: [POST]
      timeout: 10s
      rate_limit: "500/1s"
      tls:
        enabled: true
        cert_file: /etc/expanso/certs/server.crt
        key_file: /etc/expanso/certs/server.key
        client_auth_type: require

  pipeline:
    processors:
      - json_documents: {}

      # Validate input
      - mapping: |
          root = if this.transaction_id.exists() &&
                    this.timestamp.exists() &&
                    this.payment.exists() {
            this
          } else {
            throw("Missing required fields")
          }

      # Encrypt credit card fields (see pattern guide)
      - mapping: |
          root = this
          root.payment.card_number_encrypted = if this.payment.card_number.exists() {
            this.payment.card_number.encrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
          }
          root.payment.card_last_four = if this.payment.card_number.exists() {
            this.payment.card_number.re_replace_all("[^0-9]", "").slice(-4)
          }
          root.payment.card_brand = if this.payment.card_number.exists() {
            match {
              this.payment.card_number.re_match("^4") => "visa"
              this.payment.card_number.re_match("^5[1-5]") => "mastercard"
              this.payment.card_number.re_match("^3[47]") => "amex"
              this.payment.card_number.re_match("^6(?:011|5)") => "discover"
              _ => "unknown"
            }
          }
          root.payment.cvv_encrypted = if this.payment.cvv.exists() {
            this.payment.cvv.encrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
          }
          root.payment.cardholder_name_encrypted = if this.payment.cardholder_name.exists() {
            this.payment.cardholder_name.encrypt_aes("gcm", env("CARD_ENCRYPTION_KEY"))
          }
          root.payment = this.payment.without("card_number", "cvv", "cardholder_name")

      # Encrypt PII fields (see pattern guide)
      - mapping: |
          root = this
          root.customer.ssn_encrypted = if this.customer.ssn.exists() {
            this.customer.ssn.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
          }
          root.customer.ssn_last_four = if this.customer.ssn.exists() {
            this.customer.ssn.re_replace_all("[^0-9]", "").slice(-4)
          }
          root.customer.email_encrypted = if this.customer.email.exists() {
            this.customer.email.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
          }
          root.customer.email_domain = if this.customer.email.exists() {
            this.customer.email.split("@").index(1).lowercase()
          }
          root.customer.phone_encrypted = if this.customer.phone.exists() {
            this.customer.phone.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
          }
          root.customer.phone_area_code = if this.customer.phone.exists() {
            this.customer.phone.re_replace_all("[^0-9]", "").slice(0, 3)
          }
          root.customer.date_of_birth_encrypted = if this.customer.date_of_birth.exists() {
            this.customer.date_of_birth.encrypt_aes("gcm", env("PII_ENCRYPTION_KEY"))
          }
          root.customer.birth_year = if this.customer.date_of_birth.exists() {
            this.customer.date_of_birth.split("-").index(0).number()
          }
          root.customer = this.customer.without("ssn", "email", "phone", "date_of_birth")

      # Encrypt address fields (see pattern guide)
      - mapping: |
          root = this
          root.billing_address.street_encrypted = if this.billing_address.street.exists() {
            this.billing_address.street.encrypt_aes("gcm", env("ADDRESS_ENCRYPTION_KEY"))
          }
          root.billing_address.zip_encrypted = if this.billing_address.zip.exists() {
            this.billing_address.zip.encrypt_aes("gcm", env("ADDRESS_ENCRYPTION_KEY"))
          }
          root.billing_address = this.billing_address.without("street", "zip")

      # Add encryption metadata
      - mapping: |
          root = this
          root.encryption_metadata = {
            "encrypted": true,
            "encryption_timestamp": now(),
            "key_version": env("KEY_VERSION").or("unknown"),
            "algorithm": "AES-256-GCM",
            "node_id": env("NODE_ID").or("unknown")
          }

      # Validate no plaintext sensitive data remains
      - mapping: |
          root = this
          let sensitive_found = [
            if this.payment.card_number.exists() { "payment.card_number" },
            if this.payment.cvv.exists() { "payment.cvv" },
            if this.customer.ssn.exists() { "customer.ssn" },
            if this.customer.email.exists() { "customer.email" }
          ].filter(v -> v != null)
          root = if sensitive_found.length() > 0 {
            throw("Encryption validation failed: " + sensitive_found.join(", "))
          } else {
            this
          }

  output:
    broker:
      pattern: fan_out
      outputs:
        - label: payment_processor
          http_client:
            url: "${PAYMENT_PROCESSOR_ENDPOINT:https://payment-api:8443}/transactions"
            verb: POST
            headers:
              Content-Type: application/json
              X-Encryption-Version: "${KEY_VERSION}"
            batching:
              count: 50
              period: 5s
            max_retries: 3

        - label: analytics
          http_client:
            url: "${ANALYTICS_ENDPOINT:https://analytics-api:8080}/payments"
            verb: POST
            batching:
              count: 100
              period: 10s

logger:
  level: INFO
  format: json
  static_fields:
    pipeline: payment-field-encryption
    security_level: pci-dss

metrics:
  prometheus:
    path: /metrics
