# Sliding window aggregation (5-minute windows, 1-minute slides)
resources:
  caches:
    sliding_cache:
      memory:
        default_ttl: "360s"
        max_items: 100000

pipeline:
  processors:
    - json: {}
    - mapping: |
        let event_time = this.time_bucket.parse_timestamp("2006-01-02T15:04:05Z")
        let window_starts = range(0, 5).map(offset -> {
          (event_time - duration(offset.string() + "m")).ts_format("2006-01-02T15:04:00Z")
        })

        root.sliding_windows = window_starts.map(start_time -> {
          this.merge({
            "group_key": this.sensor_id + "|" + start_time + "|5min",
            "window_start": start_time,
            "window_end": (start_time.parse_timestamp("2006-01-02T15:04:05Z") + duration("5m")).ts_format("2006-01-02T15:04:05Z")
          })
        })

    - mapping: 'root = this.sliding_windows'
    - unarchive:
        format: json_array

    - cache:
        resource: sliding_cache
        key: \${! this.group_key }
        value: \${! this }

    - group_by:
        - key: \${! this.group_key }
          value: \${! this }

    - mapping: |
        let sorted_events = this.sort_by(event -> event.time_bucket)
        let temperatures = sorted_events.map_each(e -> e.temperature_avg)

        root.sensor_id = sorted_events[0].sensor_id
        root.window_start = sorted_events[0].window_start
        root.window_end = sorted_events[0].window_end
        root.temperature_5min_avg = temperatures.mean().round(2)
        root.temperature_volatility = temperatures.stddev().round(2)

        # Trend analysis
        let first_temp = temperatures[0]
        let last_temp = temperatures[temperatures.length()-1]
        root.temperature_slope = ((last_temp - first_temp) / 5.0).round(3)
        root.temperature_trend = match {
          root.temperature_slope > 0.1 => "increasing",
          root.temperature_slope < -0.1 => "decreasing",
          _ => "stable"
        }
