apiVersion: expanso.io/v1
kind: DataPipeline
metadata:
  name: complete-field-encryption
  namespace: default
  labels:
    purpose: production_encryption
    compliance: pci_dss_gdpr_hipaa
    version: "2.0"
spec:
  processors:
    # Step 1: Input validation and service authentication
    - name: validate-input-and-authenticate
      type: mapping
      config:
        mapping: |
          # Validate required transaction structure
          root = if !this.transaction_id.exists() {
            throw("transaction_id is required")
          } else if this.transaction_id.string().length() == 0 {
            throw("transaction_id cannot be empty")
          } else {
            this
          }
          
          # Validate at least one data section exists
          let has_payment = this.payment.exists()
          let has_customer = this.customer.exists() 
          let has_address = this.billing_address.exists() || this.shipping_address.exists()
          
          root = if !has_payment && !has_customer && !has_address {
            throw("At least one of payment, customer, or address data is required")
          } else {
            this
          }
          
          # Extract service authentication context
          let service_id = metadata().http.request.headers."X-Service-ID"
          let operation_type = metadata().http.request.headers."X-Operation-Type"
          
          root.encryption_context = {
            "requesting_service": if service_id.exists() { service_id } else { "anonymous" },
            "operation_type": if operation_type.exists() { operation_type } else { "encrypt" },
            "request_timestamp": now(),
            "source_ip": metadata().http.request.remote_addr,
            "user_agent": metadata().http.request.headers."User-Agent"
          }

    # Step 2: Retrieve current encryption keys from Vault
    - name: retrieve-encryption-keys
      type: mapping
      config:
        mapping: |
          # Get current encryption keys from HashiCorp Vault
          let vault_response = http_request(
            "GET",
            env("VAULT_ADDR") + "/v1/secret/data/expanso/encryption/current",
            {},
            {
              "X-Vault-Token": env("VAULT_TOKEN"),
              "Content-Type": "application/json"
            }
          )
          
          let key_data = vault_response.body.data.data
          
          # Validate key data exists
          root = if key_data.card_encryption_key.type() == "null" {
            throw("Card encryption key not found in Vault")
          } else if key_data.pii_encryption_key.type() == "null" {
            throw("PII encryption key not found in Vault")
          } else if key_data.address_encryption_key.type() == "null" {
            throw("Address encryption key not found in Vault")
          } else {
            this.merge({
              "encryption_keys": {
                "card_key": key_data.card_encryption_key,
                "pii_key": key_data.pii_encryption_key,
                "address_key": key_data.address_encryption_key,
                "key_version": key_data.version,
                "rotation_date": key_data.rotation_date
              }
            })
          }

    # Step 3: Encrypt payment/credit card data (PCI-DSS)
    - name: encrypt-payment-data
      type: mapping
      config:
        mapping: |
          root = this
          
          root.payment = if this.payment.exists() {
            let payment = this.payment
            let card_key = this.encryption_keys.card_key
            let key_version = this.encryption_keys.key_version
            
            # Encrypt credit card number with brand detection
            let encrypted_payment = if payment.card_number.exists() {
              let clean_card = payment.card_number.re_replace_all("[^0-9]", "")
              
              # Validate card number length (13-19 digits per ISO/IEC 7812)
              if clean_card.length() < 13 || clean_card.length() > 19 {
                throw("Invalid card number length: " + clean_card.length().string() + " digits")
              } else {
                {
                  "card_number_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(payment.card_number, card_key),
                  "card_last_four": clean_card.slice(-4),
                  "card_brand": if clean_card.has_prefix("4") {
                    "visa"
                  } else if clean_card.re_match("^5[1-5].*") {
                    "mastercard"
                  } else if clean_card.re_match("^3[47].*") {
                    "american_express"
                  } else if clean_card.re_match("^6(?:011|5).*") {
                    "discover"
                  } else if clean_card.re_match("^(?:2131|1800|35).*") {
                    "jcb"
                  } else {
                    "unknown"
                  }
                }
              }
            } else { {} }
            
            # Encrypt CVV (must not be stored per PCI-DSS)
            let cvv_encrypted = if payment.cvv.exists() {
              if !payment.cvv.re_match("^[0-9]{3,4}$") {
                throw("CVV must be 3-4 digits, got: " + payment.cvv)
              } else {
                {"cvv_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(payment.cvv, card_key)}
              }
            } else { {} }
            
            # Encrypt cardholder name
            let name_encrypted = if payment.cardholder_name.exists() {
              if payment.cardholder_name.trim().length() == 0 {
                throw("cardholder_name cannot be empty")
              } else {
                {"cardholder_name_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(payment.cardholder_name.trim().uppercase(), card_key)}
              }
            } else { {} }
            
            # Preserve non-sensitive payment fields
            let preserved_fields = payment.filter_keys(key -> ![
              "card_number", "cvv", "cardholder_name"
            ].contains(key))
            
            # Combine encrypted and preserved fields
            preserved_fields.merge(encrypted_payment).merge(cvv_encrypted).merge(name_encrypted)
          } else {
            this.payment
          }

    # Step 4: Encrypt customer PII data (GDPR/CCPA)
    - name: encrypt-customer-pii
      type: mapping
      config:
        mapping: |
          root = this
          
          root.customer = if this.customer.exists() {
            let customer = this.customer
            let pii_key = this.encryption_keys.pii_key
            let key_version = this.encryption_keys.key_version
            
            # Encrypt SSN with validation and last-4 preservation
            let ssn_encrypted = if customer.ssn.exists() {
              let clean_ssn = customer.ssn.re_replace_all("[^0-9]", "")
              if clean_ssn.length() != 9 {
                throw("SSN must be 9 digits, got: " + clean_ssn.length().string() + " from: " + customer.ssn)
              } else if clean_ssn.slice(0, 3) == "000" || clean_ssn.slice(0, 3) == "666" || clean_ssn.has_prefix("9") {
                throw("Invalid SSN area number: " + clean_ssn.slice(0, 3))
              } else {
                {
                  "ssn_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(customer.ssn, pii_key),
                  "ssn_last_four": clean_ssn.slice(-4),
                  "ssn_area": clean_ssn.slice(0, 3)
                }
              }
            } else { {} }
            
            # Encrypt email with domain preservation for B2B analytics
            let email_encrypted = if customer.email.exists() {
              let email = customer.email.lowercase()
              if !email.re_match("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$") {
                throw("Invalid email format: " + email)
              } else {
                let domain = email.split("@")[1]
                {
                  "email_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(email, pii_key),
                  "email_domain": domain,
                  "email_provider": if [
                    "gmail.com", "yahoo.com", "hotmail.com", "outlook.com", 
                    "aol.com", "icloud.com", "protonmail.com"
                  ].contains(domain) { "personal" } else { "business" },
                  "email_username_length": email.split("@")[0].length()
                }
              }
            } else { {} }
            
            # Encrypt phone with area code preservation for geographic analytics
            let phone_encrypted = if customer.phone.exists() {
              let clean_phone = customer.phone.re_replace_all("[^0-9+]", "")
              if !clean_phone.re_match("^\\+?1?[0-9]{10,11}$") {
                throw("Invalid phone format: " + customer.phone + " (cleaned: " + clean_phone + ")")
              } else {
                # Extract area code for US/Canada numbers
                let area_code = if clean_phone.has_prefix("+1") {
                  clean_phone.slice(2, 5)
                } else if clean_phone.has_prefix("1") && clean_phone.length() == 11 {
                  clean_phone.slice(1, 4)
                } else if clean_phone.length() == 10 {
                  clean_phone.slice(0, 3)
                } else {
                  "unknown"
                }
                
                {
                  "phone_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(customer.phone, pii_key),
                  "phone_area_code": area_code,
                  "phone_country": if clean_phone.has_prefix("+1") || 
                                      (clean_phone.length() >= 10 && !clean_phone.has_prefix("+")) {
                    "US"
                  } else {
                    "international"
                  },
                  "phone_type": if area_code.re_match("^(800|844|855|866|877|888)$") {
                    "toll_free"
                  } else {
                    "standard"
                  }
                }
              }
            } else { {} }
            
            # Encrypt date of birth with demographic analytics preservation
            let dob_encrypted = if customer.date_of_birth.exists() {
              let dob = customer.date_of_birth
              if !dob.re_match("^[0-9]{4}-[0-9]{2}-[0-9]{2}$") {
                throw("Date of birth must be YYYY-MM-DD format, got: " + dob)
              } else {
                let parsed_date = dob.parse_timestamp("2006-01-02")
                let birth_year = parsed_date.format_timestamp("2006").number()
                let current_year = now().format_timestamp("2006").number()
                let age = current_year - birth_year
                
                # Validate reasonable age (0-120)
                if age < 0 || age > 120 {
                  throw("Invalid birth year: " + birth_year.string() + " (age: " + age.string() + ")")
                } else {
                  # Generate demographic analytics metadata
                  let age_range = if age < 18 {
                    "under_18"
                  } else if age < 25 {
                    "18_24"
                  } else if age < 35 {
                    "25_34"
                  } else if age < 45 {
                    "35_44"
                  } else if age < 55 {
                    "45_54"
                  } else if age < 65 {
                    "55_64"
                  } else {
                    "65_plus"
                  }
                  
                  {
                    "dob_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(dob, pii_key),
                    "birth_year": birth_year,
                    "age": age,
                    "age_range": age_range,
                    "generation": if birth_year >= 1997 {
                      "gen_z"
                    } else if birth_year >= 1981 {
                      "millennial"
                    } else if birth_year >= 1965 {
                      "gen_x"
                    } else if birth_year >= 1946 {
                      "baby_boomer"
                    } else {
                      "silent_generation"
                    }
                  }
                }
              }
            } else { {} }
            
            # Preserve non-sensitive customer fields
            let preserved_fields = customer.filter_keys(key -> ![
              "ssn", "email", "phone", "date_of_birth"
            ].contains(key))
            
            # Combine all encrypted and preserved data
            preserved_fields.merge(ssn_encrypted).merge(email_encrypted).merge(phone_encrypted).merge(dob_encrypted)
          } else {
            this.customer
          }

    # Step 5: Encrypt address/location data (Geographic privacy)
    - name: encrypt-address-data
      type: mapping
      config:
        mapping: |
          root = this
          
          # Encrypt billing address
          root.billing_address = if this.billing_address.exists() {
            let addr = this.billing_address
            let address_key = this.encryption_keys.address_key
            let key_version = this.encryption_keys.key_version
            
            # Encrypt street address (precise location)
            let street_encrypted = if addr.street.exists() && addr.street.string().trim().length() > 0 {
              {"street_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(addr.street.trim(), address_key)}
            } else { {} }
            
            # Encrypt ZIP code with 3-digit prefix preservation for regional analytics
            let zip_encrypted = if addr.zip.exists() {
              let zip = addr.zip.string().trim()
              let clean_zip = zip.re_replace_all("[^0-9]", "")
              let zip_prefix = if clean_zip.length() >= 5 { 
                clean_zip.slice(0, 3) 
              } else { 
                "unknown" 
              }
              
              {
                "zip_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(zip, address_key),
                "zip_prefix": zip_prefix,
                "zip_type": if clean_zip.length() == 9 { "plus4" } 
                           else if clean_zip.length() == 5 { "standard" } 
                           else { "non_us" }
              }
            } else { {} }
            
            # Preserve city, state, country for geographic analytics
            let preserved_fields = addr.filter_keys(key -> !["street", "zip"].contains(key))
            
            # Add metropolitan area and timezone for business intelligence
            let geographic_metadata = if addr.city.exists() && addr.state.exists() {
              let city = addr.city.string().lowercase()
              let state = addr.state.string().lowercase()
              
              {
                "metropolitan_area": if (city.contains("san francisco") || 
                                        city.contains("oakland") || 
                                        city.contains("palo alto") ||
                                        city.contains("san jose")) && state == "ca" {
                  "SF_Bay_Area"
                } else if (city.contains("los angeles") || 
                          city.contains("santa monica") ||
                          city.contains("beverly hills")) && state == "ca" {
                  "LA_Metro"
                } else if (city.contains("new york") || 
                          city.contains("brooklyn") ||
                          city.contains("queens") ||
                          city.contains("manhattan")) && state == "ny" {
                  "NYC_Metro"
                } else if city.contains("chicago") && state == "il" {
                  "Chicago_Metro"
                } else {
                  addr.state.string().uppercase() + "_Other"
                },
                "timezone": if ["ca", "wa", "or", "nv"].contains(state) {
                  "America/Los_Angeles"
                } else if ["ny", "nj", "ct", "ma", "fl", "ga", "va", "nc", "sc"].contains(state) {
                  "America/New_York"
                } else if ["tx", "ok", "ar", "la", "mn", "wi", "il", "in", "mi", "oh"].contains(state) {
                  "America/Chicago"
                } else if ["az", "ut", "co", "nm", "wy", "mt", "nd", "sd", "ne", "ks"].contains(state) {
                  "America/Denver"
                } else if ["ak"].contains(state) {
                  "America/Anchorage"
                } else if ["hi"].contains(state) {
                  "Pacific/Honolulu"
                } else {
                  "America/New_York"  # Default to Eastern
                }
              }
            } else { {} }
            
            preserved_fields.merge(street_encrypted).merge(zip_encrypted).merge(geographic_metadata).merge({
              "address_type": "billing"
            })
          } else {
            this.billing_address
          }
          
          # Encrypt shipping address (similar logic but separate)
          root.shipping_address = if this.shipping_address.exists() {
            let addr = this.shipping_address
            let address_key = this.encryption_keys.address_key
            let key_version = this.encryption_keys.key_version
            
            let street_encrypted = if addr.street.exists() && addr.street.string().trim().length() > 0 {
              {"street_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(addr.street.trim(), address_key)}
            } else { {} }
            
            let zip_encrypted = if addr.zip.exists() {
              let clean_zip = addr.zip.string().re_replace_all("[^0-9]", "")
              {
                "zip_encrypted": key_version + ":" + crypto.encrypt_aes256_gcm(addr.zip.string().trim(), address_key),
                "zip_prefix": if clean_zip.length() >= 5 { clean_zip.slice(0, 3) } else { "unknown" },
                "zip_type": if clean_zip.length() == 9 { "plus4" } else { "standard" }
              }
            } else { {} }
            
            let preserved_fields = addr.filter_keys(key -> !["street", "zip"].contains(key))
            preserved_fields.merge(street_encrypted).merge(zip_encrypted).merge({
              "address_type": "shipping"
            })
          } else {
            this.shipping_address
          }

    # Step 6: Add comprehensive encryption metadata for audit and compliance
    - name: add-encryption-metadata
      type: mapping
      config:
        mapping: |
          root = this
          
          # Collect all encrypted fields for audit trail
          let encrypted_fields = []
          
          # Payment fields
          if this.payment.card_number_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("payment.card_number_encrypted")
          }
          if this.payment.cvv_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("payment.cvv_encrypted")
          }
          if this.payment.cardholder_name_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("payment.cardholder_name_encrypted")
          }
          
          # Customer PII fields
          if this.customer.ssn_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("customer.ssn_encrypted")
          }
          if this.customer.email_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("customer.email_encrypted")
          }
          if this.customer.phone_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("customer.phone_encrypted")
          }
          if this.customer.dob_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("customer.dob_encrypted")
          }
          
          # Address fields
          if this.billing_address.street_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("billing_address.street_encrypted")
          }
          if this.billing_address.zip_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("billing_address.zip_encrypted")
          }
          if this.shipping_address.street_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("shipping_address.street_encrypted")
          }
          if this.shipping_address.zip_encrypted.exists() {
            encrypted_fields = encrypted_fields.append("shipping_address.zip_encrypted")
          }
          
          # Calculate encryption coverage metrics
          let total_possible_fields = 11  # Maximum possible sensitive fields
          let encryption_coverage = (encrypted_fields.length().float() / total_possible_fields.float()) * 100
          
          # Collect preserved analytics fields
          let preserved_fields = []
          if this.payment.card_last_four.exists() { preserved_fields = preserved_fields.append("payment.card_last_four") }
          if this.payment.card_brand.exists() { preserved_fields = preserved_fields.append("payment.card_brand") }
          if this.customer.ssn_last_four.exists() { preserved_fields = preserved_fields.append("customer.ssn_last_four") }
          if this.customer.email_domain.exists() { preserved_fields = preserved_fields.append("customer.email_domain") }
          if this.customer.phone_area_code.exists() { preserved_fields = preserved_fields.append("customer.phone_area_code") }
          if this.customer.birth_year.exists() { preserved_fields = preserved_fields.append("customer.birth_year") }
          if this.billing_address.zip_prefix.exists() { preserved_fields = preserved_fields.append("billing_address.zip_prefix") }
          
          # Add comprehensive metadata
          root.encryption_metadata = {
            "encrypted": true,
            "encryption_timestamp": now(),
            "encryption_version": "2.0",
            "key_version": this.encryption_keys.key_version,
            "algorithm": "AES-256-GCM",
            "node_id": env("NODE_ID"),
            "pipeline": "complete-field-encryption",
            "encrypted_fields": encrypted_fields,
            "preserved_fields": preserved_fields,
            "encrypted_field_count": encrypted_fields.length(),
            "preserved_field_count": preserved_fields.length(),
            "encryption_coverage_percent": encryption_coverage,
            "compliance_standards": ["PCI-DSS-4.0", "GDPR", "HIPAA", "CCPA", "SOX"],
            "key_rotation_date": this.encryption_keys.rotation_date,
            "requesting_service": this.encryption_context.requesting_service,
            "operation_type": this.encryption_context.operation_type,
            "data_classification": "sensitive_encrypted"
          }

    # Step 7: Generate real-time compliance metrics
    - name: generate-compliance-metrics
      type: mapping
      config:
        mapping: |
          root = this
          
          # PCI-DSS compliance assessment
          let pci_compliance = {
            "cardholder_data_encrypted": this.payment.card_number_encrypted.exists() && this.payment.cvv_encrypted.exists(),
            "cardholder_name_encrypted": this.payment.cardholder_name_encrypted.exists(),
            "key_management_compliant": this.encryption_keys.key_version.exists(),
            "access_controls_enabled": this.encryption_context.requesting_service.exists(),
            "audit_trail_complete": this.encryption_metadata.exists(),
            "cvv_not_stored": !this.payment.cvv.exists(),  # CVV should be encrypted, not stored
            "pan_masked": this.payment.card_last_four.exists()  # Only last 4 visible
          }
          
          # GDPR compliance assessment
          let gdpr_compliance = {
            "personal_data_encrypted": this.customer.email_encrypted.exists() || this.customer.phone_encrypted.exists(),
            "data_minimization": this.customer.email_domain.exists(),  # Preserved only necessary metadata
            "encryption_by_design": true,  # Encrypted at collection point
            "audit_trail_maintained": this.encryption_metadata.exists(),
            "lawful_basis_documented": true,  # Processing for legitimate business interest
            "data_subject_rights_supported": true  # Can provide metadata without decryption
          }
          
          # HIPAA compliance assessment (if applicable)
          let hipaa_compliance = {
            "phi_encrypted": this.customer.dob_encrypted.exists(),  # Date of birth is PHI
            "access_controls_implemented": this.encryption_context.requesting_service != "anonymous",
            "audit_logging_enabled": this.encryption_metadata.exists(),
            "minimum_necessary_standard": this.customer.birth_year.exists()  # Only year preserved, not full DOB
          }
          
          # Calculate overall compliance score (weighted)
          let pci_score = pci_compliance.values().fold(0, (acc, compliant) -> if compliant { acc + 14.3 } else { acc })  # 7 checks, ~14.3 points each
          let gdpr_score = gdpr_compliance.values().fold(0, (acc, compliant) -> if compliant { acc + 16.7 } else { acc })  # 6 checks, ~16.7 points each
          let hipaa_score = hipaa_compliance.values().fold(0, (acc, compliant) -> if compliant { acc + 25 } else { acc })  # 4 checks, 25 points each
          
          # Overall score (average of applicable frameworks)
          let applicable_frameworks = [pci_score, gdpr_score].length()
          let total_score = (pci_score + gdpr_score) / applicable_frameworks
          
          root.compliance_status = {
            "overall_score": total_score,
            "grade": if total_score >= 95 { "A+" }
                    else if total_score >= 90 { "A" }
                    else if total_score >= 85 { "B+" }
                    else if total_score >= 80 { "B" }
                    else if total_score >= 75 { "C+" }
                    else if total_score >= 70 { "C" }
                    else { "F" },
            "pci_dss_compliance": pci_compliance.merge({
              "score": pci_score,
              "status": if pci_score >= 90 { "compliant" } else { "non_compliant" }
            }),
            "gdpr_compliance": gdpr_compliance.merge({
              "score": gdpr_score,
              "status": if gdpr_score >= 90 { "compliant" } else { "non_compliant" }
            }),
            "hipaa_compliance": hipaa_compliance.merge({
              "score": hipaa_score,
              "status": if hipaa_score >= 90 { "compliant" } else { "non_compliant" }
            }),
            "assessment_timestamp": now(),
            "next_assessment": now().ts_add("24h").format_timestamp("2006-01-02T15:04:05Z")
          }

    # Step 8: Create comprehensive audit log entry
    - name: create-audit-log
      type: mapping
      config:
        mapping: |
          # Create detailed audit log entry for compliance
          let audit_entry = {
            "event_type": "complete_field_encryption",
            "transaction_id": this.transaction_id,
            "encryption_summary": {
              "fields_encrypted": this.encryption_metadata.encrypted_field_count,
              "coverage_percentage": this.encryption_metadata.encryption_coverage_percent,
              "algorithm": this.encryption_metadata.algorithm,
              "key_version": this.encryption_metadata.key_version
            },
            "compliance_assessment": {
              "overall_score": this.compliance_status.overall_score,
              "grade": this.compliance_status.grade,
              "pci_dss_status": this.compliance_status.pci_dss_compliance.status,
              "gdpr_status": this.compliance_status.gdpr_compliance.status
            },
            "request_context": {
              "requesting_service": this.encryption_context.requesting_service,
              "source_ip": this.encryption_context.source_ip,
              "user_agent": this.encryption_context.user_agent,
              "operation_type": this.encryption_context.operation_type
            },
            "system_context": {
              "node_id": env("NODE_ID"),
              "pipeline_version": "2.0",
              "timestamp": now(),
              "environment": env("ENVIRONMENT")
            },
            "security_classification": "sensitive_data_processed",
            "retention_period": "7_years",  # Financial record retention
            "audit_trail_id": crypto.uuid()
          }
          
          # Send to primary audit system
          let audit_response = http_request(
            "POST",
            env("AUDIT_LOG_ENDPOINT"),
            audit_entry,
            {
              "Authorization": "Bearer " + env("AUDIT_API_KEY"),
              "Content-Type": "application/json",
              "X-Audit-Source": "field_encryption_pipeline",
              "X-Compliance-Level": "high"
            }
          )
          
          # Fallback audit logging if primary fails
          if audit_response.status_code >= 400 {
            # Log locally for backup audit trail
            log.info("PRIMARY_AUDIT_FAILED - LOCAL_BACKUP: " + (audit_entry | json.encode()))
            
            # Try secondary audit endpoint if configured
            if env("AUDIT_FALLBACK_ENDPOINT").exists() {
              http_request(
                "POST",
                env("AUDIT_FALLBACK_ENDPOINT"),
                audit_entry,
                {"Authorization": "Bearer " + env("AUDIT_FALLBACK_API_KEY")}
              )
            }
          }
          
          root = this.merge({
            "audit_logged": audit_response.status_code < 400,
            "audit_trail_id": audit_entry.audit_trail_id
          })

    # Step 9: Performance monitoring and metrics
    - name: record-performance-metrics
      type: mapping
      config:
        mapping: |
          let processing_end_time = now()
          let processing_start_time = this.encryption_context.request_timestamp.parse_timestamp("2006-01-02T15:04:05Z")
          let total_processing_time = (processing_end_time - processing_start_time).duration_milliseconds()
          
          # Record performance metrics
          let performance_metrics = {
            "total_processing_time_ms": total_processing_time,
            "encryption_operations_count": this.encryption_metadata.encrypted_field_count,
            "throughput_ops_per_ms": this.encryption_metadata.encrypted_field_count / total_processing_time,
            "fields_per_second": (this.encryption_metadata.encrypted_field_count / total_processing_time) * 1000,
            "compliance_score_calculation_time_ms": 5,  # Estimated
            "audit_logging_time_ms": 10,  # Estimated
            "performance_grade": if total_processing_time <= 10 { "excellent" }
                                else if total_processing_time <= 25 { "good" }
                                else if total_processing_time <= 50 { "acceptable" }
                                else { "poor" },
            "timestamp": processing_end_time,
            "node_id": env("NODE_ID")
          }
          
          # Send metrics to monitoring system
          http_request(
            "POST",
            env("METRICS_ENDPOINT"),
            performance_metrics,
            {
              "Authorization": "Bearer " + env("METRICS_API_KEY"),
              "Content-Type": "application/json",
              "X-Metric-Type": "encryption_performance"
            }
          )
          
          # Alert if performance is degraded
          if total_processing_time > 50 {
            http_request(
              "POST",
              env("ALERT_WEBHOOK_URL"),
              {
                "alert": "encryption_performance_degraded",
                "processing_time_ms": total_processing_time,
                "threshold_ms": 50,
                "transaction_id": this.transaction_id,
                "node_id": env("NODE_ID"),
                "severity": if total_processing_time > 100 { "high" } else { "medium" }
              },
              {"Content-Type": "application/json"}
            )
          }
          
          root = this.merge({
            "performance_metrics": performance_metrics
          })

    # Step 10: Final output preparation
    - name: prepare-final-output
      type: mapping
      config:
        mapping: |
          # Remove sensitive internal data from output
          root = this.without_keys([
            "encryption_keys",     # Never expose actual keys
            "encryption_context"   # Internal processing context
          ])
          
          # Add final routing metadata
          root.routing_metadata = {
            "processed_by": "complete_field_encryption_pipeline",
            "processing_completed_at": now(),
            "downstream_services": ["payment_processor", "analytics_platform", "compliance_monitoring"],
            "data_classification": "encrypted_sensitive_data",
            "retention_policy": "financial_records_7_years",
            "geographic_restrictions": if this.customer.phone_country == "EU" { 
              ["EU_ONLY"] 
            } else { 
              ["GLOBAL"] 
            }
          }
          
          # Add success confirmation
          root.processing_status = {
            "status": "success",
            "encrypted_field_count": this.encryption_metadata.encrypted_field_count,
            "compliance_grade": this.compliance_status.grade,
            "processing_time_ms": this.performance_metrics.total_processing_time_ms,
            "audit_trail_id": this.audit_trail_id
          }

  # Input configuration for production
  input:
    http_server:
      address: "0.0.0.0:8443"
      path: /transactions/encrypt
      allowed_verbs: ["POST"]
      timeout: "30s"
      cors:
        enabled: true
        allowed_origins: ["https://app.company.com", "https://admin.company.com"]
        allowed_headers: ["Content-Type", "Authorization", "X-Service-ID", "X-Operation-Type", "X-Request-ID"]
        allowed_methods: ["POST", "OPTIONS"]
      rate_limit:
        requests_per_second: 100
        burst_size: 200
        rate_limit_key: "source_ip"  # Rate limit by source IP
      tls:
        enabled: true
        cert_file: "/etc/expanso/certs/server.crt"
        key_file: "/etc/expanso/certs/server.key"
        client_auth: "request"  # Request but don't require client certificates
        min_version: "1.2"      # Minimum TLS 1.2
        ciphers: ["TLS_AES_256_GCM_SHA384", "TLS_CHACHA20_POLY1305_SHA256"]

  # Output configuration - multiple destinations
  output:
    # Primary output to payment processor
    http_client:
      url: "${PAYMENT_PROCESSOR_ENDPOINT}"
      verb: POST
      headers:
        Content-Type: "application/json"
        Authorization: "Bearer ${PAYMENT_PROCESSOR_API_KEY}"
        X-Encryption-Pipeline: "complete_field_encryption"
        X-Data-Classification: "encrypted_sensitive"
        X-Compliance-Grade: "${compliance_status.grade}"
      timeout: "15s"
      retry_until_success: false
      max_retry_backoff: "300s"
      retry_backoff: "1s"
      batch:
        count: 1        # Send immediately, no batching for sensitive data
        byte_size: 0    # Disable size-based batching
        period: "0s"    # No time-based batching

  # Environment variables for production
  environment:
    # Infrastructure
    NODE_ID: "${NODE_ID}"
    ENVIRONMENT: "${ENVIRONMENT}"
    
    # Vault configuration  
    VAULT_ADDR: "${VAULT_ADDR}"
    VAULT_TOKEN: "${VAULT_TOKEN}"
    
    # Output endpoints
    PAYMENT_PROCESSOR_ENDPOINT: "${PAYMENT_PROCESSOR_ENDPOINT}"
    PAYMENT_PROCESSOR_API_KEY: "${PAYMENT_PROCESSOR_API_KEY}"
    
    # Audit and monitoring
    AUDIT_LOG_ENDPOINT: "${AUDIT_LOG_ENDPOINT}"
    AUDIT_API_KEY: "${AUDIT_API_KEY}"
    AUDIT_FALLBACK_ENDPOINT: "${AUDIT_FALLBACK_ENDPOINT}"
    AUDIT_FALLBACK_API_KEY: "${AUDIT_FALLBACK_API_KEY}"
    
    # Performance monitoring
    METRICS_ENDPOINT: "${METRICS_ENDPOINT}"
    METRICS_API_KEY: "${METRICS_API_KEY}"
    ALERT_WEBHOOK_URL: "${ALERT_WEBHOOK_URL}"

  # Resource allocation for production workload
  resources:
    limits:
      cpu: "2000m"      # 2 CPU cores maximum
      memory: "4Gi"     # 4GB RAM maximum
    requests:
      cpu: "500m"       # 0.5 CPU cores guaranteed
      memory: "1Gi"     # 1GB RAM guaranteed

  # Health monitoring
  health_check:
    path: "/health"
    interval_seconds: 30
    timeout_seconds: 5
    healthy_threshold: 2
    unhealthy_threshold: 3

  # Prometheus metrics exposure
  metrics:
    enabled: true
    path: "/metrics"
    labels:
      environment: "production"
      pipeline: "field_encryption"
      compliance: "pci_dss_gdpr_hipaa"
      version: "2.0"

  # Security policies
  security:
    # Network policies
    network_policy:
      enabled: true
      allow_ingress:
        - from_cidr: "10.0.0.0/8"    # Internal network only
        - from_cidr: "172.16.0.0/12" # Private networks
      allow_egress:
        - to_service: "vault"         # Vault access
        - to_service: "audit-system" # Audit logging
        - to_endpoint: "${PAYMENT_PROCESSOR_ENDPOINT}"
    
    # Pod security context
    security_context:
      run_as_non_root: true
      run_as_user: 1001
      fs_group: 1001
      seccomp_profile:
        type: "RuntimeDefault"
      capabilities:
        drop: ["ALL"]
        add: []

  # Service mesh integration (if using Istio)
  service_mesh:
    mtls:
      mode: "STRICT"    # Require mTLS for all communications
    authorization:
      enabled: true
      rules:
        - from_principals: ["payment-service", "fraud-detection", "customer-service"]
          to_operations: ["/transactions/encrypt"]
    telemetry:
      tracing: true
      metrics: true
      access_logging: true
